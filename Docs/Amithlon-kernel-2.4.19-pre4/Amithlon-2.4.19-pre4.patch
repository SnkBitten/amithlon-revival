Only in new_kernel_src: .config
Only in new_kernel_src: .config.old
Only in new_kernel_src: .depend
Only in new_kernel_src: .hdepend
Only in new_kernel_src: .menuconfig.log
Only in new_kernel_src: .version
Only in linux/Documentation: kernel-docs.txt
Only in new_kernel_src/arch/i386/kernel: .depend
diff -urp linux/arch/i386/kernel/dmi_scan.c new_kernel_src/arch/i386/kernel/dmi_scan.c
--- linux/arch/i386/kernel/dmi_scan.c	2009-06-10 21:00:34.000000000 +0100
+++ new_kernel_src/arch/i386/kernel/dmi_scan.c	2002-03-25 05:14:15.000000000 +0000
@@ -14,6 +14,8 @@
 unsigned long dmi_broken;
 int is_sony_vaio_laptop;
 
+#define XXX printk(KERN_INFO "Reached line %d\n",__LINE__);
+
 struct dmi_header
 {
 	u8	type;
@@ -21,22 +23,28 @@ struct dmi_header
 	u16	handle;
 };
 
-#define dmi_printk(x)
-//#define dmi_printk(x) printk x
+//#define dmi_printk(x)
+#define dmi_printk(x) printk x
 
 static char * __init dmi_string(struct dmi_header *dm, u8 s)
 {
 	u8 *bp=(u8 *)dm;
+	
+	XXX
 	bp+=dm->length;
+	XXX
 	if(!s)
 		return "";
+	XXX
 	s--;
 	while(s>0)
 	{
+	  XXX
 		bp+=strlen(bp);
 		bp++;
 		s--;
 	}
+	XXX
 	return bp;
 }
 
@@ -151,16 +159,25 @@ static char *dmi_ident[DMI_STRING_MAX];
 static void __init dmi_save_ident(struct dmi_header *dm, int slot, int string)
 {
 	char *d = (char*)dm;
-	char *p = dmi_string(dm, d[string]);
+	char *p;
+	
+	XXX
+	p = dmi_string(dm, d[string]);
+	XXX
 	if(p==NULL || *p == 0)
 		return;
+	XXX
 	if (dmi_ident[slot])
 		return;
-	dmi_ident[slot] = alloc_bootmem(strlen(p)+1);
+	XXX
+        dmi_ident[slot] = kmalloc(strlen(p)+1, GFP_KERNEL);
+	  //dmi_ident[slot] = alloc_bootmem(strlen(p)+1);
+	XXX
 	if(dmi_ident[slot])
 		strcpy(dmi_ident[slot], p);
 	else
 		printk(KERN_ERR "dmi_save_ident: out of memory.\n");
+	XXX
 }
 
 /*
@@ -694,7 +711,9 @@ static void __init dmi_decode(struct dmi
 			p=dmi_string(dm,data[4]);
 			if(*p)
 			{
+			  XXX
 				dmi_printk(("BIOS Vendor: %s\n", p));
+				XXX
 				dmi_save_ident(dm, DMI_BIOS_VENDOR, 4);
 				dmi_printk(("BIOS Version: %s\n", 
 					dmi_string(dm, data[5])));
diff -urp linux/arch/i386/kernel/i8259.c new_kernel_src/arch/i386/kernel/i8259.c
--- linux/arch/i386/kernel/i8259.c	2001-09-18 07:03:09.000000000 +0100
+++ new_kernel_src/arch/i386/kernel/i8259.c	2001-10-13 21:12:28.000000000 +0100
@@ -496,6 +496,7 @@ void __init init_IRQ(void)
 	outb_p(0x34,0x43);		/* binary, mode 2, LSB/MSB, ch 0 */
 	outb_p(LATCH & 0xff , 0x40);	/* LSB */
 	outb(LATCH >> 8 , 0x40);	/* MSB */
+	current_latch=LATCH;
 
 #ifndef CONFIG_VISWS
 	setup_irq(2, &irq2);
diff -urp linux/arch/i386/kernel/setup.c new_kernel_src/arch/i386/kernel/setup.c
--- linux/arch/i386/kernel/setup.c	2009-06-10 21:00:34.000000000 +0100
+++ new_kernel_src/arch/i386/kernel/setup.c	2002-03-25 04:23:07.000000000 +0000
@@ -115,6 +115,7 @@
 #include <asm/dma.h>
 #include <asm/mpspec.h>
 #include <asm/mmu_context.h>
+#include <linux/uae.h>
 /*
  * Machine setup..
  */
@@ -123,7 +124,7 @@ char ignore_irq13;		/* set if exception 
 struct cpuinfo_x86 boot_cpu_data = { 0, 0, 0, 0, -1, 1, 0, 0, -1 };
 
 unsigned long mmu_cr4_features;
-
+unsigned long zeropage=0;
 /*
  * Bus types ..
  */
@@ -708,6 +709,8 @@ static void __init setup_memory_region(v
 } /* setup_memory_region */
 
 
+static int leavepages=5120; /* Leave 20M for linux' use */
+
 static void __init parse_mem_cmdline (char ** cmdline_p)
 {
 	char c = ' ', *to = command_line, *from = COMMAND_LINE;
@@ -750,7 +753,8 @@ static void __init parse_mem_cmdline (ch
 					 */
 					e820.nr_map = 0;
 					usermem = 1;
-					add_memory_region(0, LOWMEMSIZE(), E820_RAM);
+					// Leave that lovely low memory to UAE :)
+					// add_memory_region(0, LOWMEMSIZE(), E820_RAM);
 				}
 				mem_size = memparse(from+4, &from);
 				if (*from == '@')
@@ -763,10 +767,20 @@ static void __init parse_mem_cmdline (ch
 				add_memory_region(start_at, mem_size, E820_RAM);
 			}
 		}
+		if (c == ' ' && !memcmp(from, "leavepages=", 11)) {
+		     leavepages=0;
+		     from+=11;
+		     while (*from>='0' && *from<='9') {
+			  leavepages=10*leavepages+*from-'0';
+			  from++;
+		     }
+		}
+
 		/* acpismp=force forces parsing and use of the ACPI SMP table */
 		if (c == ' ' && !memcmp(from, "acpismp=force", 13)) 	
 			 enable_acpi_smp_table = 1;
 	
+
 		c = *(from++);
 		if (!c)
 			break;
@@ -943,7 +957,15 @@ void __init setup_arch(char **cmdline_p)
 	 * reserve physical page 0 - it's a special BIOS page on many boxes,
 	 * enabling clean reboots, SMP operation, laptop functions.
 	 */
+#if 0 /* Not right now --- it makes it inaccessible for Amithlon */
 	reserve_bootmem(0, PAGE_SIZE);
+#endif
+
+	/* However, the *contents* we need to do vm86 calls later on.
+	     As AmigaOS will puke all over this page, let's get them
+	     into a nice and safe place *now*.... 0x82000 is such a place */
+	memcpy((void*)0x82000,(void*)0,0x1000);
+	zeropage=0x82000;
 
 #ifdef CONFIG_SMP
 	/*
@@ -1045,7 +1067,40 @@ void __init setup_arch(char **cmdline_p)
 	conswitchp = &dummy_con;
 #endif
 #endif
-	dmi_scan_machine();
+
+	/* 
+	 * For UAE use, we need to grab as much memory below 16M as possible.
+	 * Note that the initrd memory will be added to our pool later, so
+	 * it being reserved right now isn't a problem.
+	 */
+	{
+	     int lastfound=-1;
+	     int startblock=0;
+	     int leavelowpages=512; /* And 2M of <16M mem */
+
+	     for (i=0;i<max_low_pfn;i++) {
+		  if (bootmem_is_reserved(i<<PAGE_SHIFT))
+		       continue;
+		  if ((i<<PAGE_SHIFT)>=16*1024*1024 && leavepages) {
+		       leavepages--;
+		       continue;
+		  }
+		  if ((i<<PAGE_SHIFT)>=1*1024*1024 && leavelowpages) {
+		       leavelowpages--;
+		       continue;
+		  }
+		  reserve_bootmem(i<<PAGE_SHIFT,PAGE_SIZE);
+		  
+		  if (i!=lastfound+1) {
+		       if (startblock) {
+			    add_uae_block(startblock,lastfound);
+		       }
+		       startblock=i;
+		  }
+		  lastfound=i;
+	     }
+	     add_uae_block(startblock,lastfound);
+	}
 }
 
 static int cachesize_override __initdata = -1;
@@ -2265,6 +2320,9 @@ static void __init init_intel(struct cpu
 	}
 too_many_siblings:
 #endif
+	printk(KERN_INFO "CPU: About to head into dmi_scan_machine\n");
+	dmi_scan_machine();
+	printk(KERN_INFO "CPU: Came back dmi_scan_machine\n");
 }
 
 void __init get_cpu_vendor(struct cpuinfo_x86 *c)
diff -urp linux/arch/i386/kernel/time.c new_kernel_src/arch/i386/kernel/time.c
--- linux/arch/i386/kernel/time.c	2002-02-25 19:37:53.000000000 +0000
+++ new_kernel_src/arch/i386/kernel/time.c	2002-02-08 09:17:38.000000000 +0000
@@ -71,6 +71,15 @@ static int delay_at_last_interrupt;
 
 static unsigned long last_tsc_low; /* lsb 32 bits of Time Stamp Counter */
 
+static unsigned int handle_hiprec=0; /* As long as this is 0, we do normal
+					jiffies handling */
+static unsigned long long jiffie_time; /* When to do jiffies */
+static unsigned long long jiffie_add;   /* Cycles per jiffie */
+static unsigned long long margin;
+static unsigned long long last_target;
+
+unsigned long current_latch=~0; /* The current latch value for the timer chip */
+
 /* Cached *multiplier* to convert TSC counts to microseconds.
  * (see the equation below).
  * Equal to 2^32 * (1 / (clocks per usec) ).
@@ -383,9 +392,88 @@ static int set_rtc_mmss(unsigned long no
 
 /* last time the cmos clock got updated */
 static long last_rtc_update;
+static int use_tsc;
 
 int timer_ack;
 
+
+static inline int do_hiprec_timer(int reset_always)
+{
+	if (use_tsc)
+	{ /* Handle the high precision "timer" the is kludged on
+	     via the irq.c char driver */
+	  unsigned long low,high;
+	  unsigned long long now;
+	  unsigned long newlatch=LATCH;
+	  unsigned long long nextev;
+	  unsigned long long target;
+	  int do_jiffie=0;
+
+	  nextev=~0;
+	  rdtsc(low,high);
+	  now=(unsigned long long)low | ((unsigned long long)high)<<32;
+
+	  if(uae_alert<=now) {
+	    while (1) {
+	      if (!handle_hiprec) {
+		/* First time */
+		jiffie_time=now; 
+		jiffie_add=(unsigned long)cpu_khz/HZ*1000;
+		handle_hiprec=1; 
+		margin=(unsigned long)cpu_khz/200; /* 5us */
+	      }
+	      nextev=uae_nextevent;
+	      if (nextev<=now+margin) {
+		uae_trigger();
+	      }
+	      else 
+		break; /* Get out of loop */
+	    }
+	  }
+	  if (!handle_hiprec || jiffie_time<=now+margin*32) {
+	    do_jiffie=1;
+	    jiffie_time+=jiffie_add;
+	  }
+	  if (nextev<=jiffie_time+(jiffie_add>>1)) { 
+	    target=nextev;
+	  }
+	  else {
+	    target=jiffie_time;
+	  }
+	  if (target<now) { /* Uh-oh! */
+	    target=now;
+	  }
+	  last_target=target;
+	  /* Talk about lousy precision! FIXME */
+	  newlatch=(unsigned long)(target-now)*16/(125*cpu_khz/(CLOCK_TICK_RATE/128));
+	  if (newlatch<3) /* This is probably pushing it. We might lose
+			     some interrupts, but then, who cares? */
+	    newlatch=3;
+#if 1	  
+	  if (reset_always ||
+	      ((newlatch<current_latch-5 || newlatch>current_latch+5) &&
+	       handle_hiprec)) {
+	    /* It's different enough for us to actually change the value */
+	    spin_lock(&i8259A_lock);
+	    outb_p(0x34,0x43);		/* binary, mode 2, LSB/MSB, ch 0 */
+	    outb_p(newlatch & 0xff , 0x40);	/* LSB */
+	    outb(newlatch >> 8 , 0x40);	/* MSB */
+	    spin_unlock(&i8259A_lock);
+	    current_latch=newlatch;
+	  }
+
+	  if (!do_jiffie)
+	    return 1;
+#endif
+	}
+	return 0;
+}
+	
+void schedule_hiprec(void)
+{
+  do_hiprec_timer(1);
+}
+
 /*
  * timer_interrupt() needs to keep up the real-time clock,
  * as well as call the "do_timer()" routine every clocktick
@@ -412,7 +500,11 @@ static inline void do_timer_interrupt(in
 	/* Clear the interrupt */
 	co_cpu_write(CO_CPU_STAT,co_cpu_read(CO_CPU_STAT) & ~CO_STAT_TIMEINTR);
 #endif
+	if (do_hiprec_timer(0))
+	  return;
+
 	do_timer(regs);
+	maybe_show_logo();
 /*
  * In the SMP case we use the local APIC timer interrupt to do the
  * profiling, except when we simulate SMP mode on a uniprocessor
@@ -458,7 +550,6 @@ static inline void do_timer_interrupt(in
 #endif
 }
 
-static int use_tsc;
 
 /*
  * This is the same as the above, except we _also_ save the current
@@ -501,6 +592,7 @@ static void timer_interrupt(int irq, voi
 
 		count = inb_p(0x40);    /* read the latched count */
 		count |= inb(0x40) << 8;
+		
 		spin_unlock(&i8253_lock);
 
 		count = ((LATCH-1) - count) * TICK_SIZE;
Only in new_kernel_src/arch/i386/lib: .depend
Only in new_kernel_src/arch/i386/mm: .depend
diff -urp linux/arch/i386/mm/fault.c new_kernel_src/arch/i386/mm/fault.c
--- linux/arch/i386/mm/fault.c	2002-02-25 19:37:53.000000000 +0000
+++ new_kernel_src/arch/i386/mm/fault.c	2002-02-08 09:17:38.000000000 +0000
@@ -134,6 +134,9 @@ void do_BUG(const char *file, int line)
 asmlinkage void do_invalid_op(struct pt_regs *, unsigned long);
 extern unsigned long idt;
 
+int uae_handle_fault(struct pt_regs *regs, unsigned long error_code,
+		     unsigned long addr);
+
 /*
  * This routine handles page faults.  It determines the address,
  * and the problem, and then passes it off to one of the appropriate
@@ -164,6 +167,9 @@ asmlinkage void do_page_fault(struct pt_
 
 	tsk = current;
 
+	if (uae_handle_fault(regs,error_code,address))
+	    return;
+
 	/*
 	 * We fault-in kernel-space virtual memory on-demand. The
 	 * 'reference' page table is init_mm.pgd.
diff -urp linux/arch/i386/mm/init.c new_kernel_src/arch/i386/mm/init.c
--- linux/arch/i386/mm/init.c	2009-06-10 21:00:34.000000000 +0100
+++ new_kernel_src/arch/i386/mm/init.c	2002-03-25 03:10:31.000000000 +0000
@@ -36,8 +36,9 @@
 #include <asm/fixmap.h>
 #include <asm/e820.h>
 #include <asm/apic.h>
+#include <linux/uae.h>
 #include <asm/tlb.h>
-
+  
 mmu_gather_t mmu_gathers[NR_CPUS];
 unsigned long highstart_pfn, highend_pfn;
 static unsigned long totalram_pages;
@@ -573,6 +574,14 @@ void free_initmem(void)
 #ifdef CONFIG_BLK_DEV_INITRD
 void free_initrd_mem(unsigned long start, unsigned long end)
 {
+  /* Instead of giving this back to the OS, let's hand it to UAE instead */
+  while (start&0xfff)
+    start++;
+  while (end&0xfff)
+    end--;
+  add_uae_block((start-PAGE_OFFSET)/4096,(end-PAGE_OFFSET)/4096-1);
+  return;
+
 	if (start < end)
 		printk ("Freeing initrd memory: %ldk freed\n", (end - start) >> 10);
 	for (; start < end; start += PAGE_SIZE) {
Only in new_kernel_src: cb
Only in new_kernel_src: ci
diff -urp linux/drivers/char/Config.in new_kernel_src/drivers/char/Config.in
--- linux/drivers/char/Config.in	2009-06-10 21:00:35.000000000 +0100
+++ new_kernel_src/drivers/char/Config.in	2002-03-25 03:10:32.000000000 +0000
@@ -223,6 +223,7 @@ fi
 if [ "$CONFIG_OBSOLETE" = "y" -a "$CONFIG_ALPHA_BOOK1" = "y" ]; then
    bool 'Tadpole ANA H8 Support'  CONFIG_H8
 fi
+bool 'Magic Keyboard Support' CONFIG_MKBD
 
 tristate 'Double Talk PC internal speech card support' CONFIG_DTLK
 tristate 'Siemens R3964 line discipline' CONFIG_R3964
diff -urp linux/drivers/char/Makefile new_kernel_src/drivers/char/Makefile
--- linux/drivers/char/Makefile	2009-06-10 21:00:35.000000000 +0100
+++ new_kernel_src/drivers/char/Makefile	2002-03-25 03:14:02.000000000 +0000
@@ -23,7 +23,8 @@ obj-y	 += mem.o tty_io.o n_tty.o tty_ioc
 
 export-objs     :=	busmouse.o console.o keyboard.o sysrq.o \
 			misc.o pty.o random.o selection.o serial.o \
-			sonypi.o tty_io.o tty_ioctl.o generic_serial.o \
+			tty_io.o magic_kbd.o pc_keyb.o irq.o \
+			sonypi.o tty_ioctl.o generic_serial.o \
 			au1000_gpio.o
 
 mod-subdirs	:=	joystick ftape drm drm-4.0 pcmcia
@@ -132,6 +133,7 @@ ifeq ($(CONFIG_QTRONIX_KEYBOARD),y)
   KEYMAP   = qtronixmap.o
 endif
 
+
 ifeq ($(CONFIG_DUMMY_KEYB),y)
   KEYBD = dummy_keyb.o
 endif
@@ -204,6 +206,8 @@ obj-$(CONFIG_ADBMOUSE) += adbmouse.o
 obj-$(CONFIG_PC110_PAD) += pc110pad.o
 obj-$(CONFIG_RTC) += rtc.o
 obj-$(CONFIG_EFI_RTC) += efirtc.o
+obj-$(CONFIG_MKBD) += magic_kbd.o
+obj-y += irq.o
 ifeq ($(CONFIG_PPC),)
   obj-$(CONFIG_NVRAM) += nvram.o
 endif
Only in new_kernel_src/drivers/char: amithlon_pci.h
Only in new_kernel_src/drivers/char: irq.c
Only in new_kernel_src/drivers/char: irq.h
diff -urp linux/drivers/char/keyboard.c new_kernel_src/drivers/char/keyboard.c
--- linux/drivers/char/keyboard.c	2009-06-10 21:00:35.000000000 +0100
+++ new_kernel_src/drivers/char/keyboard.c	2002-03-25 03:10:32.000000000 +0000
@@ -949,8 +949,12 @@ int __init kbd_init(void)
 
 	ttytab = console_driver.table;
 
-	kbd_init_hw();
-
+	/* Note: We want the kernel to leave the hardware alone, but still
+	   do all the other keyboard related stuff --- so that it can do
+	   the magic_keyboard receiving. */
+#if 0
+	 kbd_init_hw();  /* Woah! UAE will handle the hardware! */
+#endif
 	tasklet_enable(&keyboard_tasklet);
 	tasklet_schedule(&keyboard_tasklet);
 	
Only in new_kernel_src/drivers/char: magic_kbd.c
diff -urp linux/drivers/char/mem.c new_kernel_src/drivers/char/mem.c
--- linux/drivers/char/mem.c	2009-06-10 21:00:35.000000000 +0100
+++ new_kernel_src/drivers/char/mem.c	2002-03-25 03:10:32.000000000 +0000
@@ -661,6 +661,7 @@ int __init chr_dev_init(void)
 	mda_console_init();
 #endif
 	tty_init();
+	irq_init();
 #ifdef CONFIG_M68K_PRINTER
 	lp_m68k_init();
 #endif
diff -urp linux/drivers/char/misc.c new_kernel_src/drivers/char/misc.c
--- linux/drivers/char/misc.c	2009-06-10 21:00:35.000000000 +0100
+++ new_kernel_src/drivers/char/misc.c	2002-03-25 03:10:32.000000000 +0000
@@ -70,6 +70,7 @@ extern int psaux_init(void);
 extern void gfx_register(void);
 #endif
 extern void streamable_init(void);
+extern int mkbd_init(void);
 extern int rtc_DP8570A_init(void);
 extern int rtc_MK48T08_init(void);
 extern int ds1286_init(void);
@@ -260,6 +261,9 @@ int __init misc_init(void)
 #ifdef CONFIG_BVME6000
 	rtc_DP8570A_init();
 #endif
+#ifdef CONFIG_MKBD
+	mkbd_init();
+#endif
 #ifdef CONFIG_SGI_DS1286
 	ds1286_init();
 #endif
diff -urp linux/drivers/char/pc_keyb.c new_kernel_src/drivers/char/pc_keyb.c
--- linux/drivers/char/pc_keyb.c	2009-06-10 21:00:35.000000000 +0100
+++ new_kernel_src/drivers/char/pc_keyb.c	2002-03-25 03:10:32.000000000 +0000
@@ -41,6 +41,7 @@
 #include <asm/uaccess.h>
 #include <asm/irq.h>
 #include <asm/system.h>
+#include <linux/module.h>
 
 #include <asm/io.h>
 
@@ -48,6 +49,9 @@
 
 #include <linux/pc_keyb.h>
 
+void (*scancode_handler)(unsigned char, int some_bool)=NULL;
+EXPORT_SYMBOL(scancode_handler);
+
 /* Simple translation table for the SysRq keys */
 
 #ifdef CONFIG_MAGIC_SYSRQ
@@ -490,7 +494,6 @@ static unsigned char handle_kbd_event(vo
 		unsigned char scancode;
 
 		scancode = kbd_read_input();
-
 		/* Error bytes must be ignored to make the 
 		   Synaptics touchpads compaq use work */
 #if 1
@@ -500,8 +503,12 @@ static unsigned char handle_kbd_event(vo
 		{
 			if (status & KBD_STAT_MOUSE_OBF)
 				handle_mouse_event(scancode);
-			else
-				handle_keyboard_event(scancode);
+			else {
+			  if (scancode_handler)
+			    scancode_handler(scancode, !(scancode & 0x80));
+			  else
+			    handle_scancode(scancode, !(scancode & 0x80));
+			}
 		}
 
 		status = kbd_read_status();
@@ -895,6 +902,7 @@ static char * __init initialize_kbd(void
 
 void __init pckbd_init_hw(void)
 {
+        scancode_handler=handle_scancode;
 	kbd_request_region();
 
 	/* Flush any pending input. */
diff -urp linux/drivers/mtd/Config.in new_kernel_src/drivers/mtd/Config.in
--- linux/drivers/mtd/Config.in	2001-10-11 17:14:32.000000000 +0100
+++ new_kernel_src/drivers/mtd/Config.in	2002-02-08 08:24:04.000000000 +0000
@@ -23,7 +23,7 @@ comment 'User Modules And Translation La
    dep_tristate '  Caching block device access to MTD devices' CONFIG_MTD_BLOCK $CONFIG_MTD
    if [ "$CONFIG_MTD_BLOCK" = "n" -o "$CONFIG_MTD_BLOCK" = "m" ]; then
    	dep_tristate '  Readonly block device access to MTD devices' CONFIG_MTD_BLOCK_RO $CONFIG_MTD
-   fi
+
    dep_tristate '  FTL (Flash Translation Layer) support' CONFIG_FTL $CONFIG_MTD
    dep_tristate '  NFTL (NAND Flash Translation Layer) support' CONFIG_NFTL $CONFIG_MTD
    if [ "$CONFIG_NFTL" = "y" -o "$CONFIG_NFTL" = "m" ]; then
Only in new_kernel_src/drivers/mtd: mtduae.c
diff -urp linux/drivers/net/8139too.c new_kernel_src/drivers/net/8139too.c
--- linux/drivers/net/8139too.c	2009-06-10 21:00:35.000000000 +0100
+++ new_kernel_src/drivers/net/8139too.c	2002-03-25 07:22:31.000000000 +0000
@@ -1581,9 +1581,7 @@ static int rtl8139_thread (void *data)
 		if (tp->time_to_die)
 			break;
 
-		rtnl_lock ();
 		rtl8139_thread_iter (dev, tp, tp->mmio_addr);
-		rtnl_unlock ();
 	}
 
 	complete_and_exit (&tp->thr_exited, 0);
diff -urp linux/drivers/net/natsemi.c new_kernel_src/drivers/net/natsemi.c
--- linux/drivers/net/natsemi.c	2009-06-10 21:00:36.000000000 +0100
+++ new_kernel_src/drivers/net/natsemi.c	2002-03-25 07:22:06.000000000 +0000
@@ -2443,7 +2443,6 @@ static int natsemi_suspend (struct pci_d
 	struct netdev_private *np = dev->priv;
 	long ioaddr = dev->base_addr;
 
-	rtnl_lock();
 	if (netif_running (dev)) {
 		del_timer_sync(&np->timer);
 
@@ -2480,7 +2479,6 @@ static int natsemi_suspend (struct pci_d
 	} else {
 		netif_device_detach(dev);
 	}
-	rtnl_unlock();
 	return 0;
 }
 
@@ -2490,7 +2488,6 @@ static int natsemi_resume (struct pci_de
 	struct net_device *dev = pci_get_drvdata (pdev);
 	struct netdev_private *np = dev->priv;
 
-	rtnl_lock();
 	if (netif_device_present(dev))
 		goto out;
 	if (netif_running(dev)) {
@@ -2509,7 +2506,6 @@ static int natsemi_resume (struct pci_de
 		netif_device_attach(dev);
 	}
 out:
-	rtnl_unlock();
 	return 0;
 }
 
diff -urp linux/drivers/net/setup.c new_kernel_src/drivers/net/setup.c
--- linux/drivers/net/setup.c	2001-07-04 22:41:33.000000000 +0100
+++ new_kernel_src/drivers/net/setup.c	2001-07-22 19:35:02.000000000 +0100
@@ -8,6 +8,7 @@
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/netlink.h>
+#include <net/slhc.h>
 
 extern int slip_init_ctrl_dev(void);
 extern int x25_asy_init_ctrl_dev(void);
diff -urp linux/drivers/net/winbond-840.c new_kernel_src/drivers/net/winbond-840.c
--- linux/drivers/net/winbond-840.c	2009-06-10 21:00:36.000000000 +0100
+++ new_kernel_src/drivers/net/winbond-840.c	2002-03-25 07:22:31.000000000 +0000
@@ -1665,7 +1665,6 @@ static int w840_suspend (struct pci_dev 
 	struct netdev_private *np = dev->priv;
 	long ioaddr = dev->base_addr;
 
-	rtnl_lock();
 	if (netif_running (dev)) {
 		del_timer_sync(&np->timer);
 
@@ -1692,7 +1691,6 @@ static int w840_suspend (struct pci_dev 
 	} else {
 		netif_device_detach(dev);
 	}
-	rtnl_unlock();
 	return 0;
 }
 
@@ -1702,7 +1700,6 @@ static int w840_resume (struct pci_dev *
 	struct net_device *dev = pci_get_drvdata (pdev);
 	struct netdev_private *np = dev->priv;
 
-	rtnl_lock();
 	if (netif_device_present(dev))
 		goto out; /* device not suspended */
 	if (netif_running(dev)) {
@@ -1726,7 +1723,6 @@ static int w840_resume (struct pci_dev *
 		netif_device_attach(dev);
 	}
 out:
-	rtnl_unlock();
 	return 0;
 }
 #endif
diff -urp linux/drivers/pci/pci.c new_kernel_src/drivers/pci/pci.c
--- linux/drivers/pci/pci.c	2009-06-10 21:00:36.000000000 +0100
+++ new_kernel_src/drivers/pci/pci.c	2002-03-25 03:14:48.000000000 +0000
@@ -9,6 +9,17 @@
  *	Copyright 1997 -- 2000 Martin Mares <mj@ucw.cz>
  */
 
+#define UAE_PCI_START 0x50000000
+#define UAE_PCI_END   0xb0000000
+
+#if 1
+#define PCI_OFFSET pci_offset
+#define PCI_OFFSET_BRIDGE ((PCI_OFFSET)>>16) 
+#else
+#define PCI_OFFSET 0
+#define PCI_OFFSET_BRIDGE ((PCI_OFFSET)>>16) 
+#endif
+
 #include <linux/config.h>
 #include <linux/module.h>
 #include <linux/types.h>
@@ -24,6 +35,7 @@
 #include <linux/bitops.h>
 #include <linux/delay.h>
 #include <linux/cache.h>
+#include <linux/tty.h>
 
 #include <asm/page.h>
 #include <asm/dma.h>	/* isa_dma_bridge_buggy */
@@ -83,7 +95,9 @@ pci_find_subsys(unsigned int vendor, uns
 		const struct pci_dev *from)
 {
 	struct list_head *n = from ? from->global_list.next : pci_devices.next;
-
+	
+	printk("UAE: pci_find_subsys %04x %04x %04x %04x\n",
+	       vendor,device,ss_vendor,ss_device);
 	while (n != &pci_devices) {
 		struct pci_dev *dev = pci_dev_g(n);
 		if ((vendor == PCI_ANY_ID || dev->vendor == vendor) &&
@@ -605,6 +619,19 @@ pci_register_driver(struct pci_driver *d
 	struct pci_dev *dev;
 	int count = 0;
 
+	printk("OOO: Registering module %s\n",drv->name);
+	if (drv->id_table) {
+	  while (drv->id_table[count].vendor) {
+	    printk("OOO: %04x %04x  %04x %04x\n",
+		   drv->id_table[count].vendor,
+		   drv->id_table[count].device,
+		   drv->id_table[count].subvendor,
+		   drv->id_table[count].subdevice);
+	    count++;
+	  }
+	}
+
+	count=0;
 	list_add_tail(&drv->node, &pci_drivers);
 	pci_for_each_dev(dev) {
 		if (!pci_dev_driver(dev))
@@ -1073,6 +1100,7 @@ void __devinit pci_read_bridge_bases(str
 	if (!dev)		/* It's a host bus, nothing to read */
 		return;
 
+	dev->bridge_valid_bases=0;
 	for(i=0; i<3; i++)
 		child->resource[i] = &dev->resource[PCI_BRIDGE_RESOURCES+i];
 
@@ -1095,6 +1123,7 @@ void __devinit pci_read_bridge_bases(str
 		res->start = base;
 		res->end = limit + 0xfff;
 		res->name = child->name;
+		dev->bridge_valid_bases|=1;
 	} else {
 		/*
 		 * Ugh. We don't know enough about this bridge. Just assume
@@ -1114,6 +1143,7 @@ void __devinit pci_read_bridge_bases(str
 		res->start = base;
 		res->end = limit + 0xfffff;
 		res->name = child->name;
+		dev->bridge_valid_bases|=2;
 	} else {
 		/* See comment above. Same thing */
 		printk(KERN_ERR "Unknown bridge resource %d: assuming transparent\n", 1);
@@ -1145,6 +1175,7 @@ void __devinit pci_read_bridge_bases(str
 		res->start = base;
 		res->end = limit + 0xfffff;
 		res->name = child->name;
+		dev->bridge_valid_bases|=4;
 	} else {
 		/* See comments above */
 		printk(KERN_ERR "Unknown bridge resource %d: assuming transparent\n", 2);
@@ -2025,6 +2056,189 @@ pci_pool_free (struct pci_pool *pool, vo
 	spin_unlock_irqrestore (&pool->lock, flags);
 }
 
+void __init pci_fixup_uae(void)
+{
+	struct pci_dev *dev;
+	u32 maxsize;
+	u32 pci_offset;
+	u32 ok;
+	int rescount=7;
+
+	maxsize=1024*1024;
+
+	pci_for_each_dev(dev) {
+	  int i;
+	  
+	  printk(KERN_ERR "%04x %04x   hdrtype %d\n",dev->vendor,dev->device,
+		 dev->hdr_type);
+	  if (dev->hdr_type==1) {
+	    u16 tmp;
+
+	    printk(KERN_ERR "  subordinate bus: %p, valid_bases=%02x\n",dev->subordinate,dev->bridge_valid_bases);
+	    pci_read_config_word(dev, PCI_MEMORY_BASE, &tmp);
+	    printk(KERN_ERR "  mem_base=%04x\n",tmp);
+	    pci_read_config_word(dev, PCI_MEMORY_LIMIT, &tmp);
+	    printk(KERN_ERR "  mem_limit=%04x\n",tmp);
+	    pci_read_config_word(dev, PCI_PREF_MEMORY_BASE, &tmp);
+	    printk(KERN_ERR "  pref_base=%04x\n",tmp);
+	    pci_read_config_word(dev, PCI_PREF_MEMORY_LIMIT, &tmp);
+	    printk(KERN_ERR "  pref_limit=%04x\n",tmp);
+	  }
+	  for (i=0;i<rescount;i++) {
+	    if (dev->resource[i].start) {
+	      printk(KERN_ERR "resource %d: Start %08lx, end %08lx, flags %08x\n",
+		     i,dev->resource[i].start,
+		     dev->resource[i].end,
+		     dev->resource[i].flags);
+	      if (dev->resource[i].flags & IORESOURCE_MEM) {
+		if (dev->resource[i].end-dev->resource[i].start+1 > maxsize) 
+		  maxsize=dev->resource[i].end-dev->resource[i].start+1;
+	      }
+	    }
+	  }
+	}
+	printk(KERN_ERR "maxsize=%08x\n",
+	       maxsize);
+	pci_offset=0;
+	do {
+	  ok=1;
+	  pci_for_each_dev(dev) {
+	    int i;
+	    
+	    for (i=0;i<rescount;i++) {
+	      if (dev->resource[i].start) {
+		if (dev->resource[i].flags & IORESOURCE_MEM) {
+		  if (dev->resource[i].start+pci_offset<UAE_PCI_START ||
+		      dev->resource[i].start+pci_offset>=UAE_PCI_END)
+		    ok=0;
+		  if (dev->resource[i].end+pci_offset<UAE_PCI_START ||
+		      dev->resource[i].end+pci_offset>=UAE_PCI_END)
+		    ok=0;
+		  if (((u32)(dev->resource[i].start+pci_offset))>
+		      ((u32)(dev->resource[i].end+pci_offset)))
+		    ok=0;
+		}
+	      }
+	    }
+	  }
+	  if (!ok) {
+	    pci_offset+=maxsize;
+	    if (!pci_offset) {
+	      printk(KERN_ERR "ARGH! Could not find proper pci_offset\n");
+	      if (rescount==7) {
+		printk(KERN_ERR "Trying to fudge by ignoring ROMs!\n");
+		rescount=6;
+	      }
+	      else {
+		panic("Can't find PCI offset even when ignoring ROMs!\n");
+	      }
+	    }
+	  }
+	} while (!ok);
+
+	printk(KERN_ERR "pci_offset %08x\n",
+	       pci_offset);
+	
+	printk(KERN_ERR "==================== Moving PCI NOW! =============\n");
+	pci_for_each_dev(dev) {
+	  int i;
+	  
+	  if (dev->hdr_type==0) {
+	    for (i=0;i<6;i++) {
+	      if (dev->resource[i].start &&
+		  !(dev->resource[i].flags&PCI_BASE_ADDRESS_SPACE_IO)) {
+		u32 old,base;
+		dev->resource[i].start+=PCI_OFFSET;
+		dev->resource[i].end+=PCI_OFFSET;
+		pci_read_config_dword(dev,0x10+4*i,&old);
+		old&=~PCI_BASE_ADDRESS_MEM_MASK;
+		base=dev->resource[i].start&PCI_BASE_ADDRESS_MEM_MASK;
+		pci_write_config_dword(dev, 0x10+4*i, old|base);
+	      }
+	    }
+	    if (dev->resource[PCI_ROM_RESOURCE].start) {
+	      u32 old,base;
+	      if (rescount==7) {
+		dev->resource[PCI_ROM_RESOURCE].start+=PCI_OFFSET;
+		dev->resource[PCI_ROM_RESOURCE].end+=PCI_OFFSET;
+		pci_read_config_dword(dev,PCI_ROM_ADDRESS,&old);
+		old&=~PCI_ROM_ADDRESS_MASK;
+		base=dev->resource[PCI_ROM_RESOURCE].start&PCI_ROM_ADDRESS_MASK;
+		pci_write_config_dword(dev, PCI_ROM_ADDRESS, old|base);
+	      }
+	      else {
+		/* We can't shift the ROMs, so we disable them.
+		   Most of the time, we don't need them, anyway.... */
+		dev->resource[PCI_ROM_RESOURCE].start=0;
+		dev->resource[PCI_ROM_RESOURCE].end=0;
+		pci_write_config_dword(dev, PCI_ROM_ADDRESS,0);
+	      }
+	    }
+	  }
+	  else if (dev->hdr_type==1) {
+	    struct pci_bus* bus=dev->subordinate;
+
+	    for (i=0;i<2;i++) {
+	      if (dev->resource[i].start &&
+		  !(dev->resource[i].flags&PCI_BASE_ADDRESS_SPACE_IO)) {
+		u32 old,base;
+		dev->resource[i].start+=PCI_OFFSET;
+		dev->resource[i].end+=PCI_OFFSET;
+		pci_read_config_dword(dev,0x10+4*i,&old);
+		old&=~PCI_BASE_ADDRESS_MEM_MASK;
+		base=dev->resource[i].start&PCI_BASE_ADDRESS_MEM_MASK;
+		pci_write_config_dword(dev, 0x10+4*i, old|base);
+	      }
+	    }
+	    if (dev->resource[PCI_ROM_RESOURCE].start) {
+	      u32 old,base;
+	      dev->resource[PCI_ROM_RESOURCE].start+=PCI_OFFSET;
+	      dev->resource[PCI_ROM_RESOURCE].end+=PCI_OFFSET;
+	      pci_read_config_dword(dev,PCI_ROM_ADDRESS1,&old);
+	      old&=~PCI_ROM_ADDRESS_MASK;
+	      base=dev->resource[PCI_ROM_RESOURCE].start&PCI_ROM_ADDRESS_MASK;
+	      pci_write_config_dword(dev, PCI_ROM_ADDRESS1, old|base);
+	    }
+	    
+	    if (bus) {
+	      if (bus->resource[1] && (dev->bridge_valid_bases&2)) {
+		u16 mem_base_lo, mem_limit_lo;
+		printk(KERN_ERR " bus resource 1: Start/end %08x/%08x\n",
+		       bus->resource[1]->start,
+		       bus->resource[1]->end);
+		pci_read_config_word(dev, PCI_MEMORY_BASE, &mem_base_lo);
+		pci_read_config_word(dev, PCI_MEMORY_LIMIT, &mem_limit_lo);
+		bus->resource[1]->start+=PCI_OFFSET;
+		bus->resource[1]->end+=PCI_OFFSET;
+		pci_write_config_word(dev,PCI_MEMORY_LIMIT,
+				      mem_limit_lo+PCI_OFFSET_BRIDGE);
+		pci_write_config_word(dev,PCI_MEMORY_BASE,
+				      mem_base_lo+PCI_OFFSET_BRIDGE);
+	      }
+	      if (bus->resource[2] && (dev->bridge_valid_bases&4)) {
+		u16 mem_base_lo, mem_limit_lo;
+		printk(KERN_ERR " bus resource 2: Start/end %08x/%08x\n",
+		       bus->resource[2]->start,
+		       bus->resource[2]->end);
+		pci_read_config_word(dev, PCI_PREF_MEMORY_BASE, &mem_base_lo);
+		pci_read_config_word(dev, PCI_PREF_MEMORY_LIMIT, &mem_limit_lo);
+		bus->resource[2]->start+=PCI_OFFSET;
+		bus->resource[2]->end+=PCI_OFFSET;
+		pci_write_config_word(dev,PCI_PREF_MEMORY_LIMIT,
+				      mem_limit_lo+PCI_OFFSET_BRIDGE);
+		pci_write_config_word(dev,PCI_PREF_MEMORY_BASE,
+				      mem_base_lo+PCI_OFFSET_BRIDGE);
+	      }
+	    }
+	  }
+	}
+	screen_info.lfb_base=
+	  (u32)(screen_info.lfb_base+PCI_OFFSET);  /* For the vesa framebuffer.
+						      It's the one thing that
+						      already has cached a PCI
+						      address */
+}
+
 
 void __devinit  pci_init(void)
 {
@@ -2035,6 +2249,8 @@ void __devinit  pci_init(void)
 	pci_for_each_dev(dev) {
 		pci_fixup_device(PCI_FIXUP_FINAL, dev);
 	}
+	
+	pci_fixup_uae();
 
 #ifdef CONFIG_PM
 	pm_register(PM_PCI_DEV, 0, pci_pm_callback);
Only in new_kernel_src/drivers/scsi/aic7xxx/aicasm: aicdb.h
diff -urp linux/drivers/scsi/ide-scsi.c new_kernel_src/drivers/scsi/ide-scsi.c
--- linux/drivers/scsi/ide-scsi.c	2009-06-10 21:00:36.000000000 +0100
+++ new_kernel_src/drivers/scsi/ide-scsi.c	2002-03-25 03:10:32.000000000 +0000
@@ -31,6 +31,8 @@
 
 #define IDESCSI_VERSION "0.9"
 
+#define UAE_GET_IDENT 0x54785683
+
 #include <linux/module.h>
 #include <linux/types.h>
 #include <linux/string.h>
@@ -692,8 +694,14 @@ int idescsi_ioctl (Scsi_Device *dev, int
 		else
 			clear_bit(IDESCSI_SG_TRANSFORM, &scsi->transform);
 		return 0;
-	} else if (cmd == SG_GET_TRANSFORM)
+	} else if (cmd == SG_GET_TRANSFORM) {
 		return put_user(test_bit(IDESCSI_SG_TRANSFORM, &scsi->transform), (int *) arg);
+	} else if (cmd == UAE_GET_IDENT) {
+	  if (copy_to_user(arg,drive->name,4))
+	    return -EFAULT;
+	  return 0;
+	}
+	  
 	return -EINVAL;
 }
 
diff -urp linux/drivers/scsi/scsi.c new_kernel_src/drivers/scsi/scsi.c
--- linux/drivers/scsi/scsi.c	2009-06-10 21:00:36.000000000 +0100
+++ new_kernel_src/drivers/scsi/scsi.c	2002-03-30 14:04:29.000000000 +0000
@@ -2274,7 +2274,10 @@ static int scsi_register_device_module(s
 	 * If any of the devices would match this driver, then perform the
 	 * init function.
 	 */
-	if (tpnt->init && tpnt->dev_noticed) {
+
+        /* We need to create the sg files no matter whether we actually
+           found any SCSI devices */
+	if (tpnt->init /* && tpnt->dev_noticed */) {
 		if ((*tpnt->init) ()) {
 			for (shpnt = scsi_hostlist; shpnt;
 			     shpnt = shpnt->next) {
diff -urp linux/drivers/scsi/sg.c new_kernel_src/drivers/scsi/sg.c
--- linux/drivers/scsi/sg.c	2002-02-25 19:38:04.000000000 +0000
+++ new_kernel_src/drivers/scsi/sg.c	2002-03-30 14:04:28.000000000 +0000
@@ -835,7 +835,7 @@ static int sg_ioctl(struct inode * inode
                        &sg_idp->h_cmd_per_lun);
 	    __put_user((short)sdp->device->queue_depth,
                        &sg_idp->d_queue_depth);
-	    __put_user(0, &sg_idp->unused[0]);
+	    __put_user(sdp->device->removable?1:0, &sg_idp->unused[0]);
 	    __put_user(0, &sg_idp->unused[1]);
             return 0;
         }
@@ -1334,7 +1334,10 @@ static int sg_init()
     static int sg_registered = 0;
     unsigned long iflags;
 
-    if ((sg_template.dev_noticed == 0) || sg_dev_arr)
+    /* Make sure we get a /proc/scsi/sg/hosts_strs entry even if 
+       there are no scsi devices! Amithlon 1.0.1 will crash otherwise.
+       Thou shalt check thy return code of fopen! */
+    if (/* (sg_template.dev_noticed == 0) || */ sg_dev_arr)
     	return 0;
 
     write_lock_irqsave(&sg_dev_arr_lock, iflags);
Only in new_kernel_src/drivers/video: amithlon.h
diff -urp linux/drivers/video/aty128.h new_kernel_src/drivers/video/aty128.h
--- linux/drivers/video/aty128.h	2002-02-25 19:38:07.000000000 +0000
+++ new_kernel_src/drivers/video/aty128.h	2001-10-13 22:21:21.000000000 +0100
@@ -390,7 +390,6 @@
 #define LVDS_FRAME_MOD_NO			0x00000000
 #define LVDS_FRAME_MOD_2_LEVELS			0x00000010
 #define LVDS_FRAME_MOD_4_LEVELS			0x00000020
-#define LVDS_RST_FM				0x00000040
 #define LVDS_EN					0x00000080
 
 /* CRTC2_GEN_CNTL constants */
diff -urp linux/drivers/video/aty128fb.c new_kernel_src/drivers/video/aty128fb.c
--- linux/drivers/video/aty128fb.c	2009-06-10 21:00:37.000000000 +0100
+++ new_kernel_src/drivers/video/aty128fb.c	2002-03-25 03:10:33.000000000 +0000
@@ -7,6 +7,9 @@
  *                Ani Joshi / Jeff Garzik
  *                      - Code cleanup
  *
+ *                Andreas Hundt <andi@convergence.de>
+ *                      - FB_ACTIVATE fixes
+ *
  *                Michel Dänzer <michdaen@iiic.ethz.ch>
  *                      - 15/16 bit cleanup
  *                      - fix panning
@@ -77,7 +80,7 @@
 #include <asm/vc_ioctl.h>
 #endif
 #ifdef CONFIG_BOOTX_TEXT
-#include <asm/btext.h>
+#include <asm/bootx.h>
 #endif /* CONFIG_BOOTX_TEXT */
 
 #include <video/fbcon.h>
@@ -528,7 +531,7 @@ static u32
 _aty_ld_pll(unsigned int pll_index,
 			const struct fb_info_aty128 *info)
 {       
-    aty_st_8(CLOCK_CNTL_INDEX, pll_index & 0x3F);
+    aty_st_8(CLOCK_CNTL_INDEX, pll_index & 0x2F);
     return aty_ld_le32(CLOCK_CNTL_DATA);
 }
 
@@ -537,7 +540,7 @@ static void
 _aty_st_pll(unsigned int pll_index, u32 val,
 			const struct fb_info_aty128 *info)
 {
-    aty_st_8(CLOCK_CNTL_INDEX, (pll_index & 0x3F) | PLL_WR_EN);
+    aty_st_8(CLOCK_CNTL_INDEX, (pll_index & 0x2F) | PLL_WR_EN);
     aty_st_le32(CLOCK_CNTL_DATA, val);
 }
 
@@ -799,8 +802,13 @@ aty128_set_crtc(const struct aty128_crtc
     aty_st_le32(CRTC_PITCH, crtc->pitch);
     aty_st_le32(CRTC_OFFSET, crtc->offset);
     aty_st_le32(CRTC_OFFSET_CNTL, crtc->offset_cntl);
-    /* Disable ATOMIC updating.  Is this the right place? */
+    /* Disable ATOMIC updating.  Is this the right place?
+     * -- BenH: Breaks on my G4
+     * -- BenH: Normal, it's a pll reg ! and the mask value is false
+     */
+#if 1
     aty_st_pll(PPLL_CNTL, aty_ld_pll(PPLL_CNTL) & ~(0x00030000));
+#endif
 }
 
 
@@ -848,11 +856,13 @@ aty128_var_to_crtc(const struct fb_var_s
     xres = (xres + 7) & ~7;
     xoffset = (xoffset + 7) & ~7;
 
+#if 0
     if (vxres < xres + xoffset)
 	vxres = xres + xoffset;
 
     if (vyres < yres + yoffset)
 	vyres = yres + yoffset;
+#endif
 
     /* convert depth into ATI register depth */
     dst = depth_to_dst(depth);
@@ -1078,7 +1088,7 @@ aty128_set_lcd_enable(struct fb_info_aty
     
     if (on) {
 	reg = aty_ld_le32(LVDS_GEN_CNTL);
-	reg |= LVDS_ON | LVDS_EN | LVDS_BLON | LVDS_DIGION;
+	reg |= LVDS_ON | LVDS_EN;
 	reg &= ~LVDS_DISPLAY_DIS;
 	aty_st_le32(LVDS_GEN_CNTL, reg);
 #ifdef CONFIG_PMAC_BACKLIGHT
@@ -1350,12 +1360,12 @@ aty128_set_par(struct aty128fb_par *par,
 	display_info.disp_reg_address = info->regbase_phys;
     }
 #endif /* CONFIG_FB_COMPAT_XPMAC */
-#if defined(CONFIG_BOOTX_TEXT)
-    btext_update_display(info->frame_buffer_phys,
-		    (((par->crtc.h_total>>16) & 0xff)+1)*8,
-		    ((par->crtc.v_total>>16) & 0x7ff)+1,
-		    par->crtc.bpp,
-		    par->crtc.vxres*par->crtc.bpp/8);
+#ifdef CONFIG_BOOTX_TEXT
+	bootx_update_display(info->frame_buffer_phys,
+			     (((par->crtc.h_total>>16) & 0xff)+1)*8,
+			     ((par->crtc.v_total>>16) & 0x7ff)+1,
+			     par->crtc.bpp,
+			     par->crtc.vxres*par->crtc.bpp/8);
 #endif /* CONFIG_BOOTX_TEXT */
 }
 
@@ -1478,10 +1488,17 @@ aty128fb_set_var(struct fb_var_screeninf
     if ((err = aty128_decode_var(var, &par, info)))
 	return err;
 
-    aty128_encode_var(var, &par, info);
+    {
+      int get_out=0;
+
+      if ((var->activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_TEST)
+	get_out=1;
+      
+      aty128_encode_var(var, &par, info);
 
-    if ((var->activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_TEST)
+      if (get_out)
 	return 0;
+    }
 
     oldxres = display->var.xres;
     oldyres = display->var.yres;
@@ -1637,8 +1654,10 @@ aty128fb_pan_display(struct fb_var_scree
     xoffset = (var->xoffset +7) & ~7;
     yoffset = var->yoffset;
 
+#if 0
     if (xoffset+xres > par->crtc.vxres || yoffset+yres > par->crtc.vyres)
         return -EINVAL;
+#endif
 
     par->crtc.xoffset = xoffset;
     par->crtc.yoffset = yoffset;
@@ -1753,7 +1772,7 @@ aty128fb_setup(char *options)
     if (!options || !*options)
 	return 0;
 
-    while ((this_opt = strsep(&options, ",")) != 0) {
+    while (this_opt = strsep(&options, ",")) {
 	if (!strncmp(this_opt, "font:", 5)) {
 	    char *p;
 	    int i;
@@ -2019,7 +2038,7 @@ aty128_pci_register(struct pci_dev *pdev
 	if ((err = pci_enable_device(pdev))) {
 		printk(KERN_ERR "aty128fb: Cannot enable PCI device: %d\n",
 				err);
-		return -ENODEV;
+		goto err_out;
 	}
 
 	fb_addr = pci_resource_start(pdev, 0);
@@ -2517,8 +2536,7 @@ static int backlight_conv[] = {
  * backlight anyway
  */
 #define BACKLIGHT_LVDS_OFF
-/* That one prevents proper CRT output with LCD off */
-#undef BACKLIGHT_DAC_OFF
+#define BACKLIGHT_DAC_OFF
 
 static int
 aty128_set_backlight_enable(int on, int level, void* data)
@@ -2530,15 +2548,6 @@ aty128_set_backlight_enable(int on, int 
 		on = 0;
 	reg |= LVDS_BL_MOD_EN | LVDS_BLON;
 	if (on && level > BACKLIGHT_OFF) {
-		reg |= LVDS_DIGION;
-		if (!reg & LVDS_ON) {
-			reg &= ~LVDS_BLON;
-			aty_st_le32(LVDS_GEN_CNTL, reg);
-			(void)aty_ld_le32(LVDS_GEN_CNTL);
-			mdelay(10);
-			reg |= LVDS_BLON;
-			aty_st_le32(LVDS_GEN_CNTL, reg);
-		}
 		reg &= ~LVDS_BL_MOD_LEVEL_MASK;
 		reg |= (backlight_conv[level] << LVDS_BL_MOD_LEVEL_SHIFT);
 #ifdef BACKLIGHT_LVDS_OFF
@@ -2553,11 +2562,8 @@ aty128_set_backlight_enable(int on, int 
 		reg &= ~LVDS_BL_MOD_LEVEL_MASK;
 		reg |= (backlight_conv[0] << LVDS_BL_MOD_LEVEL_SHIFT);
 #ifdef BACKLIGHT_LVDS_OFF
+		reg &= ~(LVDS_ON | LVDS_EN);
 		reg |= LVDS_DISPLAY_DIS;
-		aty_st_le32(LVDS_GEN_CNTL, reg);
-		(void)aty_ld_le32(LVDS_GEN_CNTL);
-		udelay(10);
-		reg &= ~(LVDS_ON | LVDS_EN | LVDS_BLON | LVDS_DIGION);
 #endif		
 		aty_st_le32(LVDS_GEN_CNTL, reg);
 #ifdef BACKLIGHT_DAC_OFF
diff -urp linux/drivers/video/clgenfb.c new_kernel_src/drivers/video/clgenfb.c
--- linux/drivers/video/clgenfb.c	2009-06-10 21:00:37.000000000 +0100
+++ new_kernel_src/drivers/video/clgenfb.c	2002-03-25 03:10:33.000000000 +0000
@@ -873,12 +873,14 @@ static int clgen_decode_var (const struc
 	if (_par->var.yoffset < 0)
 		_par->var.yoffset = 0;
 
+#if 0
 	/* truncate xoffset and yoffset to maximum if too high */
 	if (_par->var.xoffset > _par->var.xres_virtual - _par->var.xres)
 		_par->var.xoffset = _par->var.xres_virtual - _par->var.xres - 1;
 
 	if (_par->var.yoffset > _par->var.yres_virtual - _par->var.yres)
 		_par->var.yoffset = _par->var.yres_virtual - _par->var.yres - 1;
+#endif
 
 	switch (_par->var.bits_per_pixel) {
 	case 1:
diff -urp linux/drivers/video/cyber2000fb.c new_kernel_src/drivers/video/cyber2000fb.c
--- linux/drivers/video/cyber2000fb.c	2001-12-21 17:41:55.000000000 +0000
+++ new_kernel_src/drivers/video/cyber2000fb.c	2002-02-08 08:32:14.000000000 +0000
@@ -1013,10 +1013,12 @@ cyber2000fb_pan_display(struct fb_var_sc
 	if (!(var->vmode & FB_VMODE_YWRAP))
 		y_bottom += var->yres;
 
+#if 0
 	if (var->xoffset > (var->xres_virtual - var->xres))
 		return -EINVAL;
 	if (y_bottom > cfb->fb.var.yres_virtual)
 		return -EINVAL;
+#endif
 
 	if (cyber2000fb_update_start(cfb, var))
 		return -EINVAL;
diff -urp linux/drivers/video/fbcon.c new_kernel_src/drivers/video/fbcon.c
--- linux/drivers/video/fbcon.c	2002-02-25 19:38:07.000000000 +0000
+++ new_kernel_src/drivers/video/fbcon.c	2002-02-08 09:17:39.000000000 +0000
@@ -221,7 +221,7 @@ static __inline__ void ypan_down(int uni
 static void fbcon_bmove_rec(struct display *p, int sy, int sx, int dy, int dx,
 			    int height, int width, u_int y_break);
 
-static int fbcon_show_logo(void);
+int fbcon_show_logo(void);
 
 #ifdef CONFIG_MAC
 /*
@@ -2135,7 +2135,81 @@ static inline unsigned safe_shift(unsign
     return n<0 ? d>>-n : d<<n;
 }
 
-static int __init fbcon_show_logo( void )
+static int do_logo=1;
+static int do_timer_logo=0;
+
+void disable_logo(void)
+{
+  do_logo=0;
+}
+
+int fbcon_show_logo_internal(int turn);
+
+void maybe_show_logo(void)
+{
+  if (do_timer_logo && do_logo)
+    fbcon_show_logo_internal(1);
+}
+
+static int offset=0;
+static int dir=1;
+
+#define USE_OUR_LOGO 1
+#define FANCY_BOUNCE 1
+static int calc_logo_pos(struct display* p, int* xp, int* yp, int move)
+{
+  static int xpos=100;
+  static int ypos=0;
+  static int xfrac=0;
+  static int yfrac=0;
+  static int dx=2*65536;
+  static int dy=0;
+  static int tillturn=1;
+
+  int doturn;
+
+  if (move) {
+    xfrac+=dx;
+    yfrac+=dy;
+    xpos+=(xfrac>>16);
+    ypos+=(yfrac>>16);
+    xfrac&=0xffff;
+    yfrac&=0xffff;
+    
+    if (xpos<0) {
+      xpos=-xpos;
+      dx=-dx;
+    }
+    if (xpos>p->var.xres-LOGO_W) {
+      xpos=(p->var.xres-LOGO_W)-(xpos-(p->var.xres-LOGO_W));
+      dx=-dx;
+    }
+    
+    if (ypos>p->var.yres-LOGO_H) {
+      ypos=(p->var.yres-LOGO_H)-(ypos-(p->var.yres-LOGO_H));
+      dy=-dy;
+    }
+    else
+      dy+=3000;
+    dy-=(dy/4000);
+    dx-=(dx/8000);
+  }
+
+  *xp=xpos;
+  *yp=ypos;
+  doturn=!tillturn;
+  if (!tillturn)
+    tillturn=5;
+  else
+    tillturn--;
+  return doturn;
+}
+
+
+#define TURNUP 1
+#define TURNNEED 3
+
+int fbcon_show_logo_internal(int turn)
 {
     struct display *p = &fb_display[fg_console]; /* draw to vt in foreground */
     int depth = p->var.bits_per_pixel;
@@ -2143,21 +2217,33 @@ static int __init fbcon_show_logo( void 
     unsigned char *fb = p->screen_base;
     unsigned char *logo;
     unsigned char *dst, *src;
-    int i, j, n, x1, y1, x;
+    int i, j, n, x1, y1, x,y;
     int logo_depth, done = 0;
+    int offbytes=0;
+    static int turncount=0;
+    static int need_cmap=1;
 
     /* Return if the frame buffer is not mapped */
     if (!fb)
 	return 0;
-	
+    if (!do_logo)
+      return 0;
+
+    do_timer_logo=1;
     /*
      * Set colors if visual is PSEUDOCOLOR and we have enough colors, or for
      * DIRECTCOLOR
      * We don't have to set the colors for the 16-color logo, since that logo
      * uses the standard VGA text console palette
      */
-    if ((p->visual == FB_VISUAL_PSEUDOCOLOR && depth >= 8) ||
-	(p->visual == FB_VISUAL_DIRECTCOLOR && depth >= 24))
+    if (need_cmap) { /* only do this the first time */
+      if ((p->visual == FB_VISUAL_PSEUDOCOLOR && depth >= 8) ||
+	  (p->visual == FB_VISUAL_DIRECTCOLOR && depth >= 24)) {
+	int is_truecolor = (p->visual == FB_VISUAL_DIRECTCOLOR);
+	int use_256 = (!is_truecolor && depth >= 8) ||
+	  (is_truecolor && depth >= 24);
+	
+	offbytes=0;
 	for (i = 0; i < LINUX_LOGO_COLORS; i += n) {
 	    n = LINUX_LOGO_COLORS - i;
 	    if (n > 16)
@@ -2166,17 +2252,20 @@ static int __init fbcon_show_logo( void 
 	    palette_cmap.start = 32 + i;
 	    palette_cmap.len   = n;
 	    for( j = 0; j < n; ++j ) {
-		palette_cmap.red[j]   = (linux_logo_red[i+j] << 8) |
-					linux_logo_red[i+j];
-		palette_cmap.green[j] = (linux_logo_green[i+j] << 8) |
-					linux_logo_green[i+j];
-		palette_cmap.blue[j]  = (linux_logo_blue[i+j] << 8) |
-					linux_logo_blue[i+j];
+		palette_cmap.red[j]   = (linux_logo_red[i+j+offbytes] << 8) |
+					linux_logo_red[i+j+offbytes];
+		palette_cmap.green[j] = (linux_logo_green[i+j+offbytes] << 8) |
+					linux_logo_green[i+j+offbytes];
+		palette_cmap.blue[j]  = (linux_logo_blue[i+j+offbytes] << 8) |
+					linux_logo_blue[i+j+offbytes];
 	    }
 	    p->fb_info->fbops->fb_set_cmap(&palette_cmap, 1, fg_console,
 					   p->fb_info);
 	}
-	
+      }
+    }
+    need_cmap=0;
+
     if (depth >= 8) {
 	logo = linux_logo;
 	logo_depth = 8;
@@ -2193,9 +2282,52 @@ static int __init fbcon_show_logo( void 
     if (p->fb_info->fbops->fb_rasterimg)
     	p->fb_info->fbops->fb_rasterimg(p->fb_info, 1);
 
+#if !USE_OUR_LOGO
+    y=0;
     for (x = 0; x < smp_num_cpus * (LOGO_W + 8) &&
-    	 x < p->var.xres - (LOGO_W + 8); x += (LOGO_W + 8)) {
-    	 
+	   x < p->var.xres - (LOGO_W + 8); x += (LOGO_W + 8)) { 
+#else
+    
+    if (p->var.xres>LOGO_W)
+    { 
+#ifdef LOGO_FRAMES
+      static int lastjiffies;
+      int nowjiffies=jiffies;
+
+      x=0;
+      y=0;
+#if FANCY_BOUNCE
+      if (console_loglevel<1)
+	calc_logo_pos(p,&x,&y,turn);
+#endif
+      offbytes=offset;
+
+      if (turn) {
+	turncount+=TURNUP;
+	if (turncount>=TURNNEED) 
+	  turncount-=TURNNEED;
+	else
+	  turn=0;
+      }
+      
+
+      if (turn) {
+	if (nowjiffies!=lastjiffies) {
+	  offset=(offset+1)%LOGO_FRAMES;
+	  lastjiffies=nowjiffies;
+	}
+      }
+#else
+      offbytes=0;
+      x=offset;
+      y=0;
+      if (offset==p->var.xres-LOGO_W && dir==1)
+	dir=-1;
+      if (offset==0 && dir==-1)
+	dir=1;
+      offset+=dir;
+#endif
+#endif    
 #if defined(CONFIG_FBCON_CFB16) || defined(CONFIG_FBCON_CFB24) || \
     defined(CONFIG_FBCON_CFB32) || defined(CONFIG_FB_SBUS)
         if (p->visual == FB_VISUAL_DIRECTCOLOR) {
@@ -2210,10 +2342,10 @@ static int __init fbcon_show_logo( void 
 
 	    if (depth >= 24 && (depth % 8) == 0) {
 		/* have at least 8 bits per color */
-		src = logo;
+		src = logo+offbytes*LOGO_W*LOGO_H;
 		bdepth = depth/8;
 		for( y1 = 0; y1 < LOGO_H; y1++ ) {
-		    dst = fb + y1*line + x*bdepth;
+		    dst = fb + (y1+y)*line + x*bdepth;
 		    for( x1 = 0; x1 < LOGO_W; x1++, src++ ) {
 			val = (*src << redshift) |
 			      (*src << greenshift) |
@@ -2289,13 +2421,15 @@ static int __init fbcon_show_logo( void 
 	    greenshift = p->var.green.offset - (8-p->var.green.length);
 	    blueshift  = p->var.blue.offset  - (8-p->var.blue.length);
 
-	    src = logo;
+	    src = logo+offbytes*LOGO_W*LOGO_H;
 	    for( y1 = 0; y1 < LOGO_H; y1++ ) {
-		dst = fb + y1*line + x*bdepth;
+		dst = fb + (y1+y)*line + x*bdepth;
 		for( x1 = 0; x1 < LOGO_W; x1++, src++ ) {
 		    val = safe_shift((linux_logo_red[*src-32]   & redmask), redshift) |
 		          safe_shift((linux_logo_green[*src-32] & greenmask), greenshift) |
 		          safe_shift((linux_logo_blue[*src-32]  & bluemask), blueshift);
+		    if (!(*src))
+		        val=0;
 		    if (bdepth == 4 && !((long)dst & 3)) {
 			/* Some cards require 32bit access */
 			fb_writel (val, dst);
@@ -2319,9 +2453,9 @@ static int __init fbcon_show_logo( void 
 #endif
 #if defined(CONFIG_FBCON_CFB4)
 	if (depth == 4 && p->type == FB_TYPE_PACKED_PIXELS) {
-		src = logo;
+   	        src = logo+offbytes*LOGO_W*LOGO_H;
 		for( y1 = 0; y1 < LOGO_H; y1++) {
-			dst = fb + y1*line + x/2;
+			dst = fb + (y1+y)*line + x/2;
 			for( x1 = 0; x1 < LOGO_W/2; x1++) {
 				u8 q = *src++;
 				q = (q << 4) | (q >> 4);
@@ -2335,9 +2469,9 @@ static int __init fbcon_show_logo( void 
 	if (depth == 8 && p->type == FB_TYPE_PACKED_PIXELS) {
 	    /* depth 8 or more, packed, with color registers */
 		
-	    src = logo;
+	    src = logo+offbytes*LOGO_W*LOGO_H;
 	    for( y1 = 0; y1 < LOGO_H; y1++ ) {
-		dst = fb + y1*line + x;
+		dst = fb + (y1+y)*line + x;
 		for( x1 = 0; x1 < LOGO_W; x1++ )
 		    fb_writeb (*src++, dst++);
 	    }
@@ -2497,6 +2631,11 @@ pm_fbcon_request(struct pm_dev *dev, pm_
 }
 #endif /* CONFIG_PM */
 
+int fbcon_show_logo(void) 
+{
+  return fbcon_show_logo_internal(0);
+}
+
 /*
  *  The console `switch' structure for the frame buffer based console
  */
@@ -2549,6 +2688,7 @@ EXPORT_SYMBOL(fb_display);
 EXPORT_SYMBOL(fbcon_redraw_bmove);
 EXPORT_SYMBOL(fbcon_redraw_clear);
 EXPORT_SYMBOL(fbcon_dummy);
+EXPORT_SYMBOL(fbcon_show_logo);
 EXPORT_SYMBOL(fb_con);
 
 MODULE_LICENSE("GPL");
diff -urp linux/drivers/video/fbmem.c new_kernel_src/drivers/video/fbmem.c
--- linux/drivers/video/fbmem.c	2009-06-10 21:00:37.000000000 +0100
+++ new_kernel_src/drivers/video/fbmem.c	2002-03-25 03:10:33.000000000 +0000
@@ -673,6 +673,7 @@ int GET_FB_IDX(kdev_t rdev)
 }
 #endif
 
+extern void disable_logo(void);
 static int
 fb_open(struct inode *inode, struct file *file)
 {
@@ -680,6 +681,7 @@ fb_open(struct inode *inode, struct file
 	struct fb_info *info;
 	int res = 0;
 
+	disable_logo();
 #ifdef CONFIG_KMOD
 	if (!(info = registered_fb[fbidx]))
 		try_to_load(fbidx);
@@ -892,6 +894,14 @@ int __init video_setup(char *options)
 	        return 0;
     }
 
+    if (!strncmp(options, "dovesa",6)) {
+      for (i = 0; i < NUM_FB_DRIVERS; i++) {
+	if (strcmp(fb_drivers[i].name,"vesa"))
+	  fb_drivers[i].init = NULL;
+      }
+      return 0;
+    }
+
     if (!strncmp(options, "map:", 4)) {
 	    options += 4;
 	    if (*options)
diff -urp linux/drivers/video/matrox/matroxfb_accel.c new_kernel_src/drivers/video/matrox/matroxfb_accel.c
--- linux/drivers/video/matrox/matroxfb_accel.c	2001-10-15 21:47:13.000000000 +0100
+++ new_kernel_src/drivers/video/matrox/matroxfb_accel.c	2002-02-11 23:36:21.000000000 +0000
@@ -143,6 +143,7 @@ void matrox_cfbX_init(WPMINFO struct dis
 	ACCESS_FBINFO(accel.m_opmode) = mopmode;
 }
 
+
 static void matrox_cfbX_bmove(struct display* p, int sy, int sx, int dy, int dx, int height, int width) {
 	int pixx = p->var.xres_virtual, start, end;
 	CRITFLAGS
@@ -186,6 +187,156 @@ static void matrox_cfbX_bmove(struct dis
 	CRITEND
 }
 
+
+int matrox_blittemplate(struct matrox_fb_info* minfo,
+			 u_int32_t fgx, u_int32_t bgx, 
+			 int sy, int sx, 
+			 int height, int width, 
+			 int offset, char* data, int pitch,
+			 unsigned char rop3)	
+{
+	u_int32_t ar0;
+	int i;
+
+	return -EINVAL;
+
+	CRITFLAGS
+
+	DBG_HEAVY("matrox_cfbX_putc");
+
+	CRITBEGIN
+
+	mga_fifo(7);
+	ar0 = width - 1;
+	mga_outl(M_FXBNDRY, ((sx+ar0)<<16) | sx);
+	mga_outl(M_DWGCTL, M_DWG_ILOAD | M_DWG_SGNZERO | M_DWG_SHIFTZERO | M_DWG_BMONOWF | M_DWG_REPLACE);
+	mga_outl(M_FCOL, fgx);
+	mga_outl(M_BCOL, bgx);
+	mga_outl(M_AR5, 0);
+	mga_outl(M_AR3, 0);
+	mga_outl(M_AR0, ar0);
+	mga_ydstlen(sy, height);
+	
+	for (i = height; i > 0; i--) {
+	  mga_memcpy_toio(ACCESS_FBINFO(mmio.vbase), 0, data, (width+7)>>8);
+	  data+=pitch;
+	}
+	WaitTillIdle();
+	CRITEND
+	return 0;  
+}
+
+void matrox_rectcopy(struct matrox_fb_info* minfo, 
+		     int sy, int sx, int dy, int dx, int height, int width,
+		     int vxres) {
+	int pixx = vxres;
+	int start, end;
+	CRITFLAGS
+
+	DBG("matrox_cfbX_bmove")
+
+	CRITBEGIN
+
+	if ((dy < sy) || ((dy == sy) && (dx <= sx))) {
+		mga_fifo(2);
+		mga_outl(M_DWGCTL, M_DWG_BITBLT | M_DWG_SHIFTZERO | M_DWG_SGNZERO |
+			 M_DWG_BFCOL | M_DWG_REPLACE);
+		mga_outl(M_AR5, pixx);
+		width--;
+		start = sy*pixx+sx+curr_ydstorg(MINFO);
+		end = start+width;
+	} else {
+		mga_fifo(3);
+		mga_outl(M_DWGCTL, M_DWG_BITBLT | M_DWG_SHIFTZERO | M_DWG_BFCOL | M_DWG_REPLACE);
+		mga_outl(M_SGN, 5);
+		mga_outl(M_AR5, -pixx);
+		width--;
+		end = (sy+height-1)*pixx+sx+curr_ydstorg(MINFO);
+		start = end+width;
+		dy += height-1;
+	}
+	mga_fifo(4);
+	mga_outl(M_AR0, end);
+	mga_outl(M_AR3, start);
+	mga_outl(M_FXBNDRY, ((dx+width)<<16) | dx);
+	mga_ydstlen(dy, height);
+	WaitTillIdle();
+
+	CRITEND
+}
+
+int matrox_rectcopy_complete(struct matrox_fb_info* minfo, 
+			      int sy, int sx, int dy, int dx, 
+			      int height, int width,
+			      int spitch, int dpitch, int op,
+			      int oldpitch, int Bpp) {
+	int pixx = spitch;
+	int start, end;
+	int myop;
+	unsigned int p1,p2;
+	unsigned int org;
+
+	CRITFLAGS
+	  
+	switch (op) {
+	case 0x0c: myop=M_DWG_REPLACE; break;
+	case 0x06: myop=M_DWG_XOR; break;
+	default: return -EINVAL;
+	}
+
+	p1=sy*spitch+sx;
+	p2=dy*dpitch+dx;
+
+	org=dy*dpitch*Bpp;
+	if (ACCESS_FBINFO(capable.srcorg)) {
+	  mga_outl(M_DSTORG,org);
+	  dy=0;
+	}
+	if (dy>=4096)
+	  return -EINVAL;
+
+	DBG("matrox_cfbX_bmove")
+
+	CRITBEGIN
+
+	mga_fifo(1);
+	mga_outl(M_PITCH, dpitch);
+	WaitTillIdle();
+
+	mga_fifo(3);
+	if (p2 <= p1) {
+		mga_outl(M_DWGCTL, M_DWG_BITBLT | M_DWG_SHIFTZERO | M_DWG_SGNZERO |
+			 M_DWG_BFCOL | myop);
+		mga_outl(M_AR5, spitch);
+		width--;
+		start = sy*spitch+sx+curr_ydstorg(MINFO);
+		end = start+width;
+	} else {
+		mga_outl(M_DWGCTL, M_DWG_BITBLT | M_DWG_SHIFTZERO | M_DWG_BFCOL | myop);
+		mga_outl(M_SGN, 5);
+		mga_outl(M_AR5, -spitch);
+		width--;
+		end = (sy+height-1)*spitch+sx+curr_ydstorg(MINFO);
+		start = end+width;
+		dy += height-1;
+	}
+	mga_fifo(5);
+	mga_outl(M_AR0, end);
+	mga_outl(M_AR3, start);
+	mga_outl(M_FXBNDRY, ((dx+width)<<16) | dx);
+	mga_ydstlen(dy, height);
+	WaitTillIdle();
+
+	mga_outl(M_PITCH, oldpitch);
+	if (ACCESS_FBINFO(capable.srcorg)) {
+	  mga_outl(M_DSTORG,0);
+	}
+	WaitTillIdle();
+
+	CRITEND
+	return 0;
+}
+
 #ifdef FBCON_HAS_CFB4
 static void matrox_cfb4_bmove(struct display* p, int sy, int sx, int dy, int dx, int height, int width) {
 	int pixx, start, end;
@@ -242,8 +393,8 @@ static void matrox_cfb4_bmove(struct dis
 }
 #endif
 
-static void matroxfb_accel_clear(WPMINFO u_int32_t color, int sy, int sx, int height,
-		int width) {
+void matroxfb_accel_clear(WPMINFO u_int32_t color, int sy, int sx, int height,
+			  int width) {
 	CRITFLAGS
 
 	DBG("matroxfb_accel_clear")
diff -urp linux/drivers/video/matrox/matroxfb_base.c new_kernel_src/drivers/video/matrox/matroxfb_base.c
--- linux/drivers/video/matrox/matroxfb_base.c	2009-06-10 21:00:37.000000000 +0100
+++ new_kernel_src/drivers/video/matrox/matroxfb_base.c	2002-03-25 03:10:33.000000000 +0000
@@ -92,6 +92,7 @@
 
 /* make checkconfig does not check included files... */
 #include <linux/config.h>
+#include "../amithlon.h"
 
 #include "matroxfb_base.h"
 #include "matroxfb_misc.h"
@@ -249,6 +250,7 @@ static int matroxfb_pan_display(struct f
 
 	DBG("matroxfb_pan_display")
 
+#if 0
 	if (var->vmode & FB_VMODE_YWRAP) {
 		if (var->yoffset < 0 || var->yoffset >= fb_display[con].var.yres_virtual || var->xoffset)
 			return -EINVAL;
@@ -257,6 +259,7 @@ static int matroxfb_pan_display(struct f
 		    var->yoffset+fb_display[con].var.yres > fb_display[con].var.yres_virtual)
 			return -EINVAL;
 	}
+#endif
 	if (con == ACCESS_FBINFO(currcon))
 		matrox_pan_var(PMINFO var);
 	fb_display[con].var.xoffset = var->xoffset;
@@ -479,11 +482,12 @@ static int matroxfb_decode_var(CPMINFO s
 		var->yres = var->yres_virtual;
 	if (var->xres_virtual < var->xres)
 		var->xres = var->xres_virtual;
+#if 0
 	if (var->xoffset + var->xres > var->xres_virtual)
 		var->xoffset = var->xres_virtual - var->xres;
 	if (var->yoffset + var->yres > var->yres_virtual)
 		var->yoffset = var->yres_virtual - var->yres;
-
+#endif
 	if (var->bits_per_pixel == 0) {
 		var->red.offset = 0;
 		var->red.length = 6;
@@ -1006,6 +1010,24 @@ static int matroxfb_get_vblank(CPMINFO s
 	return 0;
 }
 
+void matrox_rectcopy(struct matrox_fb_info* minfo, 
+		     int sy, int sx, int dy, int dx, int height, int width,
+		     int vxres);
+int matrox_rectcopy_complete(struct matrox_fb_info* minfo, 
+			     int sy, int sx, int dy, int dx, 
+			     int height, int width,
+			     int spitch, int dpitch, int op,
+			     int oldpitch, int Bpp);
+
+void matroxfb_accel_clear(WPMINFO u_int32_t color, int sy, int sx, int height,
+			  int width);
+int matrox_blittemplate(struct matrox_fb_info* minfo,
+			u_int32_t fgx, u_int32_t bgx, 
+			int sy, int sx, 
+			int height, int width, 
+			int offset, char* data, int pitch,
+			unsigned char rop3);
+
 static int matroxfb_ioctl(struct inode *inode, struct file *file,
 			  unsigned int cmd, unsigned long arg, int con,
 			  struct fb_info *info)
@@ -1158,6 +1180,89 @@ static int matroxfb_ioctl(struct inode *
 					return -EFAULT;
 				return 0;
 			}
+ 	        case MATROX_CROSS_4MB:
+			{
+				if (put_user(ACCESS_FBINFO(capable.cross4MB), (u_int32_t*)arg))
+					return -EFAULT;
+				return 0;
+			}
+ 	        case AMITHLON_MAXCLOCK:
+			{
+				if (put_user(ACCESS_FBINFO(max_pixel_clock), (u_int32_t*)arg))
+					return -EFAULT;
+				return 0;
+			}
+	        case AMITHLON_COPY_RECT: 
+			{ /* Copy rectangle */
+				amithlon_copy ac;
+				
+				if (copy_from_user(&ac, (void *) arg, sizeof(ac)))
+					return -EFAULT;
+				matrox_rectcopy(minfo,
+						ac.sy,
+						ac.sx,
+						ac.dy,
+						ac.dx,
+						ac.height,
+						ac.width,
+						ac.vxres);
+				return 0;
+			}
+
+	        case AMITHLON_COPY_RECT_COMPLETE: 
+			{ /* Copy rectangle */
+				amithlon_copy_complete acr;
+				
+				if (copy_from_user(&acr, (void *) arg, sizeof(acr)))
+					return -EFAULT;
+				return matrox_rectcopy_complete(minfo,
+								acr.sy,
+								acr.sx,
+								acr.dy,
+								acr.dx,
+								acr.height,
+								acr.width,
+								acr.spitch,
+								acr.dpitch,
+								acr.op,
+								acr.oldpitch,
+								acr.Bpp);
+			}
+
+	       case AMITHLON_FILL_RECT: 
+		       { /* Fill rectangle */
+			       amithlon_fill af;
+			       
+			       if (copy_from_user(&af, (void *) arg, sizeof(af)))
+				       return -EFAULT;
+			       matroxfb_accel_clear(PMINFO
+						    af.colour,
+						    af.sy,
+						    af.sx,
+						    af.height,
+						    af.width);
+			       return 0;
+		       }
+	      case AMITHLON_BLIT_TEMP: { /* Blit Template */
+		      amithlon_blittemplate ab;
+		      int answer=0;
+		      
+		      if (copy_from_user(&ab, (void *) arg, sizeof(ab)))
+			      return -EFAULT;
+		      answer=matrox_blittemplate(minfo,
+						 ab.colour0,
+						 ab.colour1,
+						 ab.sy,
+						 ab.sx,
+						 ab.height,
+						 ab.width,
+						 ab.offset,
+						 ab.data,
+						 ab.pitch,
+						 ab.rop3);
+		      return answer;
+	      }
+
 	}
 	return -EINVAL;
 #undef minfo
diff -urp linux/drivers/video/riva/accel.c new_kernel_src/drivers/video/riva/accel.c
--- linux/drivers/video/riva/accel.c	2009-06-10 21:00:37.000000000 +0100
+++ new_kernel_src/drivers/video/riva/accel.c	2002-03-25 03:10:33.000000000 +0000
@@ -9,6 +9,7 @@
  */
 
 #include "rivafb.h"
+#include <asm/uaccess.h>
 
 /* acceleration routines */
 
@@ -40,8 +41,79 @@ void riva_setup_accel(struct rivafb_info
 	wait_for_idle(rinfo);
 }
 
-static void riva_rectfill(struct rivafb_info *rinfo, int sy,
-			  int sx, int height, int width, u_int color)
+void riva_rectcopy(struct rivafb_info *rinfo, int sy, int sx, int dy, int dx,
+		   int height, int width)
+{
+    RIVA_FIFO_FREE(rinfo->riva, Blt, 3);
+    rinfo->riva.Blt->TopLeftSrc  = (sy << 16) | sx;
+    rinfo->riva.Blt->TopLeftDst  = (dy << 16) | dx;
+    rinfo->riva.Blt->WidthHeight = (height  << 16) | width;
+}
+
+int riva_rectcopy_complete(struct rivafb_info *rinfo, 
+			   int sy, int sx, 
+			   int dy, int dx,
+			   int height, int width,
+			   int spitch, int dpitch,
+			   int op,
+			   int oldpitch, int Bpp)
+{
+  int off0;
+  int off1;
+
+  spitch*=Bpp;
+  dpitch*=Bpp;
+
+  if (dpitch!=spitch) {
+    off0=dy*dpitch;
+    off1=sy*spitch;
+    dy=sy=0;
+  }
+  else {
+    int min=dy<sy?dy:sy;
+    off0=min*dpitch;
+    off1=min*spitch;
+    dy-=min;
+    sy-=min;
+  }
+
+  if (dy>=8192 || sy>=8192)
+    return -EINVAL;
+
+  setPitches(&(rinfo->riva),
+	     dpitch,
+	     spitch,
+	     oldpitch*Bpp,
+	     oldpitch*Bpp,
+	     off0,
+	     off1);
+  wait_for_idle(rinfo);
+
+  
+  RIVA_FIFO_FREE(rinfo->riva, Rop, 1);
+  rinfo->riva.Rop->Rop3 = (op&0x0f)*0x11;
+
+  RIVA_FIFO_FREE(rinfo->riva, Blt, 3);
+  rinfo->riva.Blt->TopLeftSrc  = (sy << 16) | sx;
+  rinfo->riva.Blt->TopLeftDst  = (dy << 16) | dx;
+  rinfo->riva.Blt->WidthHeight = (height  << 16) | width;
+
+  RIVA_FIFO_FREE(rinfo->riva, Rop, 1);
+  rinfo->riva.Rop->Rop3 = 0xCC;
+
+  wait_for_idle(rinfo);
+  setPitches(&(rinfo->riva),
+	     oldpitch*Bpp,
+	     oldpitch*Bpp,
+	     oldpitch*Bpp,
+	     oldpitch*Bpp,
+	     0,
+	     0);
+  return 0;
+}
+
+void riva_rectfill(struct rivafb_info *rinfo, int sy,
+		   int sx, int height, int width, u_int color)
 {
 	RIVA_FIFO_FREE(rinfo->riva, Bitmap, 1);
 	rinfo->riva.Bitmap->Color1A = color;
@@ -51,6 +123,128 @@ static void riva_rectfill(struct rivafb_
 	rinfo->riva.Bitmap->UnclippedRectangle[0].WidthHeight = (width << 16) | height;
 }
 
+void riva_drawline(struct rivafb_info *rinfo, int sy,
+		   int sx, int dy, int dx, 
+		   unsigned long offset, u_int color)
+{
+  setPitches(&(rinfo->riva),
+	     (&(rinfo->riva))->CurrentState->pitch0,
+	     (&(rinfo->riva))->CurrentState->pitch1,
+	     (&(rinfo->riva))->CurrentState->pitch2,
+	     (&(rinfo->riva))->CurrentState->pitch3,
+	     offset,
+	     offset);
+  wait_for_idle(rinfo);
+  
+  RIVA_FIFO_FREE(rinfo->riva, Line, 5);
+  
+  rinfo->riva.Line->Color = color;
+  
+  rinfo->riva.Line->Lin[0].point0     = (sy << 16) | (sx & 0xffff); 
+  rinfo->riva.Line->Lin[0].point1     = (dy << 16) | (dx & 0xffff); 
+  rinfo->riva.Line->Lin[1].point0     = (dy << 16) | (dx & 0xffff); 
+  rinfo->riva.Line->Lin[1].point1     = ((dy+1) << 16) | (dx & 0xffff); 
+
+  wait_for_idle(rinfo);
+  setPitches(&(rinfo->riva),
+	     (&(rinfo->riva))->CurrentState->pitch0,
+	     (&(rinfo->riva))->CurrentState->pitch1,
+	     (&(rinfo->riva))->CurrentState->pitch2,
+	     (&(rinfo->riva))->CurrentState->pitch3,
+	     0,
+	     0);
+}
+
+static u8 byte_rev[256] = {
+	0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
+	0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8, 
+	0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4, 
+	0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc, 
+	0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2, 
+	0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa, 
+	0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6, 
+	0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe, 
+	0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1, 
+	0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9, 
+	0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5, 
+	0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd, 
+	0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3, 
+	0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb, 
+	0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7, 
+	0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,
+};
+
+static void riva_setrop3(struct rivafb_info *rinfo, unsigned char x)
+{
+  RIVA_FIFO_FREE(rinfo->riva, Rop, 1);
+  rinfo->riva.Rop->Rop3 = x; 
+}
+
+int riva_blittemplate(struct rivafb_info *rinfo,
+		      u_int colour0, u_int colour1,
+		      int sy, int sx, 
+		      int height, int width, 
+		      int offset, char* data, int pitch,
+		      unsigned char rop3)
+{
+    volatile u32 *d;
+    int i, j, cnt;
+    int maskwidth=width+offset;
+    int wc=(maskwidth+31)>>5;
+    int fifoind;
+    int infifo;
+    u8  kdat[64];
+    
+    
+    riva_setrop3(rinfo, rop3);
+    RIVA_FIFO_FREE(rinfo->riva, Bitmap, 7);
+    rinfo->riva.Bitmap->ClipE.TopLeft     = (sy << 16) | (sx & 0xFFFF);
+    rinfo->riva.Bitmap->ClipE.BottomRight = ((sy+height) << 16) | ((sx+width) & 0xffff);
+    rinfo->riva.Bitmap->Color0E           = colour0;
+    rinfo->riva.Bitmap->Color1E           = colour1;
+    rinfo->riva.Bitmap->WidthHeightInE  = (height << 16) | (wc*32);
+    rinfo->riva.Bitmap->WidthHeightOutE = (height << 16) | (wc*32);
+    rinfo->riva.Bitmap->PointE          = (sy << 16) | ((sx-offset) & 0xFFFF);
+    
+    d = &rinfo->riva.Bitmap->MonochromeData01E;
+    infifo=0;
+    fifoind=0;
+    
+    for (i=0;i<height;i++) {
+	u32* ldata=(u32*)data;
+	for (j=wc;j;j--) {
+	    if (!infifo) {
+		if (j>16)
+		    cnt=16;
+		else
+		    cnt=j;
+		if (copy_from_user(kdat,ldata,cnt<<2)) {
+		    riva_setrop3(rinfo, 0xcc);
+		    return -EFAULT;
+		}
+		RIVA_FIFO_FREE(rinfo->riva, Bitmap, cnt);
+		
+		infifo=cnt;
+		fifoind=0;
+		ldata+=cnt;
+	    }
+	    {
+	      int ind=fifoind<<2;
+	      u32 val=((u32)byte_rev[kdat[ind+3]]<<24) |
+		((u32)byte_rev[kdat[ind+2]]<<16) |
+		((u32)byte_rev[kdat[ind+1]]<<8) |
+		((u32)byte_rev[kdat[ind+0]]<<0);
+	      d[fifoind]=val;
+	    }
+	    fifoind++;
+	    infifo--;
+	}
+	data+=pitch;
+    }
+    riva_setrop3(rinfo, 0xcc);
+    return 0;
+}
+
 static void fbcon_riva_bmove(struct display *p, int sy, int sx, int dy, int dx,
 			    int height, int width)
 {
@@ -88,24 +282,6 @@ static void riva_clear_margins(struct vc
 			      bottom_width, right_start, bgx);
 }
 
-static u8 byte_rev[256] = {
-	0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
-	0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8, 
-	0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4, 
-	0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc, 
-	0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2, 
-	0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa, 
-	0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6, 
-	0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe, 
-	0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1, 
-	0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9, 
-	0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5, 
-	0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd, 
-	0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3, 
-	0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb, 
-	0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7, 
-	0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,
-};
 
 static inline void fbcon_reverse_order(u32 *l)
 {
diff -urp linux/drivers/video/riva/fbdev.c new_kernel_src/drivers/video/riva/fbdev.c
--- linux/drivers/video/riva/fbdev.c	2009-06-10 21:00:37.000000000 +0100
+++ new_kernel_src/drivers/video/riva/fbdev.c	2002-03-25 03:10:33.000000000 +0000
@@ -95,8 +95,8 @@
 #define CURSOR_HIDE_DELAY		(20)
 #define CURSOR_SHOW_DELAY		(3)
 
-#define CURSOR_COLOR		0x7fff
-#define TRANSPARENT_COLOR	0x0000
+#define CURSOR_COLOR		0x4c00
+#define TRANSPARENT_COLOR	0x8000
 #define MAX_CURS		32
 
 
@@ -523,11 +523,17 @@ static void rivafb_exit_cursor(struct ri
  * CALLED FROM:
  * riva_load_video_mode()
  */
-static void rivafb_download_cursor(struct rivafb_info *rinfo)
+static void rivafb_download_cursor(struct rivafb_info *rinfo, int level)
 {
 	int i, save;
 	int *image;
+	static int maxlevel=0;
 	
+	if (level<maxlevel)
+	  return;
+	if (level>maxlevel)
+	  maxlevel=level;
+
 	if (!rinfo->cursor) return;
 
 	image = (int *)rinfo->cursor->image;
@@ -651,6 +657,80 @@ static void rivafb_cursor(struct display
 }
 
 
+static void rivafb_amithlon_poscursor(struct rivafb_info *rinfo,
+				      unsigned int x,
+				      unsigned int y,
+				      unsigned int on)
+{
+	struct riva_cursor *c = rinfo->cursor;
+
+	if (!c)	return;
+
+	if (!on)
+	  x=y=0xffffffff;
+
+	if (c->pos.x == x && c->pos.y == y)
+		return;
+	c->enable = 0;
+	c->pos.x = x;
+	c->pos.y = y;
+	*(rinfo->riva.CURSORPOS) = (x & 0xFFFF) | (y << 16);
+	rinfo->riva.ShowHideCursor(&rinfo->riva, on);
+}
+
+static void rivafb_amithlon_setcursor(struct rivafb_info *rinfo, 
+				      unsigned int* data,
+				      unsigned char* red,
+				      unsigned char* green,
+				      unsigned char* blue)
+{
+	struct riva_cursor *c = rinfo->cursor;
+	int i, j, idx;
+	int width,height;
+
+	width=height=32;
+	if (c) {
+		if (width > MAX_CURS) width = MAX_CURS;
+		if (height > MAX_CURS) height = MAX_CURS;
+
+		c->size.x = width;
+		c->size.y = height;
+		
+		idx = 0;
+
+		for (i = 0; i < height; i++) {
+		  int p1,p2;
+		  p1=data[2*i];
+		  p2=data[2*i+1];
+		  
+		  for (j = 0; j < width; j++,idx++) {
+		    int b1,b2,v;
+		    unsigned int colour;
+
+		    b1=!!(p1&(1<<(31-j)));
+		    b2=!!(p2&(1<<(31-j)));
+		    v=b1+2*b2;
+
+		    colour=(((((unsigned int)red[v])>>3)&0x1f)<<10) |
+		      (((((unsigned int)green[v])>>3)&0x1f)<<5) |
+		      (((((unsigned int)blue[v])>>3)&0x1f)<<0) | 
+		      0x8000;
+		    if (!v)
+		      colour=0;
+
+		    c->image[idx] = colour;
+		  }
+		  for (j = width; j < MAX_CURS; j++,idx++)
+		    c->image[idx] = TRANSPARENT_COLOR;
+		}
+		for (i = height; i < MAX_CURS; i++)
+		  for (j = 0; j < MAX_CURS; j++,idx++)
+		    c->image[idx] = TRANSPARENT_COLOR;
+	}
+	rivafb_download_cursor(rinfo,1);
+}
+
+
 
 /* ------------------------------------------------------------------------- *
  *
@@ -929,7 +1009,7 @@ static void riva_load_video_mode(struct 
 	riva_load_state(rinfo, &rinfo->current_state);
 
 	rinfo->riva.LockUnlock(&rinfo->riva, 0); /* important for HW cursor */
-	rivafb_download_cursor(rinfo);
+	rivafb_download_cursor(rinfo,0);
 }
 
 /**
@@ -1475,12 +1555,14 @@ static int rivafb_set_var(struct fb_var_
 	if (v.yoffset < 0)
 		v.yoffset = 0;
 
+#if 0
 	/* truncate xoffset and yoffset to maximum if too high */
 	if (v.xoffset > v.xres_virtual - v.xres)
 		v.xoffset = v.xres_virtual - v.xres - 1;
 
 	if (v.yoffset > v.yres_virtual - v.yres)
 		v.yoffset = v.yres_virtual - v.yres - 1;
+#endif
 
 	v.red.msb_right =
 	    v.green.msb_right =
@@ -1610,11 +1692,12 @@ static int rivafb_pan_display(struct fb_
 
 	assert(rivainfo != NULL);
 
+#if 0
 	if (var->xoffset > (var->xres_virtual - var->xres))
 		return -EINVAL;
 	if (var->yoffset > (var->yres_virtual - var->yres))
 		return -EINVAL;
-
+#endif
 	dsp = (con < 0) ? rivainfo->info.disp : &fb_display[con];
 
 	if (var->vmode & FB_VMODE_YWRAP) {
@@ -1622,9 +1705,11 @@ static int rivafb_pan_display(struct fb_
 		    || var->yoffset >= dsp->var.yres_virtual
 		    || var->xoffset) return -EINVAL;
 	} else {
+#if 0
 		if (var->xoffset + dsp->var.xres > dsp->var.xres_virtual ||
 		    var->yoffset + dsp->var.yres > dsp->var.yres_virtual)
 			return -EINVAL;
+#endif
 	}
 
 	base = var->yoffset * dsp->line_length + var->xoffset;
@@ -1646,20 +1731,176 @@ static int rivafb_pan_display(struct fb_
 	return 0;
 }
 
+#include "../amithlon.h"
+#include <asm/uaccess.h>
+
+void riva_rectfill(struct rivafb_info *rinfo, int sy,
+		   int sx, int height, int width, u_int color);
+void riva_rectcopy(struct rivafb_info *rinfo, int sy, int sx, int dy, int dx,
+		   int height, int width);
+int riva_blittemplate(struct rivafb_info *rinfo,
+		      u_int colour0, u_int colour1,
+		      int sy, int sx, 
+		      int height, int width, 
+		      int offset, char* data, int pitch,
+		      unsigned char rop3);
+int riva_rectcopy_complete(struct rivafb_info *rinfo, 
+			   int sy, int sx, 
+			   int dy, int dx,
+			   int height, int width,
+			   int spitch, int dpitch,
+			   int op,
+			   int oldpitch, int Bpp);
+void riva_drawline(struct rivafb_info *rinfo, int sy,
+		   int sx, int dy, int dx, 
+		   unsigned long offset, u_int color);
+
+static inline void wait_for_idle(struct rivafb_info *rinfo)
+{
+    while (rinfo->riva.Busy(&rinfo->riva));
+}
+
 static int rivafb_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
 			unsigned long arg, int con, struct fb_info *info)
 {
 	struct rivafb_info *rivainfo = (struct rivafb_info *)info;
 
 	DPRINTK("ENTER\n");
-
 	assert(rivainfo != NULL);
-
-	/* no rivafb-specific ioctls */
-
-	DPRINTK("EXIT, returning -EINVAL\n");
-
-	return -EINVAL;
+	
+	switch(cmd) {
+	 case AMITHLON_FILL_RECT: { /* Fill rectangle */
+	     amithlon_fill af;
+
+	     if (copy_from_user(&af, (void *) arg, sizeof(af)))
+		 return -EFAULT;
+	     riva_rectfill(rivainfo,
+			   af.sy,
+			   af.sx,
+			   af.height,
+			   af.width,
+			   af.colour);
+	     wait_for_idle(rivainfo);
+	     return 0;
+	 }
+
+	case AMITHLON_DRAW_LINE: { /* Draw a line */
+	     amithlon_line al;
+
+	     if (copy_from_user(&al, (void *) arg, sizeof(al)))
+		 return -EFAULT;
+	     riva_drawline(rivainfo,
+			   al.sy,
+			   al.sx,
+			   al.dy,
+			   al.dx,
+			   al.offset,
+			   al.colour);
+	     wait_for_idle(rivainfo);
+	     return 0;
+	 }
+
+	 case AMITHLON_COPY_RECT: { /* Copy rectangle */
+	     amithlon_copy ac;
+
+	     if (copy_from_user(&ac, (void *) arg, sizeof(ac)))
+		 return -EFAULT;
+	     riva_rectcopy(rivainfo,
+			   ac.sy,
+			   ac.sx,
+			   ac.dy,
+			   ac.dx,
+			   ac.height,
+			   ac.width);
+	     wait_for_idle(rivainfo);
+	     return 0;
+	 }
+
+	case AMITHLON_COPY_RECT_COMPLETE: 
+	  { /* Copy rectangle */
+	    amithlon_copy_complete acr;
+	    int answer;
+
+	    if (copy_from_user(&acr, (void *) arg, sizeof(acr)))
+	      return -EFAULT;
+	    answer=riva_rectcopy_complete(rivainfo,
+					  acr.sy,
+					  acr.sx,
+					  acr.dy,
+					  acr.dx,
+					  acr.height,
+					  acr.width,
+					  acr.spitch,
+					  acr.dpitch,
+					  acr.op,
+					  acr.oldpitch,
+					  acr.Bpp);
+	    wait_for_idle(rivainfo);
+	    return answer;
+	  }
+	  
+
+	 case AMITHLON_BLIT_TEMP: { /* Blit Template */
+	     amithlon_blittemplate ab;
+	     int answer=0;
+
+	     if (copy_from_user(&ab, (void *) arg, sizeof(ab)))
+		 return -EFAULT;
+	     answer=riva_blittemplate(rivainfo,
+				      ab.colour0,
+				      ab.colour1,
+				      ab.sy,
+				      ab.sx,
+				      ab.height,
+				      ab.width,
+				      ab.offset,
+				      ab.data,
+				      ab.pitch,
+				      ab.rop3);
+	     wait_for_idle(rivainfo);
+	     return answer;
+	 }
+
+	case AMITHLON_MAXCLOCK:
+	  {
+	    unsigned int answer=rivainfo->dclk_max/1000;
+
+	    if (put_user(answer, (u_int32_t*)arg))
+	      return -EFAULT;
+	    return 0;
+	  }
+	case AMITHLON_SET_CURSOR:
+	  {
+	    unsigned int data[64];
+	    unsigned char red[4];
+	    unsigned char green[4];
+	    unsigned char blue[4];
+	    amithlon_setcursor asc;
+
+	    if (copy_from_user(&asc, (void *) arg, sizeof(asc)))
+	      return -EFAULT;
+	    if (copy_from_user(data, asc.data, 64*sizeof(unsigned int)))
+	      return -EFAULT;
+	    if (copy_from_user(red, asc.red, 4*sizeof(unsigned char)))
+	      return -EFAULT;
+	    if (copy_from_user(green, asc.green, 4*sizeof(unsigned char)))
+	      return -EFAULT;
+	    if (copy_from_user(blue, asc.blue, 4*sizeof(unsigned char)))
+	      return -EFAULT;
+	    rivafb_amithlon_setcursor(rivainfo,data,red,green,blue);
+	    return 0;
+	  }
+	case AMITHLON_POS_CURSOR:
+	  {
+	    amithlon_poscursor apc;
+	    if (copy_from_user(&apc, (void *) arg, sizeof(apc)))
+	      return -EFAULT;
+	    rivafb_amithlon_poscursor(rivainfo,apc.x,apc.y,apc.on);
+	    return 0;
+	  }
+	 default:
+	    return -EINVAL;
+	}
 }
 
 static int rivafb_rasterimg(struct fb_info *info, int start)
diff -urp linux/drivers/video/riva/riva_hw.c new_kernel_src/drivers/video/riva/riva_hw.c
--- linux/drivers/video/riva/riva_hw.c	2002-02-25 19:38:07.000000000 +0000
+++ new_kernel_src/drivers/video/riva/riva_hw.c	2002-02-12 18:20:31.000000000 +0000
@@ -1251,7 +1251,8 @@ static void CalcStateExt
     state->pitch0   =
     state->pitch1   =
     state->pitch2   =
-    state->pitch3   = pixelDepth * width;
+      state->pitch3   = pixelDepth * width;
+    /* printk("pitch is %d\n",state->pitch3); */
 }
 /*
  * Load fixed function state and pre-calculated/stored state.
@@ -1297,6 +1298,8 @@ static void UpdateFifoState
             break;
     }
 }
+
+
 static void LoadStateExt
 (
     RIVA_HW_INST  *chip,
@@ -1564,6 +1567,7 @@ static void LoadStateExt
      * Set current state pointer.
      */
     chip->CurrentState = state;
+
     /*
      * Reset FIFO free and empty counts.
      */
@@ -1571,6 +1575,83 @@ static void LoadStateExt
     /* Free count from first subchannel */
     chip->FifoEmptyCount = chip->Rop->FifoFree; 
 }
+
+static void LoadStateExt_pitches
+(
+    RIVA_HW_INST  *chip,
+    RIVA_HW_STATE *state
+)
+{
+    int i;
+
+    switch (chip->Architecture)
+    {
+        case NV_ARCH_03:
+            chip->PGRAPH[0x00000630/4] = state->offset0;
+            chip->PGRAPH[0x00000634/4] = state->offset1;
+            chip->PGRAPH[0x00000638/4] = state->offset2;
+            chip->PGRAPH[0x0000063C/4] = state->offset3;
+            chip->PGRAPH[0x00000650/4] = state->pitch0;
+            chip->PGRAPH[0x00000654/4] = state->pitch1;
+            chip->PGRAPH[0x00000658/4] = state->pitch2;
+            chip->PGRAPH[0x0000065C/4] = state->pitch3;
+            break;
+        case NV_ARCH_04:
+            chip->PGRAPH[0x00000640/4] = state->offset0;
+            chip->PGRAPH[0x00000644/4] = state->offset1;
+            chip->PGRAPH[0x00000648/4] = state->offset2;
+            chip->PGRAPH[0x0000064C/4] = state->offset3;
+            chip->PGRAPH[0x00000670/4] = state->pitch0;
+            chip->PGRAPH[0x00000674/4] = state->pitch1;
+            chip->PGRAPH[0x00000678/4] = state->pitch2;
+            chip->PGRAPH[0x0000067C/4] = state->pitch3;
+            break;
+        case NV_ARCH_10:
+	case NV_ARCH_20:
+	    if (chip->Architecture == NV_ARCH_10) {
+            	chip->PGRAPH[0x00000640/4] = state->offset0;
+            	chip->PGRAPH[0x00000644/4] = state->offset1;
+            	chip->PGRAPH[0x00000648/4] = state->offset2;
+            	chip->PGRAPH[0x0000064C/4] = state->offset3;
+            	chip->PGRAPH[0x00000670/4] = state->pitch0;
+            	chip->PGRAPH[0x00000674/4] = state->pitch1;
+            	chip->PGRAPH[0x00000678/4] = state->pitch2;
+            	chip->PGRAPH[0x0000067C/4] = state->pitch3;
+            	chip->PGRAPH[0x00000680/4] = state->pitch3;
+	    } else {
+		chip->PGRAPH[0x00000820/4] = state->offset0;
+		chip->PGRAPH[0x00000824/4] = state->offset1;
+		chip->PGRAPH[0x00000828/4] = state->offset2;
+		chip->PGRAPH[0x0000082C/4] = state->offset3;
+		chip->PGRAPH[0x00000850/4] = state->pitch0;
+		chip->PGRAPH[0x00000854/4] = state->pitch1;
+		chip->PGRAPH[0x00000858/4] = state->pitch2;
+		chip->PGRAPH[0x0000085C/4] = state->pitch3;
+		chip->PGRAPH[0x00000860/4] = state->pitch3;
+		chip->PGRAPH[0x00000864/4] = state->pitch3;
+		chip->PGRAPH[0x000009A4/4] = chip->PFB[0x00000200/4];
+		chip->PGRAPH[0x000009A8/4] = chip->PFB[0x00000204/4];
+	    }
+            break;
+    }
+}
+
+void setPitches(RIVA_HW_INST *chip, int pitch0, int pitch1, 
+		int pitch2, int pitch3, int off0, int off1)
+{
+  RIVA_HW_STATE *state;
+  
+  state=chip->CurrentState;
+  state->pitch0=pitch0;
+  state->pitch1=pitch1;
+  state->pitch2=pitch2;
+  state->pitch3=pitch3;
+  state->offset0=off0;
+  state->offset1=off1;
+  LoadStateExt_pitches(chip,state);
+}
+
+
 static void UnloadStateExt
 (
     RIVA_HW_INST  *chip,
diff -urp linux/drivers/video/riva/riva_hw.h new_kernel_src/drivers/video/riva/riva_hw.h
--- linux/drivers/video/riva/riva_hw.h	2002-02-25 19:38:07.000000000 +0000
+++ new_kernel_src/drivers/video/riva/riva_hw.h	2002-02-12 06:53:25.000000000 +0000
@@ -458,5 +458,8 @@ int RivaGetConfig(RIVA_HW_INST *);
 	(hwinst).FifoFreeCount = (hwinst).hwptr->FifoFree >> 2;        \
    (hwinst).FifoFreeCount -= (cnt);                                \
 }
+
+void setPitches(RIVA_HW_INST *chip, int pitch0, int pitch1, 
+		int pitch2, int pitch3, int off0, int off1);
 #endif /* __RIVA_HW_H__ */
 
diff -urp linux/drivers/video/riva/riva_tbl.h new_kernel_src/drivers/video/riva/riva_tbl.h
--- linux/drivers/video/riva/riva_tbl.h	2001-02-13 21:15:05.000000000 +0000
+++ new_kernel_src/drivers/video/riva/riva_tbl.h	2002-02-12 19:28:06.000000000 +0000
@@ -36,15 +36,12 @@
 |*     those rights set forth herein.                                        *|
 |*                                                                           *|
  \***************************************************************************/
+/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/nv/riva_tbl.h,v 1.8 2001/09/19 23:40:06 mvojkovi Exp $ */
 
-/*
- * GPL licensing note -- nVidia is allowing a liberal interpretation of
- * the documentation restriction above, to merely say that this nVidia's
- * copyright and disclaimer should be included with all code derived
- * from this source.  -- Jeff Garzik <jgarzik@mandrakesoft.com>, 01/Nov/99 
- */
 
-/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/nv/riva_tbl.h,v 1.5 2000/02/08 17:19:12 dawes Exp $ */
+#define X_BYTE_ORDER 1
+#define X_BIG_ENDIAN 2
+
 /*
  * RIVA Fixed Functionality Init Tables.
  */
@@ -69,6 +66,7 @@ static unsigned RivaTableFIFO[][2] =
     {0x00001800, 0x80000010},
     {0x00002000, 0x80000011},
     {0x00002800, 0x80000012},
+    {0x00003000, 0x80000016},
     {0x00003800, 0x80000013}
 };
 static unsigned nv3TablePFIFO[][2] =
@@ -174,6 +172,8 @@ static unsigned nv3TablePRAMIN[][2] =
     {0x00000249, 0x00CC0346},
     {0x0000024C, 0x80000013},
     {0x0000024D, 0x00D70347},
+    {0x00000258, 0x80000016},
+    {0x00000259, 0x00CA034C},
     {0x00000D05, 0x00000000},
     {0x00000D06, 0x00000000},
     {0x00000D07, 0x00000000},
@@ -210,7 +210,10 @@ static unsigned nv3TablePRAMIN[][2] =
     {0x00000D2C, 0x10830200},
     {0x00000D2D, 0x00000000},
     {0x00000D2E, 0x00000000},
-    {0x00000D2F, 0x00000000} 
+    {0x00000D2F, 0x00000000},
+    {0x00000D31, 0x00000000},
+    {0x00000D32, 0x00000000},
+    {0x00000D33, 0x00000000}
 };
 static unsigned nv3TablePRAMIN_8BPP[][2] =
 {
@@ -222,7 +225,8 @@ static unsigned nv3TablePRAMIN_8BPP[][2]
     {0x00000D10, 0x10118203},
     {0x00000D14, 0x10110203},
     {0x00000D18, 0x10110203},
-    {0x00000D1C, 0x10419208}
+    {0x00000D1C, 0x10419208},
+    {0x00000D30, 0x10118203}
 };
 static unsigned nv3TablePRAMIN_15BPP[][2] =
 {
@@ -234,7 +238,8 @@ static unsigned nv3TablePRAMIN_15BPP[][2
     {0x00000D10, 0x10118200},
     {0x00000D14, 0x10110200},
     {0x00000D18, 0x10110200},
-    {0x00000D1C, 0x10419208}
+    {0x00000D1C, 0x10419208},
+    {0x00000D30, 0x10118200}
 };
 static unsigned nv3TablePRAMIN_32BPP[][2] =
 {
@@ -246,7 +251,8 @@ static unsigned nv3TablePRAMIN_32BPP[][2
     {0x00000D10, 0x10118201},
     {0x00000D14, 0x10110201},
     {0x00000D18, 0x10110201},
-    {0x00000D1C, 0x10419208}
+    {0x00000D1C, 0x10419208},
+    {0x00000D30, 0x10118201}
 };
 static unsigned nv4TableFIFO[][2] =
 {
@@ -370,6 +376,8 @@ static unsigned nv4TablePRAMIN[][2] =
     {0x00000009, 0x80011149},
     {0x0000000A, 0x80000015},
     {0x0000000B, 0x8001114A},
+    {0x0000000C, 0x80000016},
+    {0x0000000D, 0x8001114F},
     {0x00000020, 0x80000000},
     {0x00000021, 0x80011142},
     {0x00000022, 0x80000001},
@@ -437,7 +445,10 @@ static unsigned nv4TablePRAMIN[][2] =
     {0x00000537, 0x00000000},
     {0x00000538, 0x0000005B},
     {0x0000053A, 0x11401140},
-    {0x0000053B, 0x00000000} 
+    {0x0000053B, 0x00000000},
+    {0x0000053C, 0x0300A01C},
+    {0x0000053E, 0x11401140},
+    {0x0000053F, 0x00000000}
 };
 static unsigned nv4TablePRAMIN_8BPP[][2] =
 {
@@ -452,7 +463,8 @@ static unsigned nv4TablePRAMIN_8BPP[][2]
     {0x0000052D, 0x00000302},
     {0x0000052E, 0x00000302},
     {0x00000535, 0x00000000},
-    {0x00000539, 0x00000000} 
+    {0x00000539, 0x00000000},
+    {0x0000053D, 0x00000302}
 };
 static unsigned nv4TablePRAMIN_15BPP[][2] =
 {
@@ -467,7 +479,8 @@ static unsigned nv4TablePRAMIN_15BPP[][2
     {0x0000052D, 0x00000902},
     {0x0000052E, 0x00000902},
     {0x00000535, 0x00000702},
-    {0x00000539, 0x00000702} 
+    {0x00000539, 0x00000702},
+    {0x0000053D, 0x00000902}
 };
 static unsigned nv4TablePRAMIN_16BPP[][2] =
 {
@@ -482,7 +495,8 @@ static unsigned nv4TablePRAMIN_16BPP[][2
     {0x0000052D, 0x00000C02},
     {0x0000052E, 0x00000C02},
     {0x00000535, 0x00000702},
-    {0x00000539, 0x00000702} 
+    {0x00000539, 0x00000702},
+    {0x0000053D, 0x00000C02}
 };
 static unsigned nv4TablePRAMIN_32BPP[][2] =
 {
@@ -497,7 +511,8 @@ static unsigned nv4TablePRAMIN_32BPP[][2
     {0x0000052D, 0x00000E02},
     {0x0000052E, 0x00000E02},
     {0x00000535, 0x00000E02},
-    {0x00000539, 0x00000E02} 
+    {0x00000539, 0x00000E02},
+    {0x0000053D, 0x00000E02}
 };
 static unsigned nv10TableFIFO[][2] =
 {
@@ -810,6 +825,8 @@ static unsigned nv10TablePRAMIN[][2] =
     {0x00000009, 0x80011149},
     {0x0000000A, 0x80000015},
     {0x0000000B, 0x8001114A},
+    {0x0000000C, 0x80000016},
+    {0x0000000D, 0x80011150},
     {0x00000020, 0x80000000},
     {0x00000021, 0x80011142},
     {0x00000022, 0x80000001},
@@ -830,29 +847,45 @@ static unsigned nv10TablePRAMIN[][2] =
     {0x00000501, 0x01FFFFFF},
     {0x00000502, 0x00000002},
     {0x00000503, 0x00000002},
-    {0x00000508, 0x01008043},
+#if X_BYTE_ORDER == X_BIG_ENDIAN
+    {0x00000508, 0x01088043}, 
+#else
+    {0x00000508, 0x01008043}, 
+#endif
     {0x0000050A, 0x00000000},
     {0x0000050B, 0x00000000},
+#if X_BYTE_ORDER == X_BIG_ENDIAN
+    {0x0000050C, 0x01088019},
+#else
     {0x0000050C, 0x01008019},
+#endif
     {0x0000050E, 0x00000000},
     {0x0000050F, 0x00000000},
-#if 1
-    {0x00000510, 0x01008018},
+#if X_BYTE_ORDER == X_BIG_ENDIAN
+    {0x00000510, 0x01088018},
 #else
-    {0x00000510, 0x01008044},
+    {0x00000510, 0x01008018},
 #endif
     {0x00000512, 0x00000000},
     {0x00000513, 0x00000000},
+#if X_BYTE_ORDER == X_BIG_ENDIAN
+    {0x00000514, 0x01088021},
+#else
     {0x00000514, 0x01008021},
+#endif
     {0x00000516, 0x00000000},
     {0x00000517, 0x00000000},
+#if X_BYTE_ORDER == X_BIG_ENDIAN
+    {0x00000518, 0x0108805F},
+#else
     {0x00000518, 0x0100805F},
+#endif
     {0x0000051A, 0x00000000},
     {0x0000051B, 0x00000000},
-#if 1
-    {0x0000051C, 0x0100804B},
+#if X_BYTE_ORDER == X_BIG_ENDIAN
+    {0x0000051C, 0x0108804B},
 #else
-    {0x0000051C, 0x0100804A},
+    {0x0000051C, 0x0100804B},
 #endif
     {0x0000051E, 0x00000000},
     {0x0000051F, 0x00000000},
@@ -868,10 +901,18 @@ static unsigned nv10TablePRAMIN[][2] =
     {0x00000529, 0x00000D01},
     {0x0000052A, 0x11401140},
     {0x0000052B, 0x00000000},
+#if X_BYTE_ORDER == X_BIG_ENDIAN
+    {0x0000052C, 0x00080058},
+#else
     {0x0000052C, 0x00000058},
+#endif
     {0x0000052E, 0x11401140},
     {0x0000052F, 0x00000000},
+#if X_BYTE_ORDER == X_BIG_ENDIAN
+    {0x00000530, 0x00080059},
+#else
     {0x00000530, 0x00000059},
+#endif
     {0x00000532, 0x11401140},
     {0x00000533, 0x00000000},
     {0x00000534, 0x0000005A},
@@ -882,7 +923,14 @@ static unsigned nv10TablePRAMIN[][2] =
     {0x0000053B, 0x00000000},
     {0x0000053C, 0x00000093},
     {0x0000053E, 0x11401140},
-    {0x0000053F, 0x00000000} 
+    {0x0000053F, 0x00000000},
+#if X_BYTE_ORDER == X_BIG_ENDIAN
+    {0x00000540, 0x0308A01C},
+#else
+    {0x00000540, 0x0300A01C},
+#endif
+    {0x00000542, 0x11401140},
+    {0x00000543, 0x00000000}
 };
 static unsigned nv10TablePRAMIN_8BPP[][2] =
 {
@@ -898,7 +946,8 @@ static unsigned nv10TablePRAMIN_8BPP[][2
     {0x0000052E, 0x00000302},
     {0x00000535, 0x00000000},
     {0x00000539, 0x00000000},
-    {0x0000053D, 0x00000000} 
+    {0x0000053D, 0x00000000},
+    {0x00000541, 0x00000302}
 };
 static unsigned nv10TablePRAMIN_15BPP[][2] =
 {
@@ -914,7 +963,8 @@ static unsigned nv10TablePRAMIN_15BPP[][
     {0x0000052E, 0x00000902},
     {0x00000535, 0x00000902},
     {0x00000539, 0x00000902}, 
-    {0x0000053D, 0x00000902} 
+    {0x0000053D, 0x00000902},
+    {0x00000541, 0x00000902}
 };
 static unsigned nv10TablePRAMIN_16BPP[][2] =
 {
@@ -930,7 +980,8 @@ static unsigned nv10TablePRAMIN_16BPP[][
     {0x0000052E, 0x00000C02},
     {0x00000535, 0x00000C02},
     {0x00000539, 0x00000C02},
-    {0x0000053D, 0x00000C02} 
+    {0x0000053D, 0x00000C02},
+    {0x00000541, 0x00000C02}
 };
 static unsigned nv10TablePRAMIN_32BPP[][2] =
 {
@@ -946,6 +997,7 @@ static unsigned nv10TablePRAMIN_32BPP[][
     {0x0000052E, 0x00000E02},
     {0x00000535, 0x00000E02},
     {0x00000539, 0x00000E02},
-    {0x0000053D, 0x00000E02} 
+    {0x0000053D, 0x00000E02},
+    {0x00000541, 0x00000E02}
 };
 
diff -urp linux/drivers/video/vesafb.c new_kernel_src/drivers/video/vesafb.c
--- linux/drivers/video/vesafb.c	2001-11-14 22:52:20.000000000 +0000
+++ new_kernel_src/drivers/video/vesafb.c	2002-02-18 02:20:42.000000000 +0000
@@ -162,7 +162,8 @@ static int vesafb_get_fix(struct fb_fix_
 static int vesafb_get_var(struct fb_var_screeninfo *var, int con,
 			 struct fb_info *info)
 {
-	if(con==-1)
+	if(con==-1 || 1) // For amithlon, we want to read back the
+		// previously saved value at all times.
 		memcpy(var, &vesafb_defined, sizeof(struct fb_var_screeninfo));
 	else
 		*var=fb_display[con].var;
@@ -242,6 +243,11 @@ static int vesafb_set_var(struct fb_var_
 {
 	static int first = 1;
 
+	if (var->nonstd==19690901) {
+		vesafb_defined=*var;
+		return 0;
+	}
+     
 	if (var->xres           != vesafb_defined.xres           ||
 	    var->yres           != vesafb_defined.yres           ||
 	    var->xres_virtual   != vesafb_defined.xres_virtual   ||
@@ -250,8 +256,8 @@ static int vesafb_set_var(struct fb_var_
 	    var->xoffset                                         ||
 	    var->bits_per_pixel != vesafb_defined.bits_per_pixel ||
 	    var->nonstd) {
-		if (first) {
-			printk(KERN_ERR "Vesafb does not support changing the video mode\n");
+		if (first || 1) {
+			printk(KERN_ERR "Vesafb does not support changing the video mode (%d,%d)\n",var->nonstd,var->xres);
 			first = 0;
 		}
 		return -EINVAL;
@@ -519,13 +525,12 @@ int __init vesafb_init(void)
 	video_visual = (video_bpp == 8) ?
 		FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;
 
-	if (!request_mem_region(video_base, video_size, "vesafb")) {
-		printk(KERN_WARNING
-		       "vesafb: abort, cannot reserve video memory at 0x%lx\n",
-			video_base);
-		/* We cannot make this fatal. Sometimes this comes from magic
-		   spaces our resource handlers simply don't know about */
-	}
+  	if (!request_mem_region(video_base, video_size, "vesafb")) {
+ 		printk(KERN_ERR
+  		       "vesafb: abort, cannot reserve video memory at 0x%lx\n",
+  			video_base);
+ 		return -EBUSY;
+  	}
 
         video_vbase = ioremap(video_base, video_size);
 	if (!video_vbase) {
diff -urp linux/fs/inode.c new_kernel_src/fs/inode.c
--- linux/fs/inode.c	2001-12-21 17:41:55.000000000 +0000
+++ new_kernel_src/fs/inode.c	2002-02-08 08:32:14.000000000 +0000
@@ -126,41 +126,41 @@ static void init_once(void * foo, kmem_c
  * you start marking them dirty..
  */
  
-/**
- *	__mark_inode_dirty -	internal function
- *	@inode: inode to mark
- *	@flags: what kind of dirty (i.e. I_DIRTY_SYNC)
- *	Mark an inode as dirty. Callers should use mark_inode_dirty or
- *  	mark_inode_dirty_sync.
- */
- 
+  /**
+   *	__mark_inode_dirty -	internal function
+   *	@inode: inode to mark
+   *	@flags: what kind of dirty (i.e. I_DIRTY_SYNC)
+   *	Mark an inode as dirty. Callers should use mark_inode_dirty or
+   *  	mark_inode_dirty_sync.
+   */
+   
 void __mark_inode_dirty(struct inode *inode, int flags)
 {
-	struct super_block * sb = inode->i_sb;
-
-	if (!sb)
-		return;
-
-	/* Don't do this for I_DIRTY_PAGES - that doesn't actually dirty the inode itself */
-	if (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC)) {
-		if (sb->s_op && sb->s_op->dirty_inode)
-			sb->s_op->dirty_inode(inode);
-	}
-
-	/* avoid the locking if we can */
-	if ((inode->i_state & flags) == flags)
-		return;
-
-	spin_lock(&inode_lock);
-	if ((inode->i_state & flags) != flags) {
-		inode->i_state |= flags;
-		/* Only add valid (ie hashed) inodes to the dirty list */
-		if (!(inode->i_state & I_LOCK) && !list_empty(&inode->i_hash)) {
-			list_del(&inode->i_list);
-			list_add(&inode->i_list, &sb->s_dirty);
-		}
-	}
-	spin_unlock(&inode_lock);
+  struct super_block * sb = inode->i_sb;
+  
+  if (!sb)
+    return;
+  
+  /* Don't do this for I_DIRTY_PAGES - that doesn't actually dirty the inode itself */
+  if (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC)) {
+    if (sb->s_op && sb->s_op->dirty_inode)
+      sb->s_op->dirty_inode(inode);
+  }
+  
+  /* avoid the locking if we can */
+  if ((inode->i_state & flags) == flags)
+    return;
+  
+  spin_lock(&inode_lock);
+  if ((inode->i_state & flags) != flags) {
+    inode->i_state |= flags;
+    /* Only add valid (ie hashed) inodes to the dirty list */
+    if (!list_empty(&inode->i_hash)) {
+      list_del(&inode->i_list);
+      list_add(&inode->i_list, &sb->s_dirty);
+    }
+  }
+  spin_unlock(&inode_lock);
 }
 
 static void __wait_on_inode(struct inode * inode)
diff -urp linux/fs/proc/kmsg.c new_kernel_src/fs/proc/kmsg.c
--- linux/fs/proc/kmsg.c	2001-09-17 05:22:40.000000000 +0100
+++ new_kernel_src/fs/proc/kmsg.c	2001-10-13 21:12:47.000000000 +0100
@@ -32,7 +32,10 @@ static int kmsg_release(struct inode * i
 static ssize_t kmsg_read(struct file * file, char * buf,
 			 size_t count, loff_t *ppos)
 {
-	return do_syslog(2,buf,count);
+        if (file->f_flags & O_NONBLOCK) 
+	      return do_syslog(102,buf,count);
+	else
+	      return do_syslog(2,buf,count);
 }
 
 static unsigned int kmsg_poll(struct file *file, poll_table * wait)
diff -urp linux/fs/proc/proc_misc.c new_kernel_src/fs/proc/proc_misc.c
--- linux/fs/proc/proc_misc.c	2009-06-10 21:00:37.000000000 +0100
+++ new_kernel_src/fs/proc/proc_misc.c	2002-03-25 03:10:33.000000000 +0000
@@ -61,6 +61,7 @@ extern int get_filesystem_list(char *);
 extern int get_exec_domain_list(char *);
 extern int get_irq_list(char *);
 extern int get_dma_list(char *);
+extern int get_mkbd_status (char *);
 extern int get_locks_status (char *, char **, off_t, int);
 extern int get_swaparea_info (char *);
 #ifdef CONFIG_SGI_DS1286
@@ -389,6 +390,21 @@ static int cmdline_read_proc(char *page,
 	return proc_calc_metrics(page, start, off, count, eof, len);
 }
 
+
+#ifdef CONFIG_MKBD
+static int mkbd_read_proc(char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+	int len = get_mkbd_status(page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+	return len;
+}
+#endif
+
 #ifdef CONFIG_SGI_DS1286
 static int ds1286_read_proc(char *page, char **start, off_t off,
 				 int count, int *eof, void *data)
@@ -545,6 +561,9 @@ void __init proc_misc_init(void)
 		{"dma",		dma_read_proc},
 		{"ioports",	ioports_read_proc},
 		{"cmdline",	cmdline_read_proc},
+#ifdef CONFIG_MKBD
+		{"mkbd",	mkbd_read_proc},
+#endif
 #ifdef CONFIG_SGI_DS1286
 		{"rtc",		ds1286_read_proc},
 #endif
diff -urp linux/fs/reiserfs/Makefile new_kernel_src/fs/reiserfs/Makefile
--- linux/fs/reiserfs/Makefile	2002-02-25 19:38:09.000000000 +0000
+++ new_kernel_src/fs/reiserfs/Makefile	2002-02-08 09:17:39.000000000 +0000
@@ -8,18 +8,18 @@
 # Note 2! The CFLAGS definitions are now in the main makefile...
 
 O_TARGET := reiserfs.o
-obj-y   := bitmap.o do_balan.o namei.o inode.o file.o dir.o fix_node.o super.o prints.o objectid.o \
-lbalance.o ibalance.o stree.o hashes.o buffer2.o tail_conversion.o journal.o resize.o version.o item_ops.o ioctl.o procfs.o
+O_OBJS   := bitmap.o do_balan.o namei.o inode.o file.o dir.o fix_node.o super.o prints.o objectid.o \
+lbalance.o ibalance.o stree.o hashes.o buffer2.o tail_conversion.o journal.o resize.o tail_conversion.o version.o item_ops.o
 
-obj-m   := $(O_TARGET)
+M_OBJS   := $(O_TARGET)
 
-# gcc -O2 (the kernel default)  is overaggressive on ppc32 when many inline
+# gcc -O2 (the kernel default)  is overaggressive on ppc when many inline
 # functions are used.  This causes the compiler to advance the stack
 # pointer out of the available stack space, corrupting kernel space,
-# and causing a panic. Since this behavior only affects ppc32, this ifeq
+# and causing a panic. Since this behavior only affects ppc, this ifeq
 # will work around it. If any other architecture displays this behavior,
 # add it here.
-ifeq ($(CONFIG_PPC32),y)
+ifeq ($(shell uname -m),ppc) 
 EXTRA_CFLAGS := -O1
 endif
 
diff -urp linux/fs/reiserfs/README new_kernel_src/fs/reiserfs/README
--- linux/fs/reiserfs/README	2001-10-12 22:19:28.000000000 +0100
+++ new_kernel_src/fs/reiserfs/README	2002-02-08 08:24:04.000000000 +0000
@@ -1,71 +1,58 @@
-[LICENSING] 
-
-ReiserFS is hereby licensed under the GNU General
-Public License version 2.
-
-Source code files that contain the phrase "licensing governed by
-reiserfs/README" are "governed files" throughout this file.  Governed
-files are licensed under the GPL.  The portions of them owned by Hans
-Reiser, or authorized to be licensed by him, have been in the past,
-and likely will be in the future, licensed to other parties under
-other licenses.  If you add your code to governed files, and don't
-want it to be owned by Hans Reiser, put your copyright label on that
-code so the poor blight and his customers can keep things straight.
-All portions of governed files not labeled otherwise are owned by Hans
-Reiser, and by adding your code to it, widely distributing it to
-others or sending us a patch, and leaving the sentence in stating that
-licensing is governed by the statement in this file, you accept this.
-It will be a kindness if you identify whether Hans Reiser is allowed
-to license code labeled as owned by you on your behalf other than
-under the GPL, because he wants to know if it is okay to do so and put
-a check in the mail to you (for non-trivial improvements) when he
-makes his next sale.  He makes no guarantees as to the amount if any,
-though he feels motivated to motivate contributors, and you can surely
-discuss this with him before or after contributing.  You have the
-right to decline to allow him to license your code contribution other
-than under the GPL.
-
-Further licensing options are available for commercial and/or other
-interests directly from Hans Reiser: hans@reiser.to.  If you interpret
-the GPL as not allowing those additional licensing options, you read
-it wrongly, and Richard Stallman agrees with me, when carefully read
-you can see that those restrictions on additional terms do not apply
-to the owner of the copyright, and my interpretation of this shall
-govern for this license.  
-
-Finally, nothing in this license shall be interpreted to allow you to
-fail to fairly credit me, or to remove my credits, without my
-permission, unless you are an end user not redistributing to others.
-If you have doubts about how to properly do that, or about what is
-fair, ask.  (Last I spoke with him Richard was contemplating how best
-to address the fair crediting issue in the next GPL version.)
-
-[END LICENSING]
-
-Reiserfs is a file system based on balanced tree algorithms, which is
-described at http://devlinux.com/namesys.
+Reiserfs is a file system based on balanced tree algorithms, which is described at http://devlinux.com/namesys.
 
 Stop reading here.  Go there, then return.
 
-Send bug reports to yura@namesys.botik.ru.
+Send bug reports to reiser@idiom.com, or vs@namesys.botik.ru, or both.
 
 mkreiserfs and other utilities are in reiserfs/utils, or wherever your
-Linux provider put them.  There is some disagreement about how useful
-it is for users to get their fsck and mkreiserfs out of sync with the
-version of reiserfs that is in their kernel, with many important
-distributors wanting them out of sync.:-) Please try to remember to
-recompile and reinstall fsck and mkreiserfs with every update of
-reiserfs, this is a common source of confusion.  Note that some of the
-utilities cannot be compiled without accessing the balancing code
-which is in the kernel code, and relocating the utilities may require
-you to specify where that code can be found.
-
-Yes, if you update your reiserfs kernel module you do have to
-recompile your kernel, most of the time.  The errors you get will be
-quite cryptic if your forget to do so.
+Linux provider put them.  Note that some of the utilities cannot be
+compiled without accessing to the balancing code which is in the kernel
+code, and relocating the utilities may require you to specify where that
+code can be found.
+
+Try turning REISERFS_CHECK in reiserfs_fs.h on or off if you want error
+checking or speed, respectively.  Real users, as opposed to folks who
+want to hack, will want it off.
+
+[LICENSE] ReiserFS is hereby licensed under the GNU General
+Public License version 2.  Please see the file "COPYING"
+which should have accompanied this software distribution for
+details of that license.
+
+Since that license (particularly 2.b) is necessarily vague in certain
+areas due to its generality, the following interpretations shall govern.
+Some may consider these terms to be a supplemental license to the GPL.
+You may include ReiserFS in a Linux kernel which you may then include
+with anything, and you may even include it with a Linux kernel with
+non-GPL'd kernel modules.  You may include it in any kernel which is
+wholly GPL'd including its kernel modules which you may then include
+with anything.  If you wish to use it for a kernel which you sell usage
+or copying licenses for, which is not listed above, then you must obtain
+an additional license.  If you wish to integrate it with any other
+software system which is not GPL'd, without integrating it into an
+operating system kernel, then you must obtain an additional license.
+This is an interpretation of what is and is not part of the software
+program falling under the GPL section 2.b., and is intended as a
+specification of (with a slight supplement to), not an exception to, the
+GPL as applied to this particular piece of software.
 
-Real users, as opposed to folks who want to hack and then understand
-what went wrong, will want REISERFS_CHECK off.
+Further licensing options are available for commercial and/or other
+interests directly from Hans Reiser:  reiser@idiom.com.  If you
+interpret the GPL as not allowing those additional licensing options,
+you read it wrongly, when carefully read you can see that those
+restrictions on additional terms do not apply to the owner of the
+copyright, and my interpretation of this shall govern for this license.
+
+[END LICENSE]
+
+I try to find ways to make money for those who contribute to this code.
+My success in such efforts cannot be guaranteed though:-).  You are
+encouraged to add to it.  If you ask me to include it in my standard
+distribution, and you don't request an exception to this (if you want
+the exception, talk to me about it, don't be shy), you give ownership of
+the copyright to me, and you consent to my marketing exceptions to the
+GPL.  If you want to market it as part of a system you sell, please
+contact me.  
 
 Hideous Commercial Pitch: Spread your development costs across other OS
 vendors.  Select from the best in the world, not the best in your
@@ -76,7 +63,7 @@ decentralized internet development, and 
 integration that you sell as an operating system.  Let your competitors
 be the ones to compete against the entire internet by themselves.  Be
 hip, get with the new economic trend, before your competitors do.  Send
-email to hans@reiser.to.
+email to reiser@idiom.com.
 
 To understand the code, after reading the website, start reading the
 code by reading reiserfs_fs.h first.
@@ -91,8 +78,9 @@ could be, and to make his code the best 
 was quite remarkable. I don't think that money can ever motivate someone
 to work the way he did, he is one of the most selfless men I know.
 
-Yura helps with benchmarking, coding hashes, and block pre-allocation
-code.
+Yura joined us near the end of our project, and helped with such things
+as integrating hashing back into the code, and benchmarking different
+pieces of code to help with tuning analysis.
 
 Anatoly Pinchuk is a former member of our team who worked closely with
 Vladimir throughout the project's development.  He wrote a quite
@@ -102,22 +90,16 @@ that start on a node aligned boundary (t
 align files), and he invented and implemented indirect items and
 unformatted nodes as the solution.
 
-Konstantin Shvachko, with the help of the Russian version of a VC,
-tried to put me in a position where I was forced into giving control
-of the project to him.  (Fortunately, as the person paying the money
-for all salaries from my dayjob I owned all copyrights, and you can't
-really force takeovers of sole proprietorships.)  This was something
-curious, because he never really understood the value of our project,
-why we should do what we do, or why innovation was possible in
-general, but he was sure that he ought to be controlling it.  Every
-innovation had to be forced past him while he was with us.  He added
-two years to the time required to complete reiserfs, and was a net
-loss for me.  Mikhail Gilula was a brilliant innovator who also left
-in a destructive way that erased the value of his contributions, and
-that he was shown much generosity just makes it more painful.
+Two other former employees were involved who won't be getting credit
+here because they tried to kill the project at the end of it, and almost
+succeeded (they cost me maybe two years).  They wanted to force me to
+sell it to the company they tried to start.  They get to keep the money
+they got from me, and that is it.  When their "VC" said that he could
+get a hundred researchers to swear in Russian Court that I had had
+nothing to do with the development of treefs, I changed the name to
+reiserfs and registered the copyright.
 
-Grigory Zaigralin was an extremely effective system administrator for
-our group.
+Grigory Zaigralin was an extremely effective system administrator for our group.
 
 Igor Krasheninnikov was wonderful at hardware procurement, repair, and
 network installation.
@@ -135,27 +117,8 @@ He is just an amazing programmer.
 Igor Zagorovsky is writing much of the new item handler and extent code
 for our next major release.
 
-Alexander Zarochentcev (sometimes known as zam, or sasha), wrote the
-resizer, and is hard at work on implementing allocate on flush.  SGI
-implemented allocate on flush before us for XFS, and generously took
-the time to convince me we should do it also.  They are great people,
-and a great company.
-
-Yuri Shevchuk and Nikita Danilov are doing squid cache optimization.
-
-Vitaly Fertman is doing fsck.
-
-Jeff Mahoney, of SuSE, contributed a few cleanup fixes, most notably
-the endian safe patches which allow ReiserFS to run on any platform
-supported by the Linux kernel.
-
-SuSE, IntegratedLinux.com, Ecila, MP3.com, bigstorage.com, and the
-Alpha PC Company made it possible for me to not have a day job
-anymore, and to dramatically increase our staffing.  Ecila funded
-hypertext feature development, MP3.com funded journaling, SuSE funded
-core development, IntegratedLinux.com funded squid web cache
-appliances, bigstorage.com funded HSM, and the alpha PC company funded
-the alpha port.  Many of these tasks were helped by sponsors other
-than the ones just named.  SuSE has helped in much more than just
+Ecila, MP3, and SuSE (in chronological order) made it possible for me to
+not have a day job anymore, and to dramatically increase our staffing.
+Ecila funded hypertext feature development, MP3 funded journaling, and
+SuSE funded core development.  SuSE has helped in much more than just
 funding....
-
diff -urp linux/fs/reiserfs/bitmap.c new_kernel_src/fs/reiserfs/bitmap.c
--- linux/fs/reiserfs/bitmap.c	2009-06-10 21:00:37.000000000 +0100
+++ new_kernel_src/fs/reiserfs/bitmap.c	2002-03-25 03:10:33.000000000 +0000
@@ -1,8 +1,13 @@
 /*
- * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README
+ * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
  */
+//
+// Ext2's preallocation idea was used for current reiserfs preallocation
+// preallocation
+//
+
+#ifdef __KERNEL__
 
-#include <linux/config.h>
 #include <linux/sched.h>
 #include <linux/reiserfs_fs.h>
 #include <linux/locks.h>
@@ -12,7 +17,7 @@
 #ifdef CONFIG_REISERFS_CHECK
 
 /* this is a safety check to make sure
-** blocks are reused properly.  used for debugging only.
+** blocks are reused properly.
 **
 ** this checks, that block can be reused, and it has correct state
 **   (free or busy) 
@@ -82,9 +87,7 @@ static inline void get_bit_address (stru
 
 /* There would be a modest performance benefit if we write a version
    to free a list of blocks at once. -Hans */
-				/* I wonder if it would be less modest
-                                   now that we use journaling. -Hans */
-static void _reiserfs_free_block (struct reiserfs_transaction_handle *th, unsigned long block)
+void reiserfs_free_block (struct reiserfs_transaction_handle *th, unsigned long block)
 {
     struct super_block * s = th->t_super;
     struct reiserfs_super_block * rs;
@@ -248,7 +251,7 @@ retry:
       search_start = 0; /* caller will reset search_start for itself also. */
       get_bit_address (s, search_start, bmap_nr, offset);
       if (find_forward (s, bmap_nr,offset,for_unformatted) == 0) {
-	if (for_unformatted) {	/* why only unformatted nodes? -Hans */
+	if (for_unformatted) {
 	  if (retry_count == 0) {
 	    /* we've got a chance that flushing async commits will free up
 	    ** some space.  Sync then retry
@@ -298,8 +301,6 @@ retry:
    spare space is used only when priority is set to 1. reiserfsck has
    its own reiserfs_new_blocknrs, which can use reserved space
 
-   exactly what reserved space?  the SPARE_SPACE?  if so, please comment reiserfs.h.
-
    Give example of who uses spare space, and say that it is a deadlock
    avoidance mechanism.  -Hans */
 
@@ -400,8 +401,8 @@ free_and_return:
       goto free_and_return ;
     }
     search_start = new_block ;
-    if (search_start >= reiserfs_get_journal_block(s) &&
-        search_start < (reiserfs_get_journal_block(s) + JOURNAL_BLOCK_COUNT)) {
+    if (search_start >= SB_JOURNAL_BLOCK(s) &&
+        search_start < (SB_JOURNAL_BLOCK(s) + JOURNAL_BLOCK_COUNT)) {
 	reiserfs_warning("vs-4130: reiserfs_new_blocknrs: trying to allocate log block %lu\n",
 			 search_start) ;
 	search_start++ ;
@@ -431,130 +432,94 @@ free_and_return:
 
   reiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1) ;
   /* update free block count in super block */
-  PUT_SB_FREE_BLOCKS( s, SB_FREE_BLOCKS(s) - init_amount_needed );
+  s->u.reiserfs_sb.s_rs->s_free_blocks = cpu_to_le32 (SB_FREE_BLOCKS (s) - init_amount_needed);
   journal_mark_dirty (th, s, SB_BUFFER_WITH_SB (s));
   s->s_dirt = 1;
 
   return CARRY_ON;
 }
 
-// this is called only by get_empty_nodes
+// this is called only by get_empty_nodes with for_preserve_list==0
 int reiserfs_new_blocknrs (struct reiserfs_transaction_handle *th, unsigned long * free_blocknrs,
 			    unsigned long search_start, int amount_needed) {
-  return do_reiserfs_new_blocknrs(th, free_blocknrs, search_start, amount_needed, 0/*priority*/, 0/*for_formatted*/, 0/*for_prealloc */) ;
+  return do_reiserfs_new_blocknrs(th, free_blocknrs, search_start, amount_needed, 0/*for_preserve_list-priority*/, 0/*for_formatted*/, 0/*for_prealloc */) ;
 }
 
 
-// called by get_new_buffer and by reiserfs_get_block with amount_needed == 1
+// called by get_new_buffer and by reiserfs_get_block with amount_needed == 1 and for_preserve_list == 0
 int reiserfs_new_unf_blocknrs(struct reiserfs_transaction_handle *th, unsigned long * free_blocknrs,
 			      unsigned long search_start) {
+#if 0
+#ifdef REISERFS_PREALLOCATE
+  unsigned long border = (SB_BLOCK_COUNT(th->t_super) / 10); 
+  if ( search_start < border ) search_start=border;
+#endif
+#endif
+
   return do_reiserfs_new_blocknrs(th, free_blocknrs, search_start, 
                                   1/*amount_needed*/,
-				  0/*priority*/, 
+				  0/*for_preserve_list-priority*/, 
 				  1/*for formatted*/,
 				  0/*for prealloc */) ;
 }
 
 #ifdef REISERFS_PREALLOCATE
+				/* So do I understand correctly that
+                                   in this code we snag the largest
+                                   contiguous extent we can that is
+                                   not more than 128 blocks, and which
+                                   is at least 2 blocks? -Hans */
+
 
 /* 
-** We pre-allocate 8 blocks.  Pre-allocation is used for files > 16 KB only.
-** This lowers fragmentation on large files by grabbing a contiguous set of
-** blocks at once.  It also limits the number of times the bitmap block is
-** logged by making X number of allocation changes in a single transaction.
-**
-** We are using a border to divide the disk into two parts.  The first part
-** is used for tree blocks, which have a very high turnover rate (they
-** are constantly allocated then freed)
-**
-** The second part of the disk is for the unformatted nodes of larger files.
-** Putting them away from the tree blocks lowers fragmentation, and makes
-** it easier to group files together.  There are a number of different
-** allocation schemes being tried right now, each is documented below.
-**
-** A great deal of the allocator's speed comes because reiserfs_get_block
-** sends us the block number of the last unformatted node in the file.  Once
-** a given block is allocated past the border, we don't collide with the
-** blocks near the search_start again.
-** 
+   The function pre-allocate 8 blocks. We can change this later. 
+   Pre-allocation is used for files > 16 KB only.
 */
+				/* how about taking the time to explain preallocation here? -Hans */
 int reiserfs_new_unf_blocknrs2 (struct reiserfs_transaction_handle *th, 
 				struct inode       * p_s_inode,
 				unsigned long      * free_blocknrs,
 				unsigned long        search_start)
 {
-  int ret=0, blks_gotten=0;
-  unsigned long border = 0;
-  unsigned long bstart = 0;
-  unsigned long hash_in, hash_out;
-  unsigned long saved_search_start=search_start;
-  int allocated[PREALLOCATION_SIZE];
-  int blks;
-
-  if (!reiserfs_no_border(th->t_super)) {
-    /* we default to having the border at the 10% mark of the disk.  This
-    ** is an arbitrary decision and it needs tuning.  It also needs a limit
-    ** to prevent it from taking too much space on huge drives.
-    */
-    bstart = (SB_BLOCK_COUNT(th->t_super) / 10); 
-  }
-  if (!reiserfs_no_unhashed_relocation(th->t_super)) {
-    /* this is a very simple first attempt at preventing too much grouping
-    ** around the border value.  Since k_dir_id is never larger than the
-    ** highest allocated oid, it is far from perfect, and files will tend
-    ** to be grouped towards the start of the border
-    */
-    border = le32_to_cpu(INODE_PKEY(p_s_inode)->k_dir_id) % (SB_BLOCK_COUNT(th->t_super) - bstart - 1) ;
-  } else if (!reiserfs_hashed_relocation(th->t_super)) {
-      hash_in = le32_to_cpu((INODE_PKEY(p_s_inode))->k_dir_id);
-				/* I wonder if the CPU cost of the
-                                   hash will obscure the layout
-                                   effect? Of course, whether that
-                                   effect is good or bad we don't
-                                   know.... :-) */
-      
-      hash_out = keyed_hash(((char *) (&hash_in)), 4);
-      border = hash_out % (SB_BLOCK_COUNT(th->t_super) - bstart - 1) ;
-  }
+  int i, n, ret=0;
+  int allocated[8], blks;
+				/* Comments are okay with me to use. -Hans */
+
+				/* so why have we made this one / 10 */
+  unsigned long bstart = (SB_BLOCK_COUNT(th->t_super) / 10); 
+				/* and this one hashed? */
+				/* how about we have a policy of explaining the rationale behind the algorithms for all of our code? */
+				/* please perform benchmarking of
+                                   hashing by objectid instead of
+                                   k_dir_id, just to confirm that it
+                                   is helpful not harmful to put
+                                   related large files all together.
+                                   It might be harmful, I can argue it
+                                   both ways, we don't know until we
+                                   test. -Hans. */
+  unsigned long border = (INODE_PKEY(p_s_inode)->k_dir_id) % 
+                         (SB_BLOCK_COUNT(th->t_super) - bstart - 1) ;
   border += bstart ;
-  allocated[0] = 0 ; /* important.  Allows a check later on to see if at
-                      * least one block was allocated.  This prevents false
-		      * no disk space returns
+
+  allocated[0] = 0 ; /* important.  catches a good allocation when 
+                      * first prealloc works, and later one fails
 		      */
 
+				/* It would be interesting to instead
+                                   try putting all unformatted nodes
+                                   after the first 1/3 of the disk and
+                                   benchmark, as it would put
+                                   formatted nodes closer to the log on
+                                   single disk drive machines. */
   if ( (p_s_inode->i_size < 4 * 4096) || 
        !(S_ISREG(p_s_inode->i_mode)) )
     {
-      if ( search_start < border 
-	   || (
-				/* allow us to test whether it is a
-                                   good idea to prevent files from
-                                   getting too far away from their
-                                   packing locality by some unexpected
-                                   means.  This might be poor code for
-                                   directories whose files total
-                                   larger than 1/10th of the disk, and
-                                   it might be good code for
-                                   suffering from old insertions when the disk
-                                   was almost full. */
-               /* changed from !reiserfs_test3(th->t_super), which doesn't
-               ** seem like a good idea.  Think about adding blocks to
-               ** a large file.  If you've allocated 10% of the disk
-               ** in contiguous blocks, you start over at the border value
-               ** for every new allocation.  This throws away all the
-               ** information sent in about the last block that was allocated
-               ** in the file.  Not a good general case at all.
-               ** -chris
-               */
-	       reiserfs_test4(th->t_super) && 
-	       (search_start > border + (SB_BLOCK_COUNT(th->t_super) / 10))
-	       )
-	   )
-	search_start=border;
+      if ( search_start < border ) search_start=border;
   
       ret = do_reiserfs_new_blocknrs(th, free_blocknrs, search_start, 
 				     1/*amount_needed*/, 
-				     0/*use reserved blocks for root */,
+				/* someone please remove the preserve list detritus. -Hans */
+				     0/*for_preserve_list-priority*/, 
 				     1/*for_formatted*/,
 				     0/*for prealloc */) ;  
       return ret;
@@ -573,11 +538,9 @@ int reiserfs_new_unf_blocknrs2 (struct r
     return ret;
   }
 
-				/* else get a new preallocation for the file */
+				/* else  get a new preallocation for the file */
   reiserfs_discard_prealloc (th, p_s_inode);
-  /* this uses the last preallocated block as the search_start.  discard
-  ** prealloc does not zero out this number.
-  */
+				/* This does what? -Hans */
   if (search_start <= p_s_inode->u.reiserfs_i.i_prealloc_block) {
     search_start = p_s_inode->u.reiserfs_i.i_prealloc_block;
   }
@@ -597,31 +560,33 @@ int reiserfs_new_unf_blocknrs2 (struct r
   }
 
   *free_blocknrs = 0;
-  blks = PREALLOCATION_SIZE-1;
-  for (blks_gotten=0; blks_gotten<PREALLOCATION_SIZE; blks_gotten++) {
+				/* Don't use numbers like n, use numbers like PREALLOCATION_SIZE, and put them in the reiserfs_fs.h file. -Hans */
+  n = 8;
+  blks = n-1;
+  for (i=0; i<n; i++) {
     ret = do_reiserfs_new_blocknrs(th, free_blocknrs, search_start, 
 				   1/*amount_needed*/, 
-				   0/*for root reserved*/,
+				   0/*for_preserve_list-priority*/, 
 				   1/*for_formatted*/,
-				   (blks_gotten > 0)/*must_be_contiguous*/) ;
-    /* if we didn't find a block this time, adjust blks to reflect
-    ** the actual number of blocks allocated
-    */ 
+				   (i > 0)/*must_be_contiguous*/) ;
+				/* comment needed -Hans */
     if (ret != CARRY_ON) {
-      blks = blks_gotten > 0 ? (blks_gotten - 1) : 0 ;
+      blks = i > 0 ? (i - 1) : 0 ;
       break ;
     }
-    allocated[blks_gotten]= *free_blocknrs;
+    allocated[i]= *free_blocknrs;
 #ifdef CONFIG_REISERFS_CHECK
-    if ( (blks_gotten>0) && (allocated[blks_gotten] - allocated[blks_gotten-1]) != 1 ) {
+    if ( (i>0) && (allocated[i] - allocated[i-1]) != 1 ) {
+      /* this is not a standard reiserfs_warning message -Hans */
       /* this should be caught by new_blocknrs now, checking code */
-      reiserfs_warning("yura-1, reiserfs_new_unf_blocknrs2: pre-allocated not contiguous set of blocks!\n") ;
-      reiserfs_free_block(th, allocated[blks_gotten]);
-      blks = blks_gotten-1; 
+      /* use your email name of yura, not yr, and I don't believe you have written 4050 error messages.... -Hans */
+      reiserfs_warning("yura-4160, reiserfs_new_unf_blocknrs2: pre-allocated not contiguous set of blocks!\n") ;
+      reiserfs_free_block(th, allocated[i]);
+      blks = i-1; 
       break;
     }
 #endif
-    if (blks_gotten==0) {
+    if (i==0) {
       p_s_inode->u.reiserfs_i.i_prealloc_block = *free_blocknrs;
     }
     search_start = *free_blocknrs; 
@@ -648,64 +613,26 @@ int reiserfs_new_unf_blocknrs2 (struct r
   ** unless it has already successfully allocated at least one block.
   ** Just in case, we translate into a return value the rest of the
   ** filesystem can understand.
-  **
-  ** It is an error to change this without making the
-  ** rest of the filesystem understand NO_MORE_UNUSED_CONTIGUOUS_BLOCKS
-  ** If you consider it a bug to return NO_DISK_SPACE here, fix the rest
-  ** of the fs first.
   */
   if (ret == NO_MORE_UNUSED_CONTIGUOUS_BLOCKS) {
-#ifdef CONFIG_REISERFS_CHECK
-    reiserfs_warning("reiser-2015: this shouldn't happen, may cause false out of disk space error");
-#endif
-     return NO_DISK_SPACE; 
+    return NO_DISK_SPACE ;
   }
   return ret;
 }
 
-//
-// a portion of this function, was derived from minix or ext2's
-// analog. You should be able to tell which portion by looking at the
-// ext2 code and comparing. 
-static void __discard_prealloc (struct reiserfs_transaction_handle * th,
-				struct inode * inode)
-{
-  unsigned long save = inode->u.reiserfs_i.i_prealloc_block ;
-  while (inode->u.reiserfs_i.i_prealloc_count > 0) {
-    reiserfs_free_prealloc_block(th,inode->u.reiserfs_i.i_prealloc_block);
-    inode->u.reiserfs_i.i_prealloc_block++;
-    inode->u.reiserfs_i.i_prealloc_count --;
-  }
-  inode->u.reiserfs_i.i_prealloc_block = save ; 
-  list_del (&(inode->u.reiserfs_i.i_prealloc_list));
-}
-
 
+//
+// this is ext2_discard_prealloc
+//
 void reiserfs_discard_prealloc (struct reiserfs_transaction_handle *th, 
 				struct inode * inode)
 {
-#ifdef CONFIG_REISERFS_CHECK
-  if (inode->u.reiserfs_i.i_prealloc_count < 0)
-     reiserfs_warning("zam-4001:" __FUNCTION__ ": inode has negative prealloc blocks count.\n");
-#endif  
     if (inode->u.reiserfs_i.i_prealloc_count > 0) {
-    __discard_prealloc(th, inode);
-  }
+      while (inode->u.reiserfs_i.i_prealloc_count--) {
+	reiserfs_free_block(th,inode->u.reiserfs_i.i_prealloc_block);
+	inode->u.reiserfs_i.i_prealloc_block++;
       }
-
-void reiserfs_discard_all_prealloc (struct reiserfs_transaction_handle *th)
-{
-  struct list_head * plist = &SB_JOURNAL(th->t_super)->j_prealloc_list;
-  struct inode * inode;
-  
-  while (!list_empty(plist)) {
-    inode = list_entry(plist->next, struct inode, u.reiserfs_i.i_prealloc_list);
-#ifdef CONFIG_REISERFS_CHECK
-    if (!inode->u.reiserfs_i.i_prealloc_count) {
-      reiserfs_warning("zam-4001:" __FUNCTION__ ": inode is in prealloc list but has no preallocated blocks.\n");
-    }
-#endif    
-    __discard_prealloc(th, inode);
     }
+    inode->u.reiserfs_i.i_prealloc_count = 0;
 }
 #endif
diff -urp linux/fs/reiserfs/buffer2.c new_kernel_src/fs/reiserfs/buffer2.c
--- linux/fs/reiserfs/buffer2.c	2001-12-21 17:42:03.000000000 +0000
+++ new_kernel_src/fs/reiserfs/buffer2.c	2002-02-08 08:32:14.000000000 +0000
@@ -1,19 +1,42 @@
 /*
- *  Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README  
+ *  Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
  */
 
-#include <linux/config.h>
+
+/*
+ * Contains code from
+ *
+ *  linux/include/linux/lock.h and linux/fs/buffer.c /linux/fs/minix/fsync.c
+ *
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ */
+#ifdef __KERNEL__
+
 #include <linux/sched.h>
 #include <linux/locks.h>
 #include <linux/reiserfs_fs.h>
 #include <linux/smp_lock.h>
 #include <linux/kernel_stat.h>
 
+#else
+
+#include "nokernel.h"
+
+#endif
+
+
 /*
  *  wait_buffer_until_released
  *  reiserfs_bread
+ *  reiserfs_getblk
+ *  reiserfs_journal_end_io
+ *  reiserfs_end_io_task
+ *  reiserfs_end_buffer_io_sync
+ *  get_new_buffer
  */
 
+
+
 /* when we allocate a new block (get_new_buffer, get_empty_nodes) and
    get buffer for it, it is possible that it is held by someone else
    or even by this process. In this function we wait until all other
@@ -37,10 +60,105 @@ void wait_buffer_until_released (const s
     schedule();
   }
   if (repeat_counter > 30000000) {
-    reiserfs_warning("vs-3051: done waiting, ignore vs-3050 messages for (%b)\n", bh) ;
+    reiserfs_warning("vs-3051: done waiting on buffer (%b)\n", bh) ;
+  }
+}
+
+
+/* no longer need, should just make journal.c use the default handler */
+void reiserfs_journal_end_io (struct buffer_head *bh, int uptodate)
+{
+  mark_buffer_uptodate(bh, uptodate);
+  unlock_buffer(bh);
+  return ;
+}
+
+
+/* struct used to service end_io events.  kmalloc'd in 
+** reiserfs_end_buffer_io_sync 
+*/
+struct reiserfs_end_io {
+  struct buffer_head *bh ; /* buffer head to check */
+  struct tq_struct task ;  /* task struct to use */
+  struct reiserfs_end_io *self ; /* pointer to this struct for kfree to use */
+} ;
+
+/*
+** does the hash list updating required to release a buffer head.
+** must not be called at interrupt time (so I can use the non irq masking 
+** spinlocks).  Right now, put onto the schedule task queue, one for
+** each block that gets written
+*/
+static void reiserfs_end_io_task(struct reiserfs_end_io *io) {
+  struct buffer_head *bh = io->bh ;
+  int windex = push_journal_writer("end_io_task") ;
+
+  if (buffer_journal_dirty(bh)) {
+    struct reiserfs_journal_cnode *cur ;
+    struct super_block * s = get_super (bh->b_dev);
+
+    if (!s) 
+      goto done ;
+
+    if (!buffer_journal_dirty(bh)) { 
+      goto done ;
+    }
+    mark_buffer_notjournal_dirty(bh) ;
+    cur = (journal_hash(SB_JOURNAL(s)->j_list_hash_table, bh->b_dev, bh->b_blocknr)) ;
+    while(cur) {
+      if (cur->bh && cur->blocknr == bh->b_blocknr && cur->dev == bh->b_dev) {
+	if (cur->jlist) { /* since we are clearing the bh, we must decrement nonzerolen */
+	  atomic_dec(&(cur->jlist->j_nonzerolen)) ;
+	}
+	cur->bh = NULL ;
+      }
+      cur = cur->hnext ;
+    }
+    atomic_dec(&(bh->b_count)) ;
+  }
+done:
+  kfree(io->self) ;
+  pop_journal_writer(windex) ;
+  brelse(bh) ;
+  return ;
+}
+
+/*
+** general end_io routine for all reiserfs blocks.
+** logged blocks will come in here marked buffer_journal_dirty()
+** a reiserfs_end_io struct is kmalloc'd for them, and a task is put 
+** on the scheduler queue.  It then does all the required hash table
+** operations to reflect the buffer as writen
+*/
+void reiserfs_end_buffer_io_sync (struct buffer_head *bh, int uptodate)
+{
+
+  mark_buffer_notjournal_new(bh) ;
+  if (buffer_journal_dirty(bh)) {
+    struct reiserfs_end_io *io = kmalloc(sizeof(struct reiserfs_end_io), 
+                                         GFP_ATOMIC) ;
+    /* note, if kmalloc fails, this buffer will be taken care of
+    ** by a check at the end of do_journal_end() in journal.c
+    */
+    if (io) {
+      io->task.next = NULL ;
+      io->task.sync = 0 ;
+      io->task.routine = (void *)(void *)reiserfs_end_io_task ;
+      io->task.data = io ;
+      io->self = io ;
+      io->bh = bh ;
+      atomic_inc(&(bh->b_count)) ;
+      queue_task(&(io->task), &reiserfs_end_io_tq) ;
+    } else {
+      printk("reiserfs/buffer.c-184: kmalloc returned NULL block %lu\n", 
+              bh->b_blocknr) ;
+    }
   }
+  mark_buffer_uptodate(bh, uptodate);
+  unlock_buffer(bh);
 }
 
+
 /*
  * reiserfs_bread() reads a specified block and returns the buffer that contains
  * it. It returns NULL if the block was unreadable.
@@ -49,15 +167,298 @@ void wait_buffer_until_released (const s
    then it creates a new buffer and schedules I/O to read the
    block. */
 /* The function is NOT SCHEDULE-SAFE! */
-struct buffer_head  * reiserfs_bread (struct super_block *super, int n_block, int n_size) 
+
+struct buffer_head  * reiserfs_bread (kdev_t n_dev, int n_block, int n_size) 
+{
+    struct buffer_head * bh;
+
+    bh = bread (n_dev, n_block, n_size);
+    if (bh) {
+        bh->b_end_io = reiserfs_end_buffer_io_sync;
+    }
+    return bh;
+}
+
+
+/* This function looks for a buffer which contains a given block.  If
+   the block is in cache it returns it, otherwise it returns a new
+   buffer which is not uptodate.  This is called by reiserfs_bread and
+   other functions. Note that get_new_buffer ought to be called this
+   and this ought to be called get_new_buffer, since this doesn't
+   actually get the block off of the disk. */
+/* The function is NOT SCHEDULE-SAFE! */
+
+struct buffer_head  * reiserfs_getblk (kdev_t n_dev, int n_block, int n_size)
+{
+    struct buffer_head * bh;
+
+    bh = getblk (n_dev, n_block, n_size);
+    if (bh) {
+      bh->b_end_io = reiserfs_end_buffer_io_sync ;
+    }
+    return bh;
+}
+
+
+
+
+#ifdef NEW_GET_NEW_BUFFER
+
+/* returns one buffer with a blocknr near blocknr. */
+static int get_new_buffer_near_blocknr(
+                   struct super_block *  p_s_sb,
+                   int blocknr,
+                   struct buffer_head ** pp_s_new_bh,
+                   struct path         * p_s_path 
+                   ) {
+  unsigned      long n_new_blocknumber = 0;
+  int           n_ret_value,
+                n_repeat = CARRY_ON;
+
+#ifdef CONFIG_REISERFS_CHECK
+  int repeat_counter = 0;
+  
+  if (!blocknr)
+    printk ("blocknr passed to get_new_buffer_near_blocknr was 0");
+#endif
+
+
+  if ( (n_ret_value = reiserfs_new_blocknrs (p_s_sb, &n_new_blocknumber,
+                                             blocknr, 1)) == NO_DISK_SPACE )
+    return NO_DISK_SPACE;
+  
+  *pp_s_new_bh = reiserfs_getblk(p_s_sb->s_dev, n_new_blocknumber, p_s_sb->s_blocksize);
+  if ( buffer_uptodate(*pp_s_new_bh) ) {
+
+    RFALSE( buffer_dirty(*pp_s_new_bh) || (*pp_s_new_bh)->b_dev == NODEV,
+	    "PAP-14080: invalid uptodate buffer %b for the new block", 
+	    *pp_s_new_bh);
+
+    /* Free path buffers to prevent deadlock. */
+    /* It is possible that this process has the buffer, which this function is getting, already in
+       its path, and is responsible for double incrementing the value of b_count.  If we recalculate
+       the path after schedule we can avoid risking an endless loop.  This problematic situation is
+       possible in a multiple processing environment.  Suppose process 1 has acquired a path P; then
+       process 2 balanced and remove block A from the tree.  Process 1 continues and runs
+       get_new_buffer, that returns buffer with block A. If node A was on the path P, then it will
+       have b_count == 2. If we now will simply wait in while ( (*pp_s_new_bh)->b_count > 1 ) we get
+       into an endless loop, as nobody will release this buffer and the current process holds buffer
+       twice. That is why we do decrement_counters_in_path(p_s_path) before waiting until b_count
+       becomes 1. (it there were other processes holding node A, then eventually we will get a
+       moment, when all of them released a buffer). */
+    if ( atomic_read (&((*pp_s_new_bh)->b_count)) > 1  ) {
+      decrement_counters_in_path(p_s_path);
+      n_ret_value |= SCHEDULE_OCCURRED;
+    }
+
+    while ( atomic_read (&((*pp_s_new_bh)->b_count)) > 1 ) {
+
+#ifdef REISERFS_INFO
+      printk("get_new_buffer() calls schedule to decrement b_count\n");
+#endif
+
+#ifdef CONFIG_REISERFS_CHECK
+      if ( ! (++repeat_counter % 10000) )
+	printk("get_new_buffer(%u): counter(%d) too big", current->pid, repeat_counter);
+#endif
+
+      current->counter = 0;
+      schedule();
+    }
+
+#ifdef CONFIG_REISERFS_CHECK
+    if ( buffer_dirty(*pp_s_new_bh) || (*pp_s_new_bh)->b_dev == NODEV ) {
+      print_buffer_head(*pp_s_new_bh,"get_new_buffer");
+      reiserfs_panic(p_s_sb, "PAP-14090: get_new_buffer: invalid uptodate buffer %b for the new block(case 2)", *pp_s_new_bh);
+    }
+#endif
+
+  }
+  else {
+    ;
+
+    RFALSE( atomic_read (&((*pp_s_new_bh)->b_count)) != 1,
+	    "PAP-14100: not uptodate buffer %b for the new block has b_count more than one",
+	    *pp_s_new_bh);
+
+  }
+  return (n_ret_value | n_repeat);
+}
+
+
+/* returns the block number of the last unformatted node, assumes p_s_key_to_search.k_offset is a byte in the tail of
+   the file, Useful for when you want to append to a file, and convert a direct item into an unformatted node near the
+   last unformatted node of the file.  Putting the unformatted node near the direct item is potentially very bad to do.
+   If there is no unformatted node in the file, then we return the block number of the direct item.  */
+/* The function is NOT SCHEDULE-SAFE! */
+inline int get_last_unformatted_node_blocknr_of_file(  struct key * p_s_key_to_search, struct super_block * p_s_sb,
+                                                       struct buffer_head * p_s_bh
+                                                       struct path * p_unf_search_path, struct inode * p_s_inode)
+
+{
+  struct key unf_key_to_search;
+  struct item_head * p_s_ih;
+  int n_pos_in_item;
+  struct buffer_head * p_indirect_item_bh;
+
+      copy_key(&unf_key_to_search,p_s_key_to_search);
+      unf_key_to_search.k_uniqueness = TYPE_INDIRECT;
+      unf_key_to_search.k_offset = p_s_inode->u.reiserfs_i.i_first_direct_byte - 1;
+
+        /* p_s_key_to_search->k_offset -  MAX_ITEM_LEN(p_s_sb->s_blocksize); */
+      if (search_for_position_by_key (p_s_sb, &unf_key_to_search, p_unf_search_path, &n_pos_in_item) == POSITION_FOUND)
+        {
+          p_s_ih = B_N_PITEM_HEAD(p_indirect_item_bh = PATH_PLAST_BUFFER(p_unf_search_path), PATH_LAST_POSITION(p_unf_search_path));
+          return (B_I_POS_UNFM_POINTER(p_indirect_item_bh, p_s_ih, n_pos_in_item));
+        }
+     /*  else */
+      printk("reiser-1800: search for unformatted node failed, p_s_key_to_search->k_offset = %u,  unf_key_to_search.k_offset = %u, MAX_ITEM_LEN(p_s_sb->s_blocksize) = %ld, debug this\n", p_s_key_to_search->k_offset, unf_key_to_search.k_offset,  MAX_ITEM_LEN(p_s_sb->s_blocksize) );
+      print_buffer_head(PATH_PLAST_BUFFER(p_unf_search_path), "the buffer holding the item before the key we failed to find");
+      print_block_head(PATH_PLAST_BUFFER(p_unf_search_path), "the block head");
+      return 0;                         /* keeps the compiler quiet */
+}
+
+
+                                /* hasn't been out of disk space tested  */
+/* The function is NOT SCHEDULE-SAFE! */
+static int get_buffer_near_last_unf ( struct super_block * p_s_sb, struct key * p_s_key_to_search,
+                                                 struct inode *  p_s_inode,  struct buffer_head * p_s_bh, 
+                                                 struct buffer_head ** pp_s_un_bh, struct path * p_s_search_path)
+{
+  int unf_blocknr = 0, /* blocknr from which we start search for a free block for an unformatted node, if 0
+                          then we didn't find an unformatted node though we might have found a file hole */
+      n_repeat = CARRY_ON;
+  struct key unf_key_to_search;
+  struct path unf_search_path;
+
+  copy_key(&unf_key_to_search,p_s_key_to_search);
+  unf_key_to_search.k_uniqueness = TYPE_INDIRECT;
+  
+  if (
+      (p_s_inode->u.reiserfs_i.i_first_direct_byte > 4095) /* i_first_direct_byte gets used for all sorts of
+                                                              crap other than what the name indicates, thus
+                                                              testing to see if it is 0 is not enough */
+      && (p_s_inode->u.reiserfs_i.i_first_direct_byte < MAX_KEY_OFFSET) /* if there is no direct item then
+                                                                           i_first_direct_byte = MAX_KEY_OFFSET */
+      )
+    {
+                                /* actually, we don't want the last unformatted node, we want the last unformatted node
+                                   which is before the current file offset */
+      unf_key_to_search.k_offset = ((p_s_inode->u.reiserfs_i.i_first_direct_byte -1) < unf_key_to_search.k_offset) ? p_s_inode->u.reiserfs_i.i_first_direct_byte -1 :  unf_key_to_search.k_offset;
+
+      while (unf_key_to_search.k_offset > -1)
+        {
+                                /* This is our poorly documented way of initializing paths. -Hans */
+          init_path (&unf_search_path);
+                                /* get the blocknr from which we start the search for a free block. */
+          unf_blocknr = get_last_unformatted_node_blocknr_of_file(  p_s_key_to_search, /* assumes this points to the file tail */
+                                                                    p_s_sb,     /* lets us figure out the block size */
+                                                                    p_s_bh, /* if there is no unformatted node in the file,
+                                                                               then it returns p_s_bh->b_blocknr */
+                                                                    &unf_search_path,
+                                                                    p_s_inode
+                                                                    );
+/*        printk("in while loop: unf_blocknr = %d,  *pp_s_un_bh = %p\n", unf_blocknr, *pp_s_un_bh); */
+          if (unf_blocknr) 
+            break;
+          else                  /* release the path and search again, this could be really slow for huge
+                                   holes.....better to spend the coding time adding compression though.... -Hans */
+            {
+                                /* Vladimir, is it a problem that I don't brelse these buffers ?-Hans */
+              decrement_counters_in_path(&unf_search_path);
+              unf_key_to_search.k_offset -= 4096;
+            }
+        }
+      if (unf_blocknr) {
+        n_repeat |= get_new_buffer_near_blocknr(p_s_sb, unf_blocknr, pp_s_un_bh, p_s_search_path);
+      }
+      else {                    /* all unformatted nodes are holes */
+        n_repeat |= get_new_buffer_near_blocknr(p_s_sb, p_s_bh->b_blocknr, pp_s_un_bh, p_s_search_path); 
+      }
+    }
+  else {                        /* file has no unformatted nodes */
+    n_repeat |= get_new_buffer_near_blocknr(p_s_sb, p_s_bh->b_blocknr, pp_s_un_bh, p_s_search_path);
+/*     printk("in else: unf_blocknr = %d,  *pp_s_un_bh = %p\n", unf_blocknr, *pp_s_un_bh); */
+/*     print_path (0,  p_s_search_path); */
+  }
+
+  return n_repeat;
+}
+
+#endif /* NEW_GET_NEW_BUFFER */
+
+
+#ifdef OLD_GET_NEW_BUFFER
+
+/* The function is NOT SCHEDULE-SAFE! */
+int get_new_buffer(
+		   struct reiserfs_transaction_handle *th, 
+		   struct buffer_head *  p_s_bh,
+		   struct buffer_head ** pp_s_new_bh,
+		   struct path	       * p_s_path
+		   ) {
+  unsigned	long n_new_blocknumber = 0;
+  int		n_repeat;
+  struct super_block *	 p_s_sb = th->t_super;
+
+  if ( (n_repeat = reiserfs_new_unf_blocknrs (th, &n_new_blocknumber, p_s_bh->b_blocknr)) == NO_DISK_SPACE )
+    return NO_DISK_SPACE;
+  
+  *pp_s_new_bh = reiserfs_getblk(p_s_sb->s_dev, n_new_blocknumber, p_s_sb->s_blocksize);
+  if (atomic_read (&(*pp_s_new_bh)->b_count) > 1) {
+    /* Free path buffers to prevent deadlock which can occur in the
+       situation like : this process holds p_s_path; Block
+       (*pp_s_new_bh)->b_blocknr is on the path p_s_path, but it is
+       not necessary, that *pp_s_new_bh is in the tree; process 2
+       could remove it from the tree and freed block
+       (*pp_s_new_bh)->b_blocknr. Reiserfs_new_blocknrs in above
+       returns block (*pp_s_new_bh)->b_blocknr. Reiserfs_getblk gets
+       buffer for it, and it has b_count > 1. If we now will simply
+       wait in while ( (*pp_s_new_bh)->b_count > 1 ) we get into an
+       endless loop, as nobody will release this buffer and the
+       current process holds buffer twice. That is why we do
+       decrement_counters_in_path(p_s_path) before waiting until
+       b_count becomes 1. (it there were other processes holding node
+       pp_s_new_bh, then eventually we will get a moment, when all of
+       them released a buffer). */
+    decrement_counters_in_path(p_s_path);
+    wait_buffer_until_released (*pp_s_new_bh);
+    n_repeat |= SCHEDULE_OCCURRED;
+  }
+
+  RFALSE( atomic_read (&((*pp_s_new_bh)->b_count)) != 1 || 
+	  buffer_dirty (*pp_s_new_bh),
+	  "PAP-14100: not free or dirty buffer %b for the new block", 
+	  *pp_s_new_bh);
+
+  return n_repeat;
+}
+
+#endif /* OLD_GET_NEW_BUFFER */
+
+
+#ifdef GET_MANY_BLOCKNRS
+                                /* code not yet functional */
+get_next_blocknr (
+                  unsigned long *       p_blocknr_array,          /* we get a whole bunch of blocknrs all at once for
+                                                                     the write.  This is better than getting them one at
+                                                                     a time.  */
+                  unsigned long **      p_blocknr_index,        /* pointer to current offset into the array. */
+                  unsigned long        blocknr_array_length
+)
 {
-    struct buffer_head  *result;
-    PROC_EXP( unsigned int ctx_switches = kstat.context_swtch );
+  unsigned long return_value;
 
-    result = bread (super -> s_dev, n_block, n_size);
-    PROC_INFO_INC( super, breads );
-    PROC_EXP( if( kstat.context_swtch != ctx_switches ) 
-	      PROC_INFO_INC( super, bread_miss ) );
-    return result;
+  if (*p_blocknr_index < p_blocknr_array + blocknr_array_length) {
+    return_value = **p_blocknr_index;
+    **p_blocknr_index = 0;
+    *p_blocknr_index++;
+    return (return_value);
+  }
+  else
+    {
+      kfree (p_blocknr_array);
+    }
 }
+#endif /* GET_MANY_BLOCKNRS */
 
diff -urp linux/fs/reiserfs/dir.c new_kernel_src/fs/reiserfs/dir.c
--- linux/fs/reiserfs/dir.c	2009-06-10 21:00:37.000000000 +0100
+++ new_kernel_src/fs/reiserfs/dir.c	2002-03-25 03:10:33.000000000 +0000
@@ -1,8 +1,8 @@
 /*
- * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README
+ * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
  */
+#ifdef __KERNEL__
 
-#include <linux/config.h>
 #include <linux/string.h>
 #include <linux/errno.h>
 #include <linux/fs.h>
@@ -106,10 +106,6 @@ static int reiserfs_readdir (struct file
 		if (!d_name[d_reclen - 1])
 		    d_reclen = strlen (d_name);
 	
-		if (d_reclen > REISERFS_MAX_NAME_LEN(inode->i_sb->s_blocksize)){
-		    /* too big to send back to VFS */
-		    continue ;
-		}
 		d_off = deh_offset (deh);
 		filp->f_pos = d_off ;
 		d_ino = deh_objectid (deh);
@@ -131,8 +127,7 @@ static int reiserfs_readdir (struct file
 		// user space buffer is swapped out. At that time
 		// entry can move to somewhere else
 		memcpy (local_buf, d_name, d_reclen);
-		if (filldir (dirent, local_buf, d_reclen, d_off, d_ino, 
-		             DT_UNKNOWN) < 0) {
+		if (filldir (dirent, d_name, d_reclen, d_off, d_ino) < 0) {
 		    if (local_buf != small_buf) {
 			reiserfs_kfree(local_buf, d_reclen, inode->i_sb) ;
 		    }
diff -urp linux/fs/reiserfs/do_balan.c new_kernel_src/fs/reiserfs/do_balan.c
--- linux/fs/reiserfs/do_balan.c	2001-12-21 17:42:03.000000000 +0000
+++ new_kernel_src/fs/reiserfs/do_balan.c	2002-02-08 08:32:14.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README
+ * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
  */
 
 /* Now we have all buffers that must be used in balancing of the tree 	*/
@@ -16,11 +16,19 @@
  **
  **/
 
-#include <linux/config.h>
+#ifdef __KERNEL__
+
 #include <asm/uaccess.h>
 #include <linux/sched.h>
 #include <linux/reiserfs_fs.h>
 
+#else
+
+#include "nokernel.h"
+
+#endif
+
+
 #ifdef CONFIG_REISERFS_CHECK
 
 struct tree_balance * cur_tb = NULL; /* detects whether more than one
@@ -35,7 +43,7 @@ inline void do_balance_mark_leaf_dirty (
 {
     if (reiserfs_dont_log(tb->tb_sb)) {
 	if (!test_and_set_bit(BH_Dirty, &bh->b_state)) {
-	    __mark_buffer_dirty(bh) ;
+	    __mark_buffer_dirty(bh, flag);
 	    tb->need_balance_dirty = 1;
 	}
     } else {
diff -urp linux/fs/reiserfs/file.c new_kernel_src/fs/reiserfs/file.c
--- linux/fs/reiserfs/file.c	2002-02-25 19:38:09.000000000 +0000
+++ new_kernel_src/fs/reiserfs/file.c	2002-02-08 09:17:39.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README
+ * Copyright 1996-2000 Hans Reiser, see reiserfs/README for licensing and copyright details
  */
 
 
@@ -19,8 +19,9 @@
 ** small enough to have a tail, and the tail is currently in an
 ** unformatted node, the tail is converted back into a direct item.
 ** 
-** We use reiserfs_truncate_file to pack the tail, since it already has
-** all the conditions coded.  
+** Since reiserfs_file_truncate involves the same checks and conversions
+** we just call truncate on the file without changing the file size.
+** The file is not truncated at all.
 */
 static int reiserfs_file_release (struct inode * inode, struct file * filp)
 {
@@ -28,12 +29,16 @@ static int reiserfs_file_release (struct
     struct reiserfs_transaction_handle th ;
     int windex ;
 
+    /* don't pack if we aren't the last holder */
+    if (atomic_read(&inode->i_count) > 1) {
+	return 0;
+    }
+
     if (!S_ISREG (inode->i_mode))
 	BUG ();
 
     /* fast out for when nothing needs to be done */
-    if ((atomic_read(&inode->i_count) > 1 ||
-         !(inode->u.reiserfs_i.i_flags & i_pack_on_close_mask) || 
+    if ((!inode->u.reiserfs_i.i_pack_on_close || 
          !tail_has_to_be_packed(inode))       && 
 	inode->u.reiserfs_i.i_prealloc_count <= 0) {
 	return 0;
@@ -47,27 +52,22 @@ static int reiserfs_file_release (struct
 #ifdef REISERFS_PREALLOCATE
     reiserfs_discard_prealloc (&th, inode);
 #endif
-    journal_end(&th, inode->i_sb, JOURNAL_PER_BALANCE_CNT * 3) ;
 
-    if (atomic_read(&inode->i_count) <= 1 &&
-	(inode->u.reiserfs_i.i_flags & i_pack_on_close_mask) &&
-        tail_has_to_be_packed (inode)) {
+    if (tail_has_to_be_packed (inode)) {
 	/* if regular file is released by last holder and it has been
 	   appended (we append by unformatted node only) or its direct
 	   item(s) had to be converted, then it may have to be
 	   indirect2direct converted */
 	windex = push_journal_writer("file_release") ;
-	reiserfs_truncate_file(inode, 0) ;
+	reiserfs_do_truncate (&th, inode, 0/*no timestamp updates*/); 
 	pop_journal_writer(windex) ;
     }
+    journal_end(&th, inode->i_sb, JOURNAL_PER_BALANCE_CNT * 3) ;
     up (&inode->i_sem); 
     unlock_kernel() ;
     return 0;
 }
 
-static void reiserfs_vfs_truncate_file(struct inode *inode) {
-    reiserfs_truncate_file(inode, 1) ;
-}
 
 /* Sync a reiserfs file. */
 static int reiserfs_sync_file(
@@ -83,13 +83,37 @@ static int reiserfs_sync_file(
   if (!S_ISREG(p_s_inode->i_mode))
       BUG ();
 
-  n_err = fsync_inode_buffers(p_s_inode) ;
-  n_err |= fsync_inode_data_buffers(p_s_inode);
-  reiserfs_commit_for_inode(p_s_inode) ;
+  /* step one, flush all dirty buffers in the file's page map to disk */
+  n_err = generic_buffer_fdatasync(p_s_inode, 0, ~0UL) ;
+  
+  /* step two, commit the current transaction to flush any metadata
+  ** changes
+  */
+  journal_begin(&th, p_s_inode->i_sb, jbegin_count) ;
+  windex = push_journal_writer("sync_file") ;
+  reiserfs_update_sd(&th, p_s_inode);
+  pop_journal_writer(windex) ;
+  journal_end_sync(&th, p_s_inode->i_sb,jbegin_count) ;
   unlock_kernel() ;
   return ( n_err < 0 ) ? -EIO : 0;
 }
 
+
+/*
+** vfs version of truncate file.  Must NOT be called with
+** a transaction already started.
+*/
+static void reiserfs_truncate_file(struct inode *p_s_inode) {
+  struct reiserfs_transaction_handle th ;
+  int windex ;
+
+  journal_begin(&th, p_s_inode->i_sb,  JOURNAL_PER_BALANCE_CNT * 2 ) ;
+  windex = push_journal_writer("resierfs_vfs_truncate_file") ;
+  reiserfs_do_truncate (&th, p_s_inode, 1/*update timestamps*/) ;
+  pop_journal_writer(windex) ;
+  journal_end(&th, p_s_inode->i_sb,  JOURNAL_PER_BALANCE_CNT * 2 ) ;
+}
+
 static int reiserfs_setattr(struct dentry *dentry, struct iattr *attr) {
     struct inode *inode = dentry->d_inode ;
     int error ;
@@ -132,7 +156,6 @@ static int reiserfs_setattr(struct dentr
 struct file_operations reiserfs_file_operations = {
     read:	generic_file_read,
     write:	generic_file_write,
-    ioctl:	reiserfs_ioctl,
     mmap:	generic_file_mmap,
     release:	reiserfs_file_release,
     fsync:	reiserfs_sync_file,
@@ -140,8 +163,7 @@ struct file_operations reiserfs_file_ope
 
 
 struct  inode_operations reiserfs_file_inode_operations = {
-    truncate:	reiserfs_vfs_truncate_file,
-    setattr:    reiserfs_setattr,
+    truncate:	reiserfs_truncate_file,
 };
 
 
diff -urp linux/fs/reiserfs/fix_node.c new_kernel_src/fs/reiserfs/fix_node.c
--- linux/fs/reiserfs/fix_node.c	2009-06-10 21:00:37.000000000 +0100
+++ new_kernel_src/fs/reiserfs/fix_node.c	2002-03-25 03:10:33.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README
+ * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
  */
 
 /**
@@ -35,12 +35,20 @@
  **/
 
 
-#include <linux/config.h>
+#ifdef __KERNEL__
+
 #include <linux/sched.h>
 #include <linux/string.h>
 #include <linux/locks.h>
 #include <linux/reiserfs_fs.h>
 
+#else
+
+#include "nokernel.h"
+
+#endif
+
+
 
 /* To make any changes in the tree we find a node, that contains item
    to be changed/deleted or position in the node we insert a new item
@@ -373,12 +381,9 @@ static int get_num_ver (int mode, struct
 		       we do not include into node that is being filled */
 	end_bytes;	/* number of last bytes (entries for directory) of end_item-th item 
 			   we do node include into node that is being filled */
-    int split_item_positions[2]; /* these are positions in virtual item of
-				    items, that are split between S[0] and
-				    S1new and S1new and S2new */
+    //    int splitted_item_positions[2];	/* these are positions in virtual item of items, 
+    //					   that are splitted between S[0] and S1new and S1new and S2new */
 
-    split_item_positions[0] = -1;
-    split_item_positions[1] = -1;
 
     /* We only create additional nodes if we are in insert or paste mode
        or we are in replace mode at the internal level. If h is 0 and
@@ -414,18 +419,26 @@ static int get_num_ver (int mode, struct
 
     // last included item is the 'end_item'-th one
     end_item = vn->vn_nr_item - to - 1;
-    // do not count last 'end_bytes' units of 'end_item'-th item
+    // without last 'end_bytes' units
     end_bytes = (to_bytes != -1) ? to_bytes : 0;
 
-    /* go through all item beginning from the start_item-th item and ending by
-       the end_item-th item. Do not count first 'start_bytes' units of
-       'start_item'-th item and last 'end_bytes' of 'end_item'-th item */
+    /* go through all item begining from the start_item-th item and
+       ending by the end_item-th item. If start_bytes != -1 we take
+       only tailing part of start_bytes-th item. If end_bytes != -1 we
+       take only head of the end_item-th item. */
     
     for (i = start_item; i <= end_item; i ++) {
 	struct virtual_item * vi = vn->vn_vi + i;
 	int skip_from_end = ((i == end_item) ? end_bytes : 0);
 
-	RFALSE( needed_nodes > 3, "vs-8105: too many nodes are needed");
+#ifdef CONFIG_REISERFS_CHECK
+	if (needed_nodes > 3) {
+	    print_virtual_node (vn);
+	    reiserfs_panic (0, "vs-8105: get_num_ver: too many nodes %d are needed, "
+			    "start_item %d, end_item %d, start_bytes %d, end_bytes %d, i == %d",
+			    needed_nodes, start_item, end_item, start_bytes, end_bytes, i);
+	}
+#endif
 
 	/* get size of current item */
 	current_item_size = vi->vi_item_len;
@@ -476,16 +489,12 @@ static int get_num_ver (int mode, struct
 	}
 
 	/* something fits into the current node */
-	//if (snum012[3] != -1 || needed_nodes != 1)
-	//  reiserfs_panic (tb->tb_sb, "vs-8115: get_num_ver: too many nodes required");
-	//snum012[needed_nodes - 1 + 3] = op_unit_num (vi) - start_bytes - units;
+	if (snum012[3] != -1 || needed_nodes != 1)
+	    reiserfs_panic (tb->tb_sb, "vs-8115: get_num_ver: too many nodes required");
+	snum012[3] = op_unit_num (vi) - start_bytes - skip_from_end - units;
 	start_bytes += units;
-	snum012[needed_nodes - 1 + 3] = units;
 
-	if (needed_nodes > 2)
-	    reiserfs_warning ("vs-8111: get_num_ver: split_item_position is out of boundary\n");
 	snum012[needed_nodes - 1] ++;
-	split_item_positions[needed_nodes - 1] = i;
 	needed_nodes ++;
 	/* continue from the same item with start_bytes != -1 */
 	start_item = i;
@@ -493,41 +502,6 @@ static int get_num_ver (int mode, struct
 	total_node_size = 0;
     }
 
-    // sum012[4] (if it is not -1) contains number of units of which
-    // are to be in S1new, snum012[3] - to be in S0. They are supposed
-    // to be S1bytes and S2bytes correspondingly, so recalculate
-    if (snum012[4] > 0) {
-	int split_item_num;
-	int bytes_to_r, bytes_to_l;
-	int bytes_to_S1new;
-    
-	split_item_num = split_item_positions[1];
-	bytes_to_l = ((from == split_item_num && from_bytes != -1) ? from_bytes : 0);
-	bytes_to_r = ((end_item == split_item_num && end_bytes != -1) ? end_bytes : 0);
-	bytes_to_S1new = ((split_item_positions[0] == split_item_positions[1]) ? snum012[3] : 0);
-
-	// s2bytes
-	snum012[4] = op_unit_num (&vn->vn_vi[split_item_num]) - snum012[4] - bytes_to_r - bytes_to_l - bytes_to_S1new;
-
-	if (vn->vn_vi[split_item_num].vi_index != TYPE_DIRENTRY)
-	    reiserfs_warning ("vs-8115: get_num_ver: not directory item\n");
-    }
-
-    /* now we know S2bytes, calculate S1bytes */
-    if (snum012[3] > 0) {
-	int split_item_num;
-	int bytes_to_r, bytes_to_l;
-	int bytes_to_S2new;
-    
-	split_item_num = split_item_positions[0];
-	bytes_to_l = ((from == split_item_num && from_bytes != -1) ? from_bytes : 0);
-	bytes_to_r = ((end_item == split_item_num && end_bytes != -1) ? end_bytes : 0);
-	bytes_to_S2new = ((split_item_positions[0] == split_item_positions[1] && snum012[4] != -1) ? snum012[4] : 0);
-
-	// s1bytes
-	snum012[3] = op_unit_num (&vn->vn_vi[split_item_num]) - snum012[3] - bytes_to_r - bytes_to_l - bytes_to_S2new;
-    }
-    
     return needed_nodes;
 }
 
@@ -2029,7 +2003,7 @@ static int get_virtual_node_size (struct
 /* maybe we should fail balancing we are going to perform when kmalloc
    fails several times. But now it will loop until kmalloc gets
    required memory */
-static int get_mem_for_virtual_node (struct tree_balance * tb)
+int get_mem_for_virtual_node (struct tree_balance * tb)
 {
     int check_fs = 0;
     int size;
@@ -2297,18 +2271,6 @@ int fix_nodes (int n_op_mode,
 
     p_s_tb->fs_gen = get_generation (p_s_tb->tb_sb);
 
-    /* we prepare and log the super here so it will already be in the
-    ** transaction when do_balance needs to change it.
-    ** This way do_balance won't have to schedule when trying to prepare
-    ** the super for logging
-    */
-    reiserfs_prepare_for_journal(p_s_tb->tb_sb, 
-                                 SB_BUFFER_WITH_SB(p_s_tb->tb_sb), 1) ;
-    journal_mark_dirty(p_s_tb->transaction_handle, p_s_tb->tb_sb, 
-                       SB_BUFFER_WITH_SB(p_s_tb->tb_sb)) ;
-    if ( FILESYSTEM_CHANGED_TB (p_s_tb) )
-	return REPEAT_SEARCH;
-
     /* if it possible in indirect_to_direct conversion */
     if (buffer_locked (p_s_tbS0)) {
         __wait_on_buffer (p_s_tbS0);
@@ -2465,6 +2427,7 @@ int fix_nodes (int n_op_mode,
 	    brelse (p_s_tb->CFR[i]);p_s_tb->CFR[i] = 0;
 	}
 
+#if 0 // keep new allocated nodes
 	if (wait_tb_buffers_run) {
 	    for ( i = 0; i < MAX_FEB_SIZE; i++ ) { 
 		if ( p_s_tb->FEB[i] ) {
@@ -2473,6 +2436,7 @@ int fix_nodes (int n_op_mode,
 		}
 	    }
 	}
+#endif
 	return n_ret_value;
     }
 
diff -urp linux/fs/reiserfs/hashes.c new_kernel_src/fs/reiserfs/hashes.c
--- linux/fs/reiserfs/hashes.c	2001-10-12 22:19:28.000000000 +0100
+++ new_kernel_src/fs/reiserfs/hashes.c	2002-02-08 08:24:04.000000000 +0000
@@ -1,4 +1,3 @@
-
 /*
  * Keyed 32-bit hash function using TEA in a Davis-Meyer function
  *   H0 = Key
@@ -171,8 +170,6 @@ u32 keyed_hash(const signed char *msg, i
 	return h0^h1;
 }
 
-/* What follows in this file is copyright 2000 by Hans Reiser, and the
- * licensing of what follows is governed by reiserfs/README */
 
 u32 yura_hash (const signed char *msg, int len)
 {
diff -urp linux/fs/reiserfs/ibalance.c new_kernel_src/fs/reiserfs/ibalance.c
--- linux/fs/reiserfs/ibalance.c	2001-11-09 22:18:25.000000000 +0000
+++ new_kernel_src/fs/reiserfs/ibalance.c	2002-02-08 08:28:32.000000000 +0000
@@ -1,13 +1,21 @@
 /*
- * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README
+ * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
  */
 
-#include <linux/config.h>
+#ifdef __KERNEL__
+
 #include <asm/uaccess.h>
 #include <linux/string.h>
 #include <linux/sched.h>
 #include <linux/reiserfs_fs.h>
 
+#else
+
+#include "nokernel.h"
+
+#endif
+
+
 /* this is one and only function that is used outside (do_balance.c) */
 int	balance_internal (
 			  struct tree_balance * ,
diff -urp linux/fs/reiserfs/inode.c new_kernel_src/fs/reiserfs/inode.c
--- linux/fs/reiserfs/inode.c	2009-06-10 21:00:37.000000000 +0100
+++ new_kernel_src/fs/reiserfs/inode.c	2002-03-25 03:10:33.000000000 +0000
@@ -1,8 +1,7 @@
 /*
- * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README
+ * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
  */
 
-#include <linux/config.h>
 #include <linux/sched.h>
 #include <linux/reiserfs_fs.h>
 #include <linux/locks.h>
@@ -10,12 +9,12 @@
 #include <asm/uaccess.h>
 #include <asm/unaligned.h>
 
-/* args for the create parameter of reiserfs_get_block */
-#define GET_BLOCK_NO_CREATE 0 /* don't create new blocks or convert tails */
-#define GET_BLOCK_CREATE 1    /* add anything you need to find block */
-#define GET_BLOCK_NO_HOLE 2   /* return -ENOENT for file holes */
-#define GET_BLOCK_READ_DIRECT 4  /* read the tail if indirect item not found */
-#define GET_BLOCK_NO_ISEM     8 /* i_sem is not held, don't preallocate */
+#else
+
+#include "nokernel.h"
+
+#endif
+
 
 static int reiserfs_get_block (struct inode * inode, long block,
 			       struct buffer_head * bh_result, int create);
@@ -58,6 +57,26 @@ void reiserfs_delete_inode (struct inode
     unlock_kernel() ;
 }
 
+#if 0
+static void copy_data_blocks_to_inode (struct inode * inode, struct item_head * ih, __u32 * ind_item)
+{
+  int first_log_block = (ih->ih_key.k_offset - 1) / inode->i_sb->s_blocksize; /* first log block addressed by indirect item */
+  int i, j;
+  
+  for (i = first_log_block, j = 0; i < REISERFS_N_BLOCKS && j < I_UNFM_NUM (ih); i ++, j ++) {
+#ifdef CONFIG_REISERFS_CHECK
+    if (inode->u.reiserfs_i.i_data [i] && inode->u.reiserfs_i.i_data [i] != ind_item [j])
+      reiserfs_panic (inode->i_sb, "vs-13000: copy_data_blocks_to_inode: "
+							 "log block %d, data block %d is seet and doe not match to unfmptr %d",
+							 i, inode->u.reiserfs_i.i_data [i], ind_item [j]);
+#endif
+    inode->u.reiserfs_i.i_data [i] = ind_item [j];
+  }
+}
+#endif/*0*/
+
+
+
 static void _make_cpu_key (struct cpu_key * key, int version, __u32 dirid, __u32 objectid, 
 	       loff_t offset, int type, int length )
 {
@@ -113,55 +132,56 @@ static void add_to_flushlist(struct inod
 //
 // FIXME: we might cache recently accessed indirect item (or at least
 // first 15 pointers just like ext2 does
+//
+static int got_from_inode (struct inode * inode, b_blocknr_t * pblock)
+{
+  return 0;
+}
 
-// Ugh.  Not too eager for that....
-//  I cut the code until such time as I see a convincing argument (benchmark).
-// I don't want a bloated inode struct..., and I don't like code complexity....
-
-/* cutting the code is fine, since it really isn't in use yet and is easy
-** to add back in.  But, Vladimir has a really good idea here.  Think
-** about what happens for reading a file.  For each page,
-** The VFS layer calls reiserfs_readpage, who searches the tree to find
-** an indirect item.  This indirect item has X number of pointers, where
-** X is a big number if we've done the block allocation right.  But,
-** we only use one or two of these pointers during each call to readpage,
-** needlessly researching again later on.
-**
-** The size of the cache could be dynamic based on the size of the file.
-**
-** I'd also like to see us cache the location the stat data item, since
-** we are needlessly researching for that frequently.
-**
-** --chris
+/* people who call journal_begin with a page locked must call this
+** BEFORE calling journal_begin
 */
-
-/* If this page has a file tail in it, and
-** it was read in by get_block_create_0, the page data is valid,
-** but tail is still sitting in a direct item, and we can't write to
-** it.  So, look through this page, and check all the mapped buffers
-** to make sure they have valid block numbers.  Any that don't need
-** to be unmapped, so that block_prepare_write will correctly call
-** reiserfs_get_block to convert the tail into an unformatted node
+static int prevent_flush_page_lock(struct super_block *s,
+                                   struct page *page, 
+				   struct inode *inode) {
+  struct reiserfs_page_list *pl ;
+  /* we don't care if the inode has a stale pointer from an old
+  ** transaction
+  */
+  if(inode->u.reiserfs_i.i_conversion_trans_id != SB_JOURNAL(s)->j_trans_id) {
+    return 0 ;
+  }
+  pl = inode->u.reiserfs_i.i_converted_page ;
+  if (pl && pl->page == page) {
+    pl->do_not_lock = 1 ;
+  }
+  return 0 ;
+ 
+}
+/* people who call journal_end with a page locked must call this
+** AFTER calling journal_end
 */
-static inline void fix_tail_page_for_writing(struct page *page) {
-    struct buffer_head *head, *next, *bh ;
-
-    if (page && page->buffers) {
-	head = page->buffers ;
-	bh = head ;
-	do {
-	    next = bh->b_this_page ;
-	    if (buffer_mapped(bh) && bh->b_blocknr == 0) {
-	        reiserfs_unmap_buffer(bh) ;
-	    }
-	    bh = next ;
-	} while (bh != head) ;
-    }
+static int allow_flush_page_lock(struct super_block *s,
+                                   struct page *page, 
+				   struct inode *inode) {
+
+  struct reiserfs_page_list *pl ;
+  /* we don't care if the inode has a stale pointer from an old
+  ** transaction
+  */
+  if(inode->u.reiserfs_i.i_conversion_trans_id != SB_JOURNAL(s)->j_trans_id) {
+    return 0 ;
+  }
+  pl = inode->u.reiserfs_i.i_converted_page ;
+  if (pl && pl->page == page) {
+    pl->do_not_lock = 0 ;
+  }
+  return 0 ;
+ 
 }
 
 
 
-
 /* we need to allocate a block for new unformatted node.  Try to figure out
    what point in bitmap reiserfs_new_blocknrs should start from. */
 static b_blocknr_t find_tag (struct buffer_head * bh, struct item_head * ih,
@@ -228,7 +248,7 @@ static int file_capable (struct inode * 
     return 0;
 }
 
-/*static*/ void restart_transaction(struct reiserfs_transaction_handle *th,
+static void restart_transaction(struct reiserfs_transaction_handle *th,
 				struct inode *inode, struct path *path) {
   struct super_block *s = th->t_super ;
   int len = th->t_blocks_allocated ;
@@ -244,41 +264,37 @@ static int file_capable (struct inode * 
 // for 'block'-th logical block of file. When it hits direct item it
 // returns 0 (being called from bmap) or read direct item into piece
 // of page (bh_result)
-
-// Please improve the english/clarity in the comment above, as it is
-// hard to understand.
-
-static int _get_block_create_0 (struct inode * inode, long block,
+static void _get_block_create_0 (struct inode * inode, long block,
 				 struct buffer_head * bh_result,
-				 int args)
+				 int read_direct)
 {
     INITIALIZE_PATH (path);
     struct cpu_key key;
     struct buffer_head * bh;
-    struct item_head * ih, tmp_ih;
-    int fs_gen ;
+    struct item_head * ih;
     int blocknr;
-    char * p = NULL;
+    char * p;
     int chars;
-    int ret ;
-    int done = 0 ;
-    unsigned long offset ;
+
+
+    if (got_from_inode (inode, &bh_result->b_blocknr)) {
+	bh_result->b_dev = inode->i_dev;
+	//bh_result->b_blocknr = block;
+	bh_result->b_state |= (1UL << BH_Mapped);
+	return;
+    }
 
     // prepare the key to look for the 'block'-th block of file
     make_cpu_key (&key, inode,
 		  (loff_t)block * inode->i_sb->s_blocksize + 1, TYPE_ANY, 3);
 
-research:
+    wait_on_tail (inode);
+    lock_tail (inode, READ_TAIL_LOCK);
+
     if (search_for_position_by_key (inode->i_sb, &key, &path) != POSITION_FOUND) {
 	pathrelse (&path);
-        if (p)
-            kunmap(bh_result->b_page) ;
-	// We do not return -ENOENT if there is a hole but page is uptodate, because it means
-	// That there is some MMAPED data associated with it that is yet to be written to disk.
-	if ((args & GET_BLOCK_NO_HOLE) && !Page_Uptodate(bh_result->b_page) ) {
-	    return -ENOENT ;
-	}
-        return 0 ;
+	unlock_tail(inode) ;
+	return;
     }
     
     //
@@ -290,33 +306,25 @@ research:
 	/* FIXME: here we could cache indirect item or part of it in
 	   the inode to avoid search_by_key in case of subsequent
 	   access to file */
-	blocknr = get_block_num(ind_item, path.pos_in_item) ;
-	ret = 0 ;
+	blocknr = le32_to_cpu (ind_item [path.pos_in_item]);
 	if (blocknr) {
 	    bh_result->b_dev = inode->i_dev;
 	    bh_result->b_blocknr = blocknr;
 	    bh_result->b_state |= (1UL << BH_Mapped);
-	} else
-	    // We do not return -ENOENT if there is a hole but page is uptodate, because it means
-	    // That there is some MMAPED data associated with it that is yet to be written to disk.
-	    if ((args & GET_BLOCK_NO_HOLE) && !Page_Uptodate(bh_result->b_page) ) {
-		ret = -ENOENT ;
-	    }
-
+	}
+	unlock_tail (inode);
 	pathrelse (&path);
-        if (p)
-            kunmap(bh_result->b_page) ;
-	return ret ;
+	return;
     }
 
+
     // requested data are in direct item(s)
-    if (!(args & GET_BLOCK_READ_DIRECT)) {
+    if (!read_direct) {
 	// we are called by bmap. FIXME: we can not map block of file
 	// when it is stored in direct item(s)
+	unlock_tail (inode);
 	pathrelse (&path);	
-        if (p)
-            kunmap(bh_result->b_page) ;
-	return -ENOENT;
+	return;
     }
 
     /* if we've got a direct item, and the buffer was uptodate,
@@ -338,45 +346,13 @@ research:
     }
 
     // read file tail into part of page
-    offset = (cpu_key_k_offset(&key) - 1) & (PAGE_CACHE_SIZE - 1) ;
-    fs_gen = get_generation(inode->i_sb) ;
-    copy_item_head (&tmp_ih, ih);
-
-    /* we only want to kmap if we are reading the tail into the page.
-    ** this is not the common case, so we don't kmap until we are
-    ** sure we need to.  But, this means the item might move if
-    ** kmap schedules
-    */
-    if (!p) {
-    p = (char *)kmap(bh_result->b_page) ;
-    if (fs_changed (fs_gen, inode->i_sb) && item_moved (&tmp_ih, &path)) {
-        goto research;
-    }
-    }
-    p += offset ;
+    p = bh_result->b_data;
     memset (p, 0, inode->i_sb->s_blocksize);
     do {
-	if (!is_direct_le_ih (ih)) {
+	if (!is_direct_le_ih (ih))
 	    BUG ();
-        }
-	/* make sure we don't read more bytes than actually exist in
-	** the file.  This can happen in odd cases where i_size isn't
-	** correct, and when direct item padding results in a few 
-	** extra bytes at the end of the direct item
-	*/
-        if ((le_ih_k_offset(ih) + path.pos_in_item) > inode->i_size)
-	    break ;
-	if ((le_ih_k_offset(ih) - 1 + ih_item_len(ih)) > inode->i_size) {
-	    chars = inode->i_size - (le_ih_k_offset(ih) - 1) - path.pos_in_item;
-	    done = 1 ;
-	} else {
-	    chars = ih_item_len(ih) - path.pos_in_item;
-	}
+	chars = le16_to_cpu (ih->ih_item_len) - path.pos_in_item;
 	memcpy (p, B_I_PITEM (bh, ih) + path.pos_in_item, chars);
-
-	if (done) 
-	    break ;
-
 	p += chars;
 
 	if (PATH_LAST_POSITION (&path) != (B_NR_ITEMS (bh) - 1))
@@ -395,16 +371,17 @@ research:
 	ih = get_ih (&path);
     } while (1);
 
-    flush_dcache_page(bh_result->b_page) ;
-    kunmap(bh_result->b_page) ;
-
-finished:
+    unlock_tail (inode);
     pathrelse (&path);
+    
+    // FIXME: b_blocknr == 0 here. but b_data contains correct data
+    // from tail. ll_rw_block will skip uptodate buffers
     bh_result->b_blocknr = 0 ;
     bh_result->b_dev = inode->i_dev;
     mark_buffer_uptodate (bh_result, 1);
     bh_result->b_state |= (1UL << BH_Mapped);
-    return 0;
+
+    return;
 }
 
 
@@ -417,118 +394,11 @@ int reiserfs_bmap (struct inode * inode,
 	return -EFBIG;
 
     lock_kernel() ;
-    /* do not read the direct item */
-    _get_block_create_0 (inode, block, bh_result, 0) ;
+    _get_block_create_0 (inode, block, bh_result, 0/*do not read direct item*/);
     unlock_kernel() ;
     return 0;
 }
 
-/* special version of get_block that is only used by grab_tail_page right
-** now.  It is sent to block_prepare_write, and when you try to get a
-** block past the end of the file (or a block from a hole) it returns
-** -ENOENT instead of a valid buffer.  block_prepare_write expects to
-** be able to do i/o on the buffers returned, unless an error value
-** is also returned.
-** 
-** So, this allows block_prepare_write to be used for reading a single block
-** in a page.  Where it does not produce a valid page for holes, or past the
-** end of the file.  This turns out to be exactly what we need for reading
-** tails for conversion.
-**
-** The point of the wrapper is forcing a certain value for create, even
-** though the VFS layer is calling this function with create==1.  If you 
-** don't want to send create == GET_BLOCK_NO_HOLE to reiserfs_get_block, 
-** don't use this function.
-*/
-static int reiserfs_get_block_create_0 (struct inode * inode, long block,
-			struct buffer_head * bh_result, int create) {
-    return reiserfs_get_block(inode, block, bh_result, GET_BLOCK_NO_HOLE) ;
-}
-
-static int reiserfs_get_block_direct_io (struct inode * inode, long block,
-			struct buffer_head * bh_result, int create) {
-    int ret ;
-
-    ret = reiserfs_get_block(inode, block, bh_result, create) ;
-
-    /* don't allow direct io onto tail pages */
-    if (ret == 0 && buffer_mapped(bh_result) && bh_result->b_blocknr == 0) {
-	/* make sure future calls to the direct io funcs for this offset
-	** in the file fail by unmapping the buffer
-	*/
-	reiserfs_unmap_buffer(bh_result);
-        ret = -EINVAL ;
-    }
-    return ret ;
-}
-
-
-/*
-** helper function for when reiserfs_get_block is called for a hole
-** but the file tail is still in a direct item
-** bh_result is the buffer head for the hole
-** tail_offset is the offset of the start of the tail in the file
-**
-** This calls prepare_write, which will start a new transaction
-** you should not be in a transaction, or have any paths held when you
-** call this.
-*/
-static int convert_tail_for_hole(struct inode *inode, 
-                                 struct buffer_head *bh_result,
-				 loff_t tail_offset) {
-    unsigned long index ;
-    unsigned long tail_end ; 
-    unsigned long tail_start ;
-    struct page * tail_page ;
-    struct page * hole_page = bh_result->b_page ;
-    int retval = 0 ;
-
-    if ((tail_offset & (bh_result->b_size - 1)) != 1) 
-        return -EIO ;
-
-    /* always try to read until the end of the block */
-    tail_start = tail_offset & (PAGE_CACHE_SIZE - 1) ;
-    tail_end = (tail_start | (bh_result->b_size - 1)) + 1 ;
-
-    index = tail_offset >> PAGE_CACHE_SHIFT ;
-    if (index != hole_page->index) {
-	tail_page = grab_cache_page(inode->i_mapping, index) ;
-	retval = -ENOMEM;
-	if (!tail_page) {
-	    goto out ;
-	}
-    } else {
-        tail_page = hole_page ;
-    }
-
-    /* we don't have to make sure the conversion did not happen while
-    ** we were locking the page because anyone that could convert
-    ** must first take i_sem.
-    **
-    ** We must fix the tail page for writing because it might have buffers
-    ** that are mapped, but have a block number of 0.  This indicates tail
-    ** data that has been read directly into the page, and block_prepare_write
-    ** won't trigger a get_block in this case.
-    */
-    fix_tail_page_for_writing(tail_page) ;
-    retval = block_prepare_write(tail_page, tail_start, tail_end, 
-                                 reiserfs_get_block) ; 
-    if (retval)
-        goto unlock ;
-
-    /* tail conversion might change the data in the page */
-    flush_dcache_page(tail_page) ;
-
-    retval = generic_commit_write(NULL, tail_page, tail_start, tail_end) ;
-
-unlock:
-    if (tail_page != hole_page) {
-        UnlockPage(tail_page) ;
-	page_cache_release(tail_page) ;
-    }
-out:
-    return retval ;
-}
 
 static inline int _allocate_block(struct reiserfs_transaction_handle *th,
                            struct inode *inode, 
@@ -544,10 +414,8 @@ static inline int _allocate_block(struct
     return reiserfs_new_unf_blocknrs (th, allocated_block_nr, tag);
 }
 //
-// initially this function was derived from ext2's analog and evolved
-// as the prototype did.  You'll need to look at the ext2 version to
-// determine which parts are derivative, if any, understanding that
-// there are only so many ways to code to a given interface.
+// initially this function was derived from minix or ext2's analog and
+// evolved as the prototype did
 //
 static int reiserfs_get_block (struct inode * inode, long block,
 			       struct buffer_head * bh_result, int create)
@@ -565,25 +433,12 @@ static int reiserfs_get_block (struct in
     int fs_gen;
     int windex ;
     struct reiserfs_transaction_handle th ;
-    /* space reserved in transaction batch: 
-        . 3 balancings in direct->indirect conversion
-        . 1 block involved into reiserfs_update_sd()
-       XXX in practically impossible worst case direct2indirect()
-       can incur (much) more that 3 balancings. */
-    int jbegin_count = JOURNAL_PER_BALANCE_CNT * 3 + 1;
+    int jbegin_count = JOURNAL_PER_BALANCE_CNT * 3 ;
     int version;
-    int transaction_started = 0 ;
-    loff_t new_offset = (((loff_t)block) << inode->i_sb->s_blocksize_bits) + 1 ;
 
-				/* bad.... */
     lock_kernel() ;
-    th.t_trans_id = 0 ;
-    version = get_inode_item_key_version (inode);
 
-    if (block < 0) {
-	unlock_kernel();
-	return -EIO;
-    }
+    version = inode_items_version (inode);
 
     if (!file_capable (inode, block)) {
 	unlock_kernel() ;
@@ -593,27 +448,33 @@ static int reiserfs_get_block (struct in
     /* if !create, we aren't changing the FS, so we don't need to
     ** log anything, so we don't need to start a transaction
     */
-    if (!(create & GET_BLOCK_CREATE)) {
-	int ret ;
+    if (!create) {
 	/* find number of block-th logical block of the file */
-	ret = _get_block_create_0 (inode, block, bh_result, 
-	                           create | GET_BLOCK_READ_DIRECT) ;
+	_get_block_create_0 (inode, block, bh_result, 1/*read direct item*/);
 	unlock_kernel() ;
-	return ret;
+	return 0;
+    }
+
+    if (block < 0) {
+	unlock_kernel();
+	return -EIO;
     }
 
-    inode->u.reiserfs_i.i_flags |= i_pack_on_close_mask;
+    // note: tail can not be convert_locked here. It can not get locked by
+    // another process either while we are in this vfs_write->get_block
+    if (is_tail_convert_locked (inode))
+	BUG ();
 
+    prevent_flush_page_lock(inode->i_sb, bh_result->b_page, inode) ;
+    journal_begin(&th, inode->i_sb, jbegin_count) ;
+    inode->u.reiserfs_i.i_pack_on_close = 1 ;
     windex = push_journal_writer("reiserfs_get_block") ;
   
     /* set the key of the first byte in the 'block'-th block of file */
-    make_cpu_key (&key, inode, new_offset,
+    make_cpu_key (&key, inode,
+		  (loff_t)block * inode->i_sb->s_blocksize + 1, // k_offset
 		  TYPE_ANY, 3/*key length*/);
-    if ((new_offset + inode->i_sb->s_blocksize - 1) > inode->i_size) {
-	journal_begin(&th, inode->i_sb, jbegin_count) ;
-	reiserfs_update_inode_transaction(inode) ;
-	transaction_started = 1 ;
-    }
+
  research:
 
     retval = search_for_position_by_key (inode->i_sb, &key, &path);
@@ -628,20 +489,16 @@ static int reiserfs_get_block (struct in
     pos_in_item = path.pos_in_item;
 
     fs_gen = get_generation (inode->i_sb);
-    copy_item_head (&tmp_ih, ih);
 
     if (allocation_needed (retval, allocated_block_nr, ih, item, pos_in_item)) {
 	/* we have to allocate block for the unformatted node */
+	copy_item_head (&tmp_ih, ih);
 	tag = find_tag (bh, ih, item, pos_in_item);
-	if (!transaction_started) {
-	    pathrelse(&path) ;
-	    journal_begin(&th, inode->i_sb, jbegin_count) ;
-	    reiserfs_update_inode_transaction(inode) ;
-	    transaction_started = 1 ;
-	    goto research ;
-	}
-
-	repeat = _allocate_block(&th, inode, &allocated_block_nr, tag, create);
+#ifdef REISERFS_PREALLOCATE
+	repeat = reiserfs_new_unf_blocknrs2 (&th, inode, &allocated_block_nr, tag);
+#else
+	repeat = reiserfs_new_unf_blocknrs (&th, &allocated_block_nr, tag);
+#endif
 
 	if (repeat == NO_DISK_SPACE) {
 	    /* restart the transaction to give the journal a chance to free
@@ -652,6 +509,7 @@ static int reiserfs_get_block (struct in
 	    repeat = _allocate_block(&th, inode,&allocated_block_nr,tag,create);
 
 	    if (repeat != NO_DISK_SPACE) {
+		allocated_block_nr = 0 ; /* just in case it got changed somehow */
 		goto research ;
 	    }
 	    retval = -ENOSPC;
@@ -677,38 +535,23 @@ static int reiserfs_get_block (struct in
 		goto research;
 	    }
 	    bh_result->b_state |= (1UL << BH_New);
-	    put_block_num(item, pos_in_item, allocated_block_nr) ;
-            unfm_ptr = allocated_block_nr;
+	    item[pos_in_item] = cpu_to_le32 (allocated_block_nr);
 	    journal_mark_dirty (&th, inode->i_sb, bh);
-	    inode->i_blocks += (inode->i_sb->s_blocksize / 512) ;
-	    reiserfs_update_sd(&th, inode) ;
 	}
-	set_block_dev_mapped(bh_result, unfm_ptr, inode);
+	set_block_dev_mapped (bh_result, le32_to_cpu (item[pos_in_item]), inode);
 	pathrelse (&path);
 	pop_journal_writer(windex) ;
-	if (transaction_started)
-	    journal_end(&th, inode->i_sb, jbegin_count) ;
-
+	journal_end(&th, inode->i_sb, jbegin_count) ;
+	allow_flush_page_lock(inode->i_sb, bh_result->b_page, inode) ;
 	unlock_kernel() ;
 	 
-	/* the item was found, so new blocks were not added to the file
+	/* the item was found, so the file was not grown or changed. 
 	** there is no need to make sure the inode is updated with this 
 	** transaction
 	*/
 	return 0;
     }
 
-    if (!transaction_started) {
-	/* if we don't pathrelse, we could vs-3050 on the buffer if
-	** someone is waiting for it (they can't finish until the buffer
-	** is released, we can start a new transaction until they finish)
-	*/
-	pathrelse(&path) ;
-	journal_begin(&th, inode->i_sb, jbegin_count) ;
-	reiserfs_update_inode_transaction(inode) ;
-	transaction_started = 1 ;
-	goto research;
-    }
 
     /* desired position is not found or is in the direct item. We have
        to append file with holes up to 'block'-th block converting
@@ -751,7 +594,7 @@ static int reiserfs_get_block (struct in
 	    if (tail_offset == cpu_key_k_offset (&key)) {
 		/* direct item we just found fits into block we have
                    to map. Convert it into unformatted node: use
-                   bh_result for the conversion */
+                   bh_result for the convertion */
 		set_block_dev_mapped (bh_result, allocated_block_nr, inode);
 		unbh = bh_result;
 		done = 1;
@@ -759,41 +602,55 @@ static int reiserfs_get_block (struct in
 		/* we have to padd file tail stored in direct item(s)
 		   up to block size and convert it to unformatted
 		   node. FIXME: this should also get into page cache */
-
-		pathrelse(&path) ;
-		journal_end(&th, inode->i_sb, jbegin_count) ;
-		transaction_started = 0 ;
-
-		retval = convert_tail_for_hole(inode, bh_result, tail_offset) ;
-		if (retval) {
-		    if ( retval != -ENOSPC )
-			printk("clm-6004: convert tail failed inode %lu, error %d\n", inode->i_ino, retval) ;
-		    if (allocated_block_nr) {
-			/* the bitmap, the super, and the stat data == 3 */
-			journal_begin(&th, inode->i_sb, 3) ;
+		if (!unbh) {
+		    copy_item_head (&tmp_ih, ih);
+			 
+		    fs_gen = get_generation (inode->i_sb);
+
+		    get_new_buffer (&th, bh, &unbh, &path);
+		    if (!unbh) {
+			/* restart_transaction calls pathrelse for us */
+			restart_transaction(&th, inode, &path) ;
+			get_new_buffer (&th, bh, &unbh, &path);
+			if (unbh) {
+			    goto search_again ;
+			}
 			reiserfs_free_block (&th, allocated_block_nr);
-			transaction_started = 1 ;
+
+#ifdef REISERFS_PREALLOCATE
+			reiserfs_discard_prealloc (&th, inode); 
+#endif
+			retval = -ENOSPC;
+			goto failure;
+		    }
+		    //unbh->b_state |= (1UL << BH_New);
+		    if (fs_changed (fs_gen, inode->i_sb) && 
+		        item_moved (&tmp_ih, &path)) {
+			goto search_again ;
 		    }
-		    goto failure ;
 		}
-		goto research ;
 	    }
+	    mark_buffer_uptodate (unbh, 1);
 	    retval = direct2indirect (&th, inode, &path, unbh, tail_offset);
 	    if (retval) {
-		reiserfs_unmap_buffer(unbh);
+		if (!done) {
+		    // free what has been allocated by get_new_buffer
+		    unsigned long tmp = unbh->b_blocknr;
+
+		    bforget (unbh);
+		    reiserfs_free_block (&th, tmp);
+#ifdef REISERFS_PREALLOCATE
+		    reiserfs_discard_prealloc (&th, inode); 
+#endif
+
+		}
 		reiserfs_free_block (&th, allocated_block_nr);
+
+#ifdef REISERFS_PREALLOCATE
+		reiserfs_discard_prealloc (&th, inode); 
+#endif
 		goto failure;
 	    }
-	    /* it is important the mark_buffer_uptodate is done after
-	    ** the direct2indirect.  The buffer might contain valid
-	    ** data newer than the data on disk (read by readpage, changed,
-	    ** and then sent here by writepage).  direct2indirect needs
-	    ** to know if unbh was already up to date, so it can decide
-	    ** if the data in unbh needs to be replaced with data from
-	    ** the disk
-	    */
-	    mark_buffer_uptodate (unbh, 1);
-
 	    /* we've converted the tail, so we must 
 	    ** flush unbh before the transaction commits
 	    */
@@ -804,6 +661,18 @@ static int reiserfs_get_block (struct in
 	    */
 	    __mark_buffer_dirty(unbh) ;
 		  
+	    if (!done) {
+		// unbh was acquired by get_new_buffer
+		/* adding the page to the flush list sets the do not lock
+		** flag that gets check when flushing the page at transaction
+		** end.  We only want this for pages passed in to get_block, 
+		** not for buffer cache pages returned by get_new_buffer().  
+		** So, we allow flush page to lock this page before brelsing 
+		** the buffer.
+		*/
+		allow_flush_page_lock(inode->i_sb, unbh->b_page, inode) ;
+		brelse (unbh);
+	    }
 	    //inode->i_blocks += inode->i_sb->s_blocksize / 512;
 	    //mark_tail_converted (inode);
 	} else {
@@ -853,13 +722,13 @@ static int reiserfs_get_block (struct in
 	** ending their transaction will be able to continue.
 	*/
 	if (journal_transaction_should_end(&th, th.t_blocks_allocated)) {
-	  restart_transaction(&th, inode, &path) ; 
+	  int orig_len_alloc = th.t_blocks_allocated ;
+	  pathrelse (&path);
+	  reiserfs_update_sd(&th, inode) ;
+	  journal_end(&th, inode->i_sb, orig_len_alloc) ;
+	  journal_begin(&th, inode->i_sb, orig_len_alloc) ;
 	}
-	/* inserting indirect pointers for a hole can take a 
-	** long time.  reschedule if needed
-	*/
-	if (current->need_resched)
-	    schedule() ;
+search_again:
 
 	retval = search_for_position_by_key (inode->i_sb, &key, &path);
 	if (retval == IO_ERROR) {
@@ -870,27 +739,32 @@ static int reiserfs_get_block (struct in
 	    reiserfs_warning ("vs-825: reiserfs_get_block: "
 			      "%K should not be found\n", &key);
 	    retval = -EEXIST;
-	    if (allocated_block_nr)
-	        reiserfs_free_block (&th, allocated_block_nr);
-	    pathrelse(&path) ;
 	    goto failure;
 	}
 	bh = get_last_bh (&path);
 	ih = get_ih (&path);
 	item = get_item (&path);
 	pos_in_item = path.pos_in_item;
+
     } while (1);
 
 
     retval = 0;
     reiserfs_check_path(&path) ;
 
+    //    pathrelse (&path);
+    //reiserfs_update_sd(&th, inode) ;
+    //pop_journal_writer(windex) ;
+    //journal_end(&th, inode->i_sb, jbegin_count) ;
+    //allow_flush_page_lock(inode->i_sb, bh_result->b_page, inode) ;
+    //unlock_kernel() ;
+    //return 0;
+    
  failure:
-    if (transaction_started) {
-      reiserfs_update_sd(&th, inode) ;
-      journal_end(&th, inode->i_sb, jbegin_count) ;
-    }
+    reiserfs_update_sd(&th, inode) ;
     pop_journal_writer(windex) ;
+    journal_end(&th, inode->i_sb, jbegin_count) ;
+    allow_flush_page_lock(inode->i_sb, bh_result->b_page, inode) ;
     unlock_kernel() ;
     reiserfs_check_path(&path) ;
     return retval;
@@ -917,76 +791,59 @@ static void init_inode (struct inode * i
 
 
     copy_key (INODE_PKEY (inode), &(ih->ih_key));
-    inode->i_blksize = PAGE_SIZE;
+    inode->i_generation = INODE_PKEY (inode)->k_dir_id;
 
     INIT_LIST_HEAD(&inode->u.reiserfs_i.i_prealloc_list) ;
 
     if (stat_data_v1 (ih)) {
 	struct stat_data_v1 * sd = (struct stat_data_v1 *)B_I_PITEM (bh, ih);
-	unsigned long blocks;
 
-	set_inode_item_key_version (inode, KEY_FORMAT_3_5);
-        set_inode_sd_version (inode, STAT_DATA_V1);
-	inode->i_mode  = sd_v1_mode(sd);
-	inode->i_nlink = sd_v1_nlink(sd);
-	inode->i_uid   = sd_v1_uid(sd);
-	inode->i_gid   = sd_v1_gid(sd);
-	inode->i_size  = sd_v1_size(sd);
-	inode->i_atime = sd_v1_atime(sd);
-	inode->i_mtime = sd_v1_mtime(sd);
-	inode->i_ctime = sd_v1_ctime(sd);
-
-	inode->i_blocks = sd_v1_blocks(sd);
-	inode->i_generation = le32_to_cpu (INODE_PKEY (inode)->k_dir_id);
-	blocks = (inode->i_size + 511) >> 9;
-	blocks = _ROUND_UP (blocks, inode->i_sb->s_blocksize >> 9);
-	if (inode->i_blocks > blocks) {
-	    // there was a bug in <=3.5.23 when i_blocks could take negative
-	    // values. Starting from 3.5.17 this value could even be stored in
-	    // stat data. For such files we set i_blocks based on file
-	    // size. Just 2 notes: this can be wrong for sparce files. On-disk value will be
-	    // only updated if file's inode will ever change
-	    inode->i_blocks = blocks;
-	}
-
-        rdev = sd_v1_rdev(sd);
-	inode->u.reiserfs_i.i_first_direct_byte = sd_v1_first_direct_byte(sd);
-	/* nopack is initially zero for v1 objects. For v2 objects,
-	   nopack is initialised from sd_attrs */
-	inode->u.reiserfs_i.i_flags &= ~i_nopack_mask;
+	inode_items_version (inode) = ITEM_VERSION_1;
+	//version = ITEM_VERSION_1;
+	inode->i_mode = le16_to_cpu (sd->sd_mode);
+	inode->i_nlink = le16_to_cpu (sd->sd_nlink);
+	inode->i_uid = le16_to_cpu (sd->sd_uid);
+	inode->i_gid = le16_to_cpu (sd->sd_gid);
+	inode->i_size = le32_to_cpu (sd->sd_size);
+	inode->i_atime = le32_to_cpu (sd->sd_atime);
+	inode->i_mtime = le32_to_cpu (sd->sd_mtime);
+	inode->i_ctime = le32_to_cpu (sd->sd_ctime);
+	inode->i_blocks = le32_to_cpu (sd->u.sd_blocks);
+	if (!inode->i_blocks)
+	    // files created by <=3.5.16 have 0 here. Calculate
+	    // i_blocks using i_size (this gives incorrect value for
+	    // files with holes)
+	    inode->i_blocks = (inode->i_size + 511) >> 9;
+	rdev = le32_to_cpu (sd->u.sd_rdev);
+	inode->u.reiserfs_i.i_first_direct_byte = le32_to_cpu (sd->sd_first_direct_byte);
     } else {
 	// new stat data found, but object may have old items
 	// (directories and symlinks)
 	struct stat_data * sd = (struct stat_data *)B_I_PITEM (bh, ih);
 
-	inode->i_mode   = sd_v2_mode(sd);
-	inode->i_nlink  = sd_v2_nlink(sd);
-	inode->i_uid    = sd_v2_uid(sd);
-	inode->i_size   = sd_v2_size(sd);
-	inode->i_gid    = sd_v2_gid(sd);
-	inode->i_mtime  = sd_v2_mtime(sd);
-	inode->i_atime  = sd_v2_atime(sd);
-	inode->i_ctime  = sd_v2_ctime(sd);
-	inode->i_blocks = sd_v2_blocks(sd);
-        rdev            = sd_v2_rdev(sd);
-	if( S_ISCHR( inode -> i_mode ) || S_ISBLK( inode -> i_mode ) )
-	    inode->i_generation = le32_to_cpu (INODE_PKEY (inode)->k_dir_id);
+	/* both old and new directories have old keys */
+	//version = (S_ISDIR (sd->sd_mode) ? ITEM_VERSION_1 : ITEM_VERSION_2);
+	if (S_ISDIR (sd->sd_mode) || S_ISLNK (sd->sd_mode))
+	    inode_items_version (inode) = ITEM_VERSION_1;
 	else
-            inode->i_generation = sd_v2_generation(sd);
-
-	if (S_ISDIR (inode->i_mode) || S_ISLNK (inode->i_mode))
-	    set_inode_item_key_version (inode, KEY_FORMAT_3_5);
+	    inode_items_version (inode) = ITEM_VERSION_2;
+	inode->i_mode = le16_to_cpu (sd->sd_mode);
+	inode->i_nlink = le32_to_cpu (sd->sd_nlink);
+	inode->i_uid = le32_to_cpu (sd->sd_uid);
+	inode->i_size = le64_to_cpu (sd->sd_size);
+	inode->i_gid = le32_to_cpu (sd->sd_gid);
+	inode->i_mtime = le32_to_cpu (sd->sd_mtime);
+	inode->i_atime = le32_to_cpu (sd->sd_atime);
+	inode->i_ctime = le32_to_cpu (sd->sd_ctime);
+	inode->i_blksize = inode->i_sb->s_blocksize;
+	inode->i_blocks = le32_to_cpu (sd->sd_blocks);
+	rdev = le32_to_cpu (sd->u.sd_rdev);
+	if( S_ISCHR( inode -> i_mode ) || S_ISBLK( inode -> i_mode ) )
+	    inode->i_generation = INODE_PKEY (inode)->k_dir_id;
 	else
-            set_inode_item_key_version (inode, KEY_FORMAT_3_6);
-
-        set_inode_sd_version (inode, STAT_DATA_V2);
-	/* read persistent inode attributes from sd and initalise
-	   generic inode flags from them */
-	inode -> u.reiserfs_i.i_attrs = sd_v2_attrs( sd );
-	sd_attrs_to_i_attrs( sd_v2_attrs( sd ), inode );
+	    inode->i_generation = le32_to_cpu( sd->u.sd_generation );
     }
 
-
     pathrelse (path);
     if (S_ISREG (inode->i_mode)) {
 	inode->i_op = &reiserfs_file_inode_operations;
@@ -1002,6 +859,9 @@ static void init_inode (struct inode * i
 	inode->i_blocks = 0;
 	init_special_inode(inode, inode->i_mode, rdev) ;
     }
+
+    //inode_items_version (inode) = version;
+
 }
 
 
@@ -1093,7 +953,6 @@ void reiserfs_update_sd (struct reiserfs
     make_cpu_key (&key, inode, SD_OFFSET, TYPE_STAT_DATA, 3);//key type is unimportant
     
     for(;;) {
-	int pos;
 	/* look for the object's stat data */
 	retval = search_item (inode->i_sb, &key, &path);
 	if (retval == IO_ERROR) {
@@ -1103,7 +962,6 @@ void reiserfs_update_sd (struct reiserfs
 	    return;
 	}
 	if (retval == ITEM_NOT_FOUND) {
-	    pos = PATH_LAST_POSITION (&path);
 	    pathrelse(&path) ;
 	    if (inode->i_nlink == 0) {
 		/*printk ("vs-13050: reiserfs_update_sd: i_nlink == 0, stat data not found\n");*/
@@ -1111,7 +969,7 @@ void reiserfs_update_sd (struct reiserfs
 	    }
 	    reiserfs_warning ("vs-13060: reiserfs_update_sd: "
 			      "stat data of object %k (nlink == %d) not found (pos %d)\n", 
-			      INODE_PKEY (inode), inode->i_nlink, pos);
+			      INODE_PKEY (inode), inode->i_nlink);
 	    reiserfs_check_path(&path) ;
 	    return;
 	}
@@ -1157,11 +1015,6 @@ void reiserfs_read_inode2 (struct inode 
     unsigned long dirino;
     int retval;
 
-    if (!p) {
-	make_bad_inode(inode) ;
-	return;
-    }
-
     dirino = args->objectid ;
 
     /* set version 1, version 2 could be used too, because stat data
@@ -1374,34 +1227,24 @@ int reiserfs_dentry_to_fh(struct dentry 
 //
 /* looks for stat data, then copies fields to it, marks the buffer
    containing stat data as dirty */
-/* reiserfs inodes are never really dirty, since the dirty inode call
-** always logs them.  This call allows the VFS inode marking routines
-** to properly mark inodes for datasync and such, but only actually
-** does something when called for a synchronous update.
-*/
 void reiserfs_write_inode (struct inode * inode, int do_sync) {
+    int windex ;
     struct reiserfs_transaction_handle th ;
-    int jbegin_count = 1 ;
+    int jbegin_count = JOURNAL_PER_BALANCE_CNT * 3; 
 
-    if (inode->i_sb->s_flags & MS_RDONLY) {
-        reiserfs_warning("clm-6005: writing inode %lu on readonly FS\n", 
-	                  inode->i_ino) ;
-        return ;
-    }
-    /* memory pressure can sometimes initiate write_inode calls with sync == 1,
-    ** these cases are just when the system needs ram, not when the 
-    ** inode needs to reach disk for safety, and they can safely be
-    ** ignored because the altered inode has already been logged.
-    */
-    if (do_sync && !(current->flags & PF_MEMALLOC)) {
-	lock_kernel() ;
-	journal_begin(&th, inode->i_sb, jbegin_count) ;
-	reiserfs_update_sd (&th, inode);
+    lock_kernel() ;
+    journal_begin(&th, inode->i_sb, jbegin_count) ;
+    windex = push_journal_writer("write_inode") ;
+    reiserfs_update_sd (&th, inode);
+    pop_journal_writer(windex) ;
+    if (do_sync) 
 	journal_end_sync(&th, inode->i_sb, jbegin_count) ;
-	unlock_kernel() ;
-    }
+    else
+	journal_end(&th, inode->i_sb, jbegin_count) ;
+    unlock_kernel() ;
 }
 
+
 /* FIXME: no need any more. right? */
 int reiserfs_sync_inode (struct reiserfs_transaction_handle *th, struct inode * inode)
 {
@@ -1613,6 +1456,7 @@ struct inode * reiserfs_new_inode (struc
     inode->i_ino = le32_to_cpu (ih.ih_key.k_objectid);
     inode->i_blksize = PAGE_SIZE;
     inode->i_dev = sb->s_dev;
+    inode->i_blksize = sb->s_blocksize;
   
     // store in in-core inode the key of stat data and version all
     // object items will have (directory items will have old offset
@@ -1648,7 +1492,6 @@ struct inode * reiserfs_new_inode (struc
 	retval = reiserfs_new_symlink (th, &ih, &path_to_key, symname, i_size);
     }
     if (retval) {
-      inode->i_nlink = 0;
 	iput (inode);
 	*err = retval;
 	reiserfs_check_path(&path_to_key) ;
@@ -1659,387 +1502,31 @@ struct inode * reiserfs_new_inode (struc
     // we do not mark inode dirty: on disk content matches to the
     // in-core one
     reiserfs_check_path(&path_to_key) ;
-
     return inode;
 }
 
-/*
-** finds the tail page in the page cache,
-** reads the last block in.
-**
-** On success, page_result is set to a locked, pinned page, and bh_result
-** is set to an up to date buffer for the last block in the file.  returns 0.
-**
-** tail conversion is not done, so bh_result might not be valid for writing
-** check buffer_mapped(bh_result) and bh_result->b_blocknr != 0 before
-** trying to write the block.
-**
-** on failure, nonzero is returned, page_result and bh_result are untouched.
-*/
-static int grab_tail_page(struct inode *p_s_inode, 
-			  struct page **page_result, 
-			  struct buffer_head **bh_result) {
-
-    /* we want the page with the last byte in the file,
-    ** not the page that will hold the next byte for appending
-    */
-    unsigned long index = (p_s_inode->i_size-1) >> PAGE_CACHE_SHIFT ;
-    unsigned long pos = 0 ;
-    unsigned long start = 0 ;
-    unsigned long blocksize = p_s_inode->i_sb->s_blocksize ;
-    unsigned long offset = (p_s_inode->i_size) & (PAGE_CACHE_SIZE - 1) ;
-    struct buffer_head *bh ;
-    struct buffer_head *head ;
-    struct page * page ;
-    int error ;
-    
-    /* we know that we are only called with inode->i_size > 0.
-    ** we also know that a file tail can never be as big as a block
-    ** If i_size % blocksize == 0, our file is currently block aligned
-    ** and it won't need converting or zeroing after a truncate.
-    */
-    if ((offset & (blocksize - 1)) == 0) {
-        return -ENOENT ;
-    }
-    page = grab_cache_page(p_s_inode->i_mapping, index) ;
-    error = -ENOMEM ;
-    if (!page) {
-        goto out ;
-    }
-    /* start within the page of the last block in the file */
-    start = (offset / blocksize) * blocksize ;
-
-    error = block_prepare_write(page, start, offset, 
-				reiserfs_get_block_create_0) ;
-    if (error)
-	goto unlock ;
-
-    kunmap(page) ; /* mapped by block_prepare_write */
-
-    head = page->buffers ;      
-    bh = head;
-    do {
-	if (pos >= start) {
-	    break ;
-	}
-	bh = bh->b_this_page ;
-	pos += blocksize ;
-    } while(bh != head) ;
-
-    if (!buffer_uptodate(bh)) {
-	/* note, this should never happen, prepare_write should
-	** be taking care of this for us.  If the buffer isn't up to date,
-	** I've screwed up the code to find the buffer, or the code to
-	** call prepare_write
-	*/
-	reiserfs_warning("clm-6000: error reading block %lu on dev %s\n",
-	                  bh->b_blocknr, kdevname(bh->b_dev)) ;
-	error = -EIO ;
-	goto unlock ;
-    }
-    *bh_result = bh ;
-    *page_result = page ;
-
-out:
-    return error ;
-
-unlock:
-    UnlockPage(page) ;
-    page_cache_release(page) ;
-    return error ;
-}
-
-/*
-** vfs version of truncate file.  Must NOT be called with
-** a transaction already started.
-**
-** some code taken from block_truncate_page
-*/
-void reiserfs_truncate_file(struct inode *p_s_inode, int update_timestamps) {
-    struct reiserfs_transaction_handle th ;
-    int windex ;
-
-    /* we want the offset for the first byte after the end of the file */
-    unsigned long offset = p_s_inode->i_size & (PAGE_CACHE_SIZE - 1) ;
-    unsigned blocksize = p_s_inode->i_sb->s_blocksize ;
-    unsigned length ;
-    struct page *page = NULL ;
-    int error ;
-    struct buffer_head *bh = NULL ;
-
-    if (p_s_inode->i_size > 0) {
-        if ((error = grab_tail_page(p_s_inode, &page, &bh))) {
-	    // -ENOENT means we truncated past the end of the file, 
-	    // and get_block_create_0 could not find a block to read in,
-	    // which is ok.
-	    if (error != -ENOENT)
-	        reiserfs_warning("clm-6001: grab_tail_page failed %d\n", error);
-	    page = NULL ;
-	    bh = NULL ;
-	}
-    }
-
-    /* so, if page != NULL, we have a buffer head for the offset at 
-    ** the end of the file. if the bh is mapped, and bh->b_blocknr != 0, 
-    ** then we have an unformatted node.  Otherwise, we have a direct item, 
-    ** and no zeroing is required on disk.  We zero after the truncate, 
-    ** because the truncate might pack the item anyway 
-    ** (it will unmap bh if it packs).
-    */
-    /* it is enough to reserve space in transaction for 2 balancings:
-       one for "save" link adding and another for the first
-       cut_from_item. 1 is for update_sd */
-    journal_begin(&th, p_s_inode->i_sb,  JOURNAL_PER_BALANCE_CNT * 2 + 1 ) ;
-    reiserfs_update_inode_transaction(p_s_inode) ;
-    windex = push_journal_writer("reiserfs_vfs_truncate_file") ;
-    if (update_timestamps)
-           /* we are doing real truncate: if the system crashes before the last
-              transaction of truncating gets committed - on reboot the file
-              either appears truncated properly or not truncated at all */
-           add_save_link (&th, p_s_inode, 1);
-    reiserfs_do_truncate (&th, p_s_inode, page, update_timestamps) ;
-    pop_journal_writer(windex) ;
-    journal_end(&th, p_s_inode->i_sb,  JOURNAL_PER_BALANCE_CNT * 2 + 1 ) ;
-
-    if (update_timestamps)
-       remove_save_link (p_s_inode, 1/* truncate */);
-
-    if (page) {
-        length = offset & (blocksize - 1) ;
-	/* if we are not on a block boundary */
-	if (length) {
-	    length = blocksize - length ;
-	    memset((char *)kmap(page) + offset, 0, length) ;   
-	    flush_dcache_page(page) ;
-	    kunmap(page) ;
-	    if (buffer_mapped(bh) && bh->b_blocknr != 0) {
-	        mark_buffer_dirty(bh) ;
-	    }
-	}
-	UnlockPage(page) ;
-	page_cache_release(page) ;
-    }
-
-    return ;
-}
-
-static int map_block_for_writepage(struct inode *inode, 
-			       struct buffer_head *bh_result, 
-                               unsigned long block) {
-    struct reiserfs_transaction_handle th ;
-    int fs_gen ;
-    struct item_head tmp_ih ;
-    struct item_head *ih ;
-    struct buffer_head *bh ;
-    __u32 *item ;
-    struct cpu_key key ;
-    INITIALIZE_PATH(path) ;
-    int pos_in_item ;
-    int jbegin_count = JOURNAL_PER_BALANCE_CNT ;
-    loff_t byte_offset = (block << inode->i_sb->s_blocksize_bits) + 1 ;
-    int retval ;
-    int use_get_block = 0 ;
-    int bytes_copied = 0 ;
-    int copy_size ;
-
-    kmap(bh_result->b_page) ;
-start_over:
-    lock_kernel() ;
-    journal_begin(&th, inode->i_sb, jbegin_count) ;
-    reiserfs_update_inode_transaction(inode) ;
-
-    make_cpu_key(&key, inode, byte_offset, TYPE_ANY, 3) ;
-
-research:
-    retval = search_for_position_by_key(inode->i_sb, &key, &path) ;
-    if (retval != POSITION_FOUND) {
-        use_get_block = 1;
-	goto out ;
-    } 
-
-    bh = get_last_bh(&path) ;
-    ih = get_ih(&path) ;
-    item = get_item(&path) ;
-    pos_in_item = path.pos_in_item ;
-
-    /* we've found an unformatted node */
-    if (indirect_item_found(retval, ih)) {
-	if (bytes_copied > 0) {
-	    reiserfs_warning("clm-6002: bytes_copied %d\n", bytes_copied) ;
-	}
-        if (!get_block_num(item, pos_in_item)) {
-	    /* crap, we are writing to a hole */
-	    use_get_block = 1;
-	    goto out ;
-	}
-	set_block_dev_mapped(bh_result, get_block_num(item,pos_in_item),inode);
-        mark_buffer_uptodate(bh_result, 1);
-    } else if (is_direct_le_ih(ih)) {
-        char *p ; 
-        p = page_address(bh_result->b_page) ;
-        p += (byte_offset -1) & (PAGE_CACHE_SIZE - 1) ;
-        copy_size = ih_item_len(ih) - pos_in_item;
-
-	fs_gen = get_generation(inode->i_sb) ;
-	copy_item_head(&tmp_ih, ih) ;
-	reiserfs_prepare_for_journal(inode->i_sb, bh, 1) ;
-	if (fs_changed (fs_gen, inode->i_sb) && item_moved (&tmp_ih, &path)) {
-	    reiserfs_restore_prepared_buffer(inode->i_sb, bh) ;
-	    goto research;
-	}
-
-	memcpy( B_I_PITEM(bh, ih) + pos_in_item, p + bytes_copied, copy_size) ;
-
-	journal_mark_dirty(&th, inode->i_sb, bh) ;
-	bytes_copied += copy_size ;
-	set_block_dev_mapped(bh_result, 0, inode);
-        mark_buffer_uptodate(bh_result, 1);
-
-	/* are there still bytes left? */
-        if (bytes_copied < bh_result->b_size && 
-	    (byte_offset + bytes_copied) < inode->i_size) {
-	    set_cpu_key_k_offset(&key, cpu_key_k_offset(&key) + copy_size) ;
-	    goto research ;
-	}
-    } else {
-        reiserfs_warning("clm-6003: bad item inode %lu, device %s\n", inode->i_ino, kdevname(inode->i_sb->s_dev)) ;
-        retval = -EIO ;
-	goto out ;
-    }
-    retval = 0 ;
-    
-out:
-    pathrelse(&path) ;
-    journal_end(&th, inode->i_sb, jbegin_count) ;
-    unlock_kernel() ;
-
-    /* this is where we fill in holes in the file. */
-    if (use_get_block) {
-	retval = reiserfs_get_block(inode, block, bh_result, 
-	                            GET_BLOCK_CREATE | GET_BLOCK_NO_ISEM) ;
-	if (!retval) {
-	    if (!buffer_mapped(bh_result) || bh_result->b_blocknr == 0) {
-	        /* get_block failed to find a mapped unformatted node. */
-		use_get_block = 0 ;
-		goto start_over ;
-	    }
-	}
-    }
-    kunmap(bh_result->b_page) ;
-    return retval ;
-}
-
-/* helper func to get a buffer head ready for writepage to send to
-** ll_rw_block
+/* If this page has a file tail in it, and
+** it was read in by get_block_create_0, the page data is valid,
+** but tail is still sitting in a direct item, and we can't write to
+** it.  So, look through this page, and check all the mapped buffers
+** to make sure they have valid block numbers.  Any that don't need
+** to be unmapped, so that block_prepare_write will correctly call
+** reiserfs_get_block to convert the tail into an unformatted node
 */
-static inline void submit_bh_for_writepage(struct buffer_head **bhp, int nr) {
-    struct buffer_head *bh ;
-    int i;
-
-    /* lock them all first so the end_io handler doesn't unlock the page
-    ** too early
-    */
-    for(i = 0 ; i < nr ; i++) {
-        bh = bhp[i] ;
-	lock_buffer(bh) ;
-	set_buffer_async_io(bh) ;
-    }
-    for(i = 0 ; i < nr ; i++) {
-	/* submit_bh doesn't care if the buffer is dirty, but nobody
-	** later on in the call chain will be cleaning it.  So, we
-	** clean the buffer here, it still gets written either way.
-	*/
-        bh = bhp[i] ;
-	clear_bit(BH_Dirty, &bh->b_state) ;
-	set_bit(BH_Uptodate, &bh->b_state) ;
-	submit_bh(WRITE, bh) ;
-    }
-}
+static inline void fix_tail_page_for_writing(struct page *page) {
+    struct buffer_head *head, *next, *bh ;
 
-static int reiserfs_write_full_page(struct page *page) {
-    struct inode *inode = page->mapping->host ;
-    unsigned long end_index = inode->i_size >> PAGE_CACHE_SHIFT ;
-    unsigned last_offset = PAGE_CACHE_SIZE;
-    int error = 0;
-    unsigned long block ;
-    unsigned cur_offset = 0 ;
-    struct buffer_head *head, *bh ;
-    int partial = 0 ;
-    struct buffer_head *arr[PAGE_CACHE_SIZE/512] ;
-    int nr = 0 ;
-
-    if (!page->buffers) {
-        block_prepare_write(page, 0, 0, NULL) ;
-	kunmap(page) ;
-    }
-    /* last page in the file, zero out any contents past the
-    ** last byte in the file
-    */
-    if (page->index >= end_index) {
-        last_offset = inode->i_size & (PAGE_CACHE_SIZE - 1) ;
-	/* no file contents in this page */
-	if (page->index >= end_index + 1 || !last_offset) {
-	    error =  -EIO ;
-	    goto fail ;
-	}
-	memset((char *)kmap(page)+last_offset, 0, PAGE_CACHE_SIZE-last_offset) ;
-	flush_dcache_page(page) ;
-	kunmap(page) ;
-    }
-    head = page->buffers ;
-    bh = head ;
-    block = page->index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits) ;
-    do {
-	/* if this offset in the page is outside the file */
-	if (cur_offset >= last_offset) {
-	    if (!buffer_uptodate(bh))
-	        partial = 1 ;
-	} else {
-	    /* fast path, buffer mapped to an unformatted node */
-	    if (buffer_mapped(bh) && bh->b_blocknr != 0) {
-		arr[nr++] = bh ;
-	    } else {
-		/* buffer not mapped yet, or points to a direct item.
-		** search and dirty or log
-		*/
-		if ((error = map_block_for_writepage(inode, bh, block))) {
-		    goto fail ;
-		}
-		/* map_block_for_writepage either found an unformatted node
-		** and mapped it for us, or it found a direct item
-		** and logged the changes.  
-		*/
-		if (buffer_mapped(bh) && bh->b_blocknr != 0) {
-		    arr[nr++] = bh ;
-		}
+    if (page && page->buffers) {
+	head = page->buffers ;
+	bh = head ;
+	do {
+	    next = bh->b_this_page ;
+	    if (buffer_mapped(bh) && bh->b_blocknr == 0) {
+	        reiserfs_unmap_buffer(bh) ;
 	    }
-	}
-        bh = bh->b_this_page ;
-	cur_offset += bh->b_size ;
-	block++ ;
-    } while(bh != head) ;
-
-    /* if this page only had a direct item, it is very possible for
-    ** nr == 0 without there being any kind of error.
-    */
-    if (nr) {
-        submit_bh_for_writepage(arr, nr) ;
-    } else {
-        UnlockPage(page) ;
-    }
-    if (!partial)
-        SetPageUptodate(page) ;
-
-    return 0 ;
-
-fail:
-    if (nr) {
-        submit_bh_for_writepage(arr, nr) ;
-    } else {
-        UnlockPage(page) ;
+	    bh = next ;
+	} while (bh != head) ;
     }
-    ClearPageUptodate(page) ;
-    return error ;
 }
 
 //
@@ -2052,23 +1539,19 @@ static int reiserfs_readpage (struct fil
 
 
 //
-// modified from ext2_writepage is
+// this is exactly what 2.3.99-pre9's ext2_writepage is
 //
-static int reiserfs_writepage (struct page * page)
+static int reiserfs_writepage (struct file *f, struct page * page)
 {
-    struct inode *inode = page->mapping->host ;
-    reiserfs_wait_on_write_block(inode->i_sb) ;
-    return reiserfs_write_full_page(page) ;
+    fix_tail_page_for_writing(page) ;
+    return block_write_full_page (page, reiserfs_get_block);
 }
 
 
 //
 // from ext2_prepare_write, but modified
 //
-int reiserfs_prepare_write(struct file *f, struct page *page, 
-			   unsigned from, unsigned to) {
-    struct inode *inode = page->mapping->host ;
-    reiserfs_wait_on_write_block(inode->i_sb) ;
+static int reiserfs_prepare_write(struct file *f, struct page *page, unsigned from, unsigned to) {
     fix_tail_page_for_writing(page) ;
     return block_prepare_write(page, from, to, reiserfs_get_block) ;
 }
@@ -2081,100 +1564,30 @@ static int reiserfs_aop_bmap(struct addr
   return generic_block_bmap(as, block, reiserfs_bmap) ;
 }
 
+
 static int reiserfs_commit_write(struct file *f, struct page *page, 
                                  unsigned from, unsigned to) {
-    struct inode *inode = page->mapping->host ;
-    loff_t pos = ((loff_t)page->index << PAGE_CACHE_SHIFT) + to;
-    int ret ; 
-    
-    reiserfs_wait_on_write_block(inode->i_sb) ;
- 
-    /* generic_commit_write does this for us, but does not update the
-    ** transaction tracking stuff when the size changes.  So, we have
-    ** to do the i_size updates here.
-    */
-    if (pos > inode->i_size) {
-	struct reiserfs_transaction_handle th ;
-	lock_kernel() ;
-	journal_begin(&th, inode->i_sb, 1) ;
-	reiserfs_update_inode_transaction(inode) ;
-	inode->i_size = pos ;
-	reiserfs_update_sd(&th, inode) ;
-	journal_end(&th, inode->i_sb, 1) ;
-	unlock_kernel() ;
-    }
- 
-    ret = generic_commit_write(f, page, from, to) ;
+    struct inode *inode = (struct inode *)(page->mapping->host) ;
+    loff_t pos = inode->i_size ;
+    int ret = generic_commit_write(f, page, from, to) ;
 
-    /* we test for O_SYNC here so we can commit the transaction
-    ** for any packed tails the file might have had
+    /* ok, generic_commit_write might change the inode's sizes
+    ** this change will be lost if we don't dirty the inode
     */
-    if (f && (f->f_flags & O_SYNC)) {
-	lock_kernel() ;
- 	reiserfs_commit_for_inode(inode) ;
-	unlock_kernel();
+    if (pos != inode->i_size) {
+	prevent_flush_page_lock(inode->i_sb, page, inode) ;
+	reiserfs_write_inode(inode, 0) ;
+	allow_flush_page_lock(inode->i_sb, page, inode) ;
     }
-    return ret ;
-}
 
-void sd_attrs_to_i_attrs( __u16 sd_attrs, struct inode *inode )
-{
-	if( reiserfs_attrs( inode -> i_sb ) ) {
-		if( sd_attrs & REISERFS_SYNC_FL )
-			inode -> i_flags |= S_SYNC;
-		else
-			inode -> i_flags &= ~S_SYNC;
-		if( sd_attrs & REISERFS_IMMUTABLE_FL )
-			inode -> i_flags |= S_IMMUTABLE;
-		else
-			inode -> i_flags &= ~S_IMMUTABLE;
-		if( sd_attrs & REISERFS_NOATIME_FL )
-			inode -> i_flags |= S_NOATIME;
-		else
-			inode -> i_flags &= ~S_NOATIME;
-		if( sd_attrs & REISERFS_NOTAIL_FL )
-			inode->u.reiserfs_i.i_flags |= i_nopack_mask;
-		else
-			inode->u.reiserfs_i.i_flags &= ~i_nopack_mask;
-	}
-}
-
-void i_attrs_to_sd_attrs( struct inode *inode, __u16 *sd_attrs )
-{
-	if( reiserfs_attrs( inode -> i_sb ) ) {
-		if( inode -> i_flags & S_IMMUTABLE )
-			*sd_attrs |= REISERFS_IMMUTABLE_FL;
-		else
-			*sd_attrs &= ~REISERFS_IMMUTABLE_FL;
-		if( inode -> i_flags & S_SYNC )
-			*sd_attrs |= REISERFS_SYNC_FL;
-		else
-			*sd_attrs &= ~REISERFS_SYNC_FL;
-		if( inode -> i_flags & S_NOATIME )
-			*sd_attrs |= REISERFS_NOATIME_FL;
-		else
-			*sd_attrs &= ~REISERFS_NOATIME_FL;
-		if( inode->u.reiserfs_i.i_flags & i_nopack_mask )
-			*sd_attrs |= REISERFS_NOTAIL_FL;
-		else
-			*sd_attrs &= ~REISERFS_NOTAIL_FL;
-	}
-}
+    return ret ;
 
-static int reiserfs_direct_io(int rw, struct inode *inode, 
-                              struct kiobuf *iobuf, unsigned long blocknr,
-			      int blocksize) 
-{
-    return generic_direct_IO(rw, inode, iobuf, blocknr, blocksize,
-                             reiserfs_get_block_direct_io) ;
 }
-
 struct address_space_operations reiserfs_address_space_operations = {
     writepage: reiserfs_writepage,
     readpage: reiserfs_readpage, 
     sync_page: block_sync_page,
     prepare_write: reiserfs_prepare_write,
     commit_write: reiserfs_commit_write,
-    bmap: reiserfs_aop_bmap,
-    direct_IO: reiserfs_direct_io,
+    bmap: reiserfs_aop_bmap
 } ;
diff -urp linux/fs/reiserfs/item_ops.c new_kernel_src/fs/reiserfs/item_ops.c
--- linux/fs/reiserfs/item_ops.c	2009-06-10 21:00:37.000000000 +0100
+++ new_kernel_src/fs/reiserfs/item_ops.c	2002-03-25 03:10:33.000000000 +0000
@@ -1,15 +1,22 @@
 /*
- * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README
+ * Copyright 2000 Hans Reiser, see reiserfs/README for licensing and copyright details
  */
 
+#ifdef __KERNEL__
+
 #include <linux/sched.h>
 #include <linux/reiserfs_fs.h>
 
-// this contains item handlers for old item types: sd, direct,
+#else
+
+#include "nokernel.h"
+
+#endif
+
+
+// this conatins item hadlers for old item types: sd, direct,
 // indirect, directory
 
-/* and where are the comments? how about saying where we can find an
-   explanation of each item handler method? -Hans */
 
 //////////////////////////////////////////////////////////////////////////////
 // stat data functions
@@ -22,8 +29,6 @@ static int sd_bytes_number (struct item_
 static void sd_decrement_key (struct cpu_key * key)
 {
     key->on_disk_key.k_objectid --;
-    set_cpu_key_k_type (key, TYPE_ANY);
-    set_cpu_key_k_offset(key, (loff_t)(-1));
 }
 
 static int sd_is_left_mergeable (struct key * key, unsigned long bsize)
@@ -48,15 +53,13 @@ static void sd_print_item (struct item_h
     if (stat_data_v1 (ih)) {
       	struct stat_data_v1 * sd = (struct stat_data_v1 *)item;
 
-	printk ("\t0%-6o | %6u | %2u | %d | %s\n", sd_v1_mode(sd),
-                sd_v1_size(sd), sd_v1_nlink(sd), sd_v1_first_direct_byte(sd),
-                print_time( sd_v1_mtime(sd) ) );
+	printk ("\t0%-6o | %6u | %2u | %d | %s\n", sd->sd_mode, sd->sd_size,
+		sd->sd_nlink, sd->sd_first_direct_byte, print_time (sd->sd_mtime));
     } else {
 	struct stat_data * sd = (struct stat_data *)item;
 
-	printk ("\t0%-6o | %6Lu | %2u | %d | %s\n", sd_v2_mode(sd),
-            (unsigned long long)sd_v2_size(sd), sd_v2_nlink(sd),
-            sd_v2_rdev(sd), print_time(sd_v2_mtime(sd)));
+	printk ("\t0%-6o | %6Lu | %2u | %d | %s\n", sd->sd_mode, sd->sd_size,
+		sd->sd_nlink, sd->u.sd_rdev, print_time (sd->sd_mtime));
     }
 }
 
@@ -301,14 +304,14 @@ static void indirect_print_item (struct 
 
     unp = (__u32 *)item;
 
-    if (ih_item_len(ih) % UNFM_P_SIZE)
+    if (ih->ih_item_len % UNFM_P_SIZE)
 	printk ("indirect_print_item: invalid item len");  
 
-    printk ("%d pointers\n[ ", (int)I_UNFM_NUM (ih));
+    printk ("%d pointers\n[ ", I_UNFM_NUM (ih));
     for (j = 0; j < I_UNFM_NUM (ih); j ++) {
-	if (sequence_finished (prev, &num, get_block_num(unp, j))) {
+	if (sequence_finished (prev, &num, unp[j])) {
 	    print_sequence (prev, num);
-	    start_new_sequence (&prev, &num, get_block_num(unp, j));
+	    start_new_sequence (&prev, &num, unp[j]);
 	}
     }
     print_sequence (prev, num);
@@ -348,7 +351,7 @@ static int indirect_check_right (struct 
 
 
 
-// return size in bytes of 'units' units. If first == 0 - calculate from the head (left), otherwise - from tail (right)
+// return size in bytes of 'units' units. If first == 0 - calculate from the head, othewise - form tail
 static int indirect_part_size (struct virtual_item * vi, int first, int units)
 {
     // unit of indirect item is byte (yet)
@@ -519,7 +522,6 @@ static int direntry_create_vi (struct vi
 	BUG ();
 
 
-    dir_u->flags = 0;
     if (le_ih_k_offset (vi->vi_ih) == DOT_OFFSET)
 	dir_u->flags |= DIRENTRY_VI_FIRST_DIRENTRY_ITEM;
 
@@ -660,8 +662,8 @@ static void direntry_print_vi (struct vi
     int i;
     struct direntry_uarea * dir_u = vi->vi_uarea;
 
-    reiserfs_warning ("DIRENTRY, index %d, type 0x%x, %h, flags 0x%x\n", 
-		      vi->vi_index, vi->vi_type, vi->vi_ih, dir_u->flags);
+    reiserfs_warning ("DIRENTRY, index %d, type 0x%x, %h\n", 
+		      vi->vi_index, vi->vi_type, vi->vi_ih);
     printk ("%d entries: ", dir_u->entry_count);
     for (i = 0; i < dir_u->entry_count; i ++)
 	printk ("%d ", dir_u->entry_sizes[i]);
diff -urp linux/fs/reiserfs/journal.c new_kernel_src/fs/reiserfs/journal.c
--- linux/fs/reiserfs/journal.c	2009-06-10 21:00:37.000000000 +0100
+++ new_kernel_src/fs/reiserfs/journal.c	2002-03-25 03:10:33.000000000 +0000
@@ -1,6 +1,7 @@
 /*
 ** Write ahead logging implementation copyright Chris Mason 2000
 **
+**
 ** The background commits make this code very interelated, and 
 ** overly complex.  I need to rethink things a bit....The major players:
 **
@@ -41,7 +42,8 @@
 **                      log blocks to hit disk if it doesn't want to.
 */
 
-#include <linux/config.h>
+#ifdef __KERNEL__
+
 #include <asm/uaccess.h>
 #include <asm/system.h>
 
@@ -69,7 +71,15 @@ DECLARE_WAIT_QUEUE_HEAD(reiserfs_commit_
 
 /* wait on this if you need to be sure you task queue entries have been run */
 static DECLARE_WAIT_QUEUE_HEAD(reiserfs_commit_thread_done) ;
+
+/* task queue for async commits, and for the end_io tasks that can't
+** be done with interrupts turned off
+**
+** tasks put on this queue will be run by the commit thread
+*/
 DECLARE_TASK_QUEUE(reiserfs_commit_thread_tq) ;
+DECLARE_TASK_QUEUE(reiserfs_end_io_tq) ;
+DECLARE_MUTEX(reiserfs_end_io_sem) ;
 
 #define JOURNAL_TRANS_HALF 1018   /* must be correct to keep the desc and commit
 				     structs at 4k */
@@ -87,15 +97,10 @@ DECLARE_TASK_QUEUE(reiserfs_commit_threa
 #define COMMIT_NOW  2		/* end and commit this transaction */
 #define WAIT        4		/* wait for the log blocks to hit the disk*/
 
-/* state bits for the journal */
-#define WRITERS_BLOCKED 1      /* set when new writers not allowed */
-
 static int do_journal_end(struct reiserfs_transaction_handle *,struct super_block *,unsigned long nblocks,int flags) ;
-static int flush_journal_list(struct super_block *s, struct reiserfs_journal_list *jl, int flushall) ;
+static void dirty_journal_list(struct super_block *p_s_sb, struct reiserfs_journal_list *jl) ;
+static int flush_journal_list(struct super_block *s, struct reiserfs_journal_list *jl, int old_only,int flushall) ;
 static int flush_commit_list(struct super_block *s, struct reiserfs_journal_list *jl, int flushall)  ;
-static int can_dirty(struct reiserfs_journal_cnode *cn) ;
-static int remove_from_journal_list(struct super_block *s, struct reiserfs_journal_list *jl, struct buffer_head *bh, int remove_freed);
-static int journal_join(struct reiserfs_transaction_handle *th, struct super_block *p_s_sb, unsigned long nblocks);
 
 static void init_journal_hash(struct super_block *p_s_sb) {
   memset(SB_JOURNAL(p_s_sb)->j_hash_table, 0, JOURNAL_HASH_SIZE * sizeof(struct reiserfs_journal_cnode *)) ;
@@ -114,169 +119,52 @@ static int reiserfs_clean_and_file_buffe
   return 0 ;
 }
 
-static struct reiserfs_bitmap_node *
-allocate_bitmap_node(struct super_block *p_s_sb) {
-  struct reiserfs_bitmap_node *bn ;
-  static int id = 0 ;
-
-  bn = reiserfs_kmalloc(sizeof(struct reiserfs_bitmap_node), GFP_NOFS, p_s_sb) ;
-  if (!bn) {
-    return NULL ;
-  }
-  bn->data = reiserfs_kmalloc(p_s_sb->s_blocksize, GFP_NOFS, p_s_sb) ;
-  if (!bn->data) {
-    reiserfs_kfree(bn, sizeof(struct reiserfs_bitmap_node), p_s_sb) ;
-    return NULL ;
-  }
-  bn->id = id++ ;
-  memset(bn->data, 0, p_s_sb->s_blocksize) ;
-  INIT_LIST_HEAD(&bn->list) ;
-  return bn ;
-}
-
-static struct reiserfs_bitmap_node *
-get_bitmap_node(struct super_block *p_s_sb) {
-  struct reiserfs_bitmap_node *bn = NULL;
-  struct list_head *entry = SB_JOURNAL(p_s_sb)->j_bitmap_nodes.next ;
-
-  SB_JOURNAL(p_s_sb)->j_used_bitmap_nodes++ ;
-repeat:
-
-  if(entry != &SB_JOURNAL(p_s_sb)->j_bitmap_nodes) {
-    bn = list_entry(entry, struct reiserfs_bitmap_node, list) ;
-    list_del(entry) ;
-    memset(bn->data, 0, p_s_sb->s_blocksize) ;
-    SB_JOURNAL(p_s_sb)->j_free_bitmap_nodes-- ;
-    return bn ;
-  }
-  bn = allocate_bitmap_node(p_s_sb) ;
-  if (!bn) {
-    current->policy |= SCHED_YIELD ;
-    schedule() ;
-    goto repeat ;
-  }
-  return bn ;
-}
-static inline void free_bitmap_node(struct super_block *p_s_sb,
-                                    struct reiserfs_bitmap_node *bn) {
-  SB_JOURNAL(p_s_sb)->j_used_bitmap_nodes-- ;
-  if (SB_JOURNAL(p_s_sb)->j_free_bitmap_nodes > REISERFS_MAX_BITMAP_NODES) {
-    reiserfs_kfree(bn->data, p_s_sb->s_blocksize, p_s_sb) ;
-    reiserfs_kfree(bn, sizeof(struct reiserfs_bitmap_node), p_s_sb) ;
-  } else {
-    list_add(&bn->list, &SB_JOURNAL(p_s_sb)->j_bitmap_nodes) ;
-    SB_JOURNAL(p_s_sb)->j_free_bitmap_nodes++ ;
-  }
-}
-
-static void allocate_bitmap_nodes(struct super_block *p_s_sb) {
-  int i ;
-  struct reiserfs_bitmap_node *bn = NULL ;
-  for (i = 0 ; i < REISERFS_MIN_BITMAP_NODES ; i++) {
-    bn = allocate_bitmap_node(p_s_sb) ;
-    if (bn) {
-      list_add(&bn->list, &SB_JOURNAL(p_s_sb)->j_bitmap_nodes) ;
-      SB_JOURNAL(p_s_sb)->j_free_bitmap_nodes++ ;
-    } else {
-      break ; // this is ok, we'll try again when more are needed 
-    }
-  }
-}
-
-static int set_bit_in_list_bitmap(struct super_block *p_s_sb, int block,
-                                  struct reiserfs_list_bitmap *jb) {
-  int bmap_nr = block / (p_s_sb->s_blocksize << 3) ;
-  int bit_nr = block % (p_s_sb->s_blocksize << 3) ;
-
-  if (!jb->bitmaps[bmap_nr]) {
-    jb->bitmaps[bmap_nr] = get_bitmap_node(p_s_sb) ;
-  }
-  set_bit(bit_nr, jb->bitmaps[bmap_nr]->data) ;
-  return 0 ;
-}
-
-static void cleanup_bitmap_list(struct super_block *p_s_sb,
-                                struct reiserfs_list_bitmap *jb) {
-  int i;
-  for (i = 0 ; i < SB_BMAP_NR(p_s_sb) ; i++) {
-    if (jb->bitmaps[i]) {
-      free_bitmap_node(p_s_sb, jb->bitmaps[i]) ;
-      jb->bitmaps[i] = NULL ;
-    }
-  }
-}
-
 /*
 ** only call this on FS unmount.
 */
-static int free_list_bitmaps(struct super_block *p_s_sb,
-                             struct reiserfs_list_bitmap *jb_array) {
+static int free_list_bitmaps(struct super_block *p_s_sb) {
   int i ;
   struct reiserfs_list_bitmap *jb ;
   for (i = 0 ; i < JOURNAL_NUM_BITMAPS ; i++) {
-    jb = jb_array + i ;
+    jb = SB_JOURNAL(p_s_sb)->j_list_bitmap + i ;
     jb->journal_list = NULL ;
-    cleanup_bitmap_list(p_s_sb, jb) ;
-    vfree(jb->bitmaps) ;
-    jb->bitmaps = NULL ;
+    vfree(jb->bitmap) ;
   }
   return 0;
 }
 
-static int free_bitmap_nodes(struct super_block *p_s_sb) {
-  struct list_head *next = SB_JOURNAL(p_s_sb)->j_bitmap_nodes.next ;
-  struct reiserfs_bitmap_node *bn ;
-
-  while(next != &SB_JOURNAL(p_s_sb)->j_bitmap_nodes) {
-    bn = list_entry(next, struct reiserfs_bitmap_node, list) ;
-    list_del(next) ;
-    reiserfs_kfree(bn->data, p_s_sb->s_blocksize, p_s_sb) ;
-    reiserfs_kfree(bn, sizeof(struct reiserfs_bitmap_node), p_s_sb) ;
-    next = SB_JOURNAL(p_s_sb)->j_bitmap_nodes.next ;
-    SB_JOURNAL(p_s_sb)->j_free_bitmap_nodes-- ;
-  }
-
-  return 0 ;
-}
-
 /*
-** get memory for JOURNAL_NUM_BITMAPS worth of bitmaps. 
-** jb_array is the array to be filled in.
+** get memory for JOURNAL_NUM_BITMAPS worth of bitmaps.  ick.
 */
-int reiserfs_allocate_list_bitmaps(struct super_block *p_s_sb,
-                                   struct reiserfs_list_bitmap *jb_array,
-				   int bmap_nr) {
+static int allocate_list_bitmaps(struct super_block *p_s_sb) {
   int i ;
   int failed = 0 ;
   struct reiserfs_list_bitmap *jb ;
-  int mem = bmap_nr * sizeof(struct reiserfs_bitmap_node *) ;
-
   for (i = 0 ; i < JOURNAL_NUM_BITMAPS ; i++) {
-    jb = jb_array + i ;
+    jb = SB_JOURNAL(p_s_sb)->j_list_bitmap + i ;
     jb->journal_list = NULL ;
-    jb->bitmaps = vmalloc( mem ) ;
-    if (!jb->bitmaps) {
-      reiserfs_warning("clm-2000, unable to allocate bitmaps for journal lists\n") ;
+    jb->bitmap = vmalloc( ((SB_BLOCK_COUNT(p_s_sb) / 8) + 1) * sizeof(char)) ;
+    if (!jb->bitmap) {
+      reiserfs_warning("journal-175, unable to allocate bitmaps for journal lists\n") ;
       failed = 1;   
       break ;
     }
-    memset(jb->bitmaps, 0, mem) ;
+    memset(jb->bitmap, 0, ((SB_BLOCK_COUNT(p_s_sb) / 8) + 1) * sizeof(char)) ;
   }
   if (failed) {
-    free_list_bitmaps(p_s_sb, jb_array) ;
+    free_list_bitmaps(p_s_sb) ;
     return -1 ;
   }
   return 0 ;
 }
 
 /*
-** find an available list bitmap.  If you can't find one, flush a commit list 
-** and try again
+** find an available list bitmap.  If you can't find one, flush a commit list and try again
 */
-static struct reiserfs_list_bitmap *
-get_list_bitmap(struct super_block *p_s_sb, struct reiserfs_journal_list *jl) {
+static struct reiserfs_list_bitmap *get_list_bitmap(struct super_block *p_s_sb, struct reiserfs_journal_list *jl) {
   int i,j ; 
   struct reiserfs_list_bitmap *jb = NULL ;
+  int windex = push_journal_writer("get_list_bitmap") ;
 
   for (j = 0 ; j < (JOURNAL_NUM_BITMAPS * 3) ; j++) {
     i = SB_JOURNAL(p_s_sb)->j_list_bitmap_index ;
@@ -292,9 +180,12 @@ get_list_bitmap(struct super_block *p_s_
     }
   }
   if (jb->journal_list) { /* double check to make sure if flushed correctly */
+    pop_journal_writer(windex) ;
     return NULL ;
   }
+  memset(jb->bitmap, 0, ((SB_BLOCK_COUNT(p_s_sb) / 8) + 1) * sizeof(char)) ;
   jb->journal_list = jl ;
+  pop_journal_writer(windex) ;
   return jb ;
 }
 
@@ -329,16 +220,19 @@ static struct reiserfs_journal_cnode *al
 */
 static struct reiserfs_journal_cnode *get_cnode(struct super_block *p_s_sb) {
   struct reiserfs_journal_cnode *cn ;
+  int windex = push_journal_writer("get_cnode") ;
 
   reiserfs_check_lock_depth("get_cnode") ;
 
   if (SB_JOURNAL(p_s_sb)->j_cnode_free <= 0) {
+    pop_journal_writer(windex) ;
     return NULL ;
   }
   SB_JOURNAL(p_s_sb)->j_cnode_used++ ;
   SB_JOURNAL(p_s_sb)->j_cnode_free-- ;
   cn = SB_JOURNAL(p_s_sb)->j_cnode_free_list ;
   if (!cn) {
+    pop_journal_writer(windex) ;
     return cn ;
   }
   if (cn->next) {
@@ -346,6 +240,7 @@ static struct reiserfs_journal_cnode *ge
   }
   SB_JOURNAL(p_s_sb)->j_cnode_free_list = cn->next ;
   memset(cn, 0, sizeof(struct reiserfs_journal_cnode)) ;
+  pop_journal_writer(windex) ;
   return cn ;
 }
 
@@ -353,6 +248,7 @@ static struct reiserfs_journal_cnode *ge
 ** returns a cnode to the free list 
 */
 static void free_cnode(struct super_block *p_s_sb, struct reiserfs_journal_cnode *cn) {
+  int windex = push_journal_writer("free_cnode") ;
 
   reiserfs_check_lock_depth("free_cnode") ;
 
@@ -365,10 +261,12 @@ static void free_cnode(struct super_bloc
   }
   cn->prev = NULL ; /* not needed with the memset, but I might kill the memset, and forget to do this */
   SB_JOURNAL(p_s_sb)->j_cnode_free_list = cn ;
+  pop_journal_writer(windex) ;
 }
 
 static int clear_prepared_bits(struct buffer_head *bh) {
   clear_bit(BH_JPrepared, &bh->b_state) ;
+  clear_bit(BH_JRestore_dirty, &bh->b_state) ;
   return 0 ;
 }
 
@@ -403,15 +301,13 @@ inline int mark_buffer_not_journaled(str
   return 0 ;
 }
 
-/* utility function to force a BUG if it is called without the big
-** kernel lock held.  caller is the string printed just before calling BUG()
-*/
 void reiserfs_check_lock_depth(char *caller) {
-#ifdef CONFIG_SMP
+#ifdef __SMP__
   if (current->lock_depth < 0) {
+    char *crashit = NULL ;
     printk("%s called without kernel lock held\n", caller) ;
     show_reiserfs_locks() ;
-    BUG() ;
+    *crashit = 1 ;
   }
 #else
   ;
@@ -443,18 +339,11 @@ static inline struct reiserfs_journal_cn
   return cn ;
 }
 
-/* once upon a time, the journal would deadlock.  a lot.  Now, when
-** CONFIG_REISERFS_CHECK is defined, anytime someone enters a
-** transaction, it pushes itself into this ugly static list, and pops
-** itself off before calling journal_end.  I made a SysRq key to dump
-** the list, and tell me what the writers are when I'm deadlocked.  */
-
-				/* are you depending on the compiler
-                                   to optimize this function away
-                                   everywhere it is called? It is not
-                                   obvious how this works, but I
-                                   suppose debugging code need not be
-                                   clear.  -Hans */
+/*
+** once upon a time, the journal would deadlock.  a lot.  Now, which CONFIG_REISERFS_CHECK, anytime someone enters a
+** transaction, it pushes itself into this ugly static list, and pops itself off before calling journal_end.
+** I made a SysRq key to dump the list, and tell me what the writers are when I'm deadlocked.
+*/
 static char *journal_writers[512] ;
 int push_journal_writer(char *s) {
 #ifdef CONFIG_REISERFS_CHECK
@@ -478,7 +367,6 @@ int pop_journal_writer(int index) {
 #endif
   return 0 ;
 }
-
 int dump_journal_writers(void) {
   int i ;
   for (i = 0 ; i < 512 ; i++) {
@@ -507,23 +395,20 @@ int dump_journal_writers(void) {
 ** reject it on the next call to reiserfs_in_journal
 **
 */
-int reiserfs_in_journal(struct super_block *p_s_sb, kdev_t dev, 
-                        unsigned long bl, int size, int search_all, 
-			unsigned long *next_zero_bit) {
+int reiserfs_in_journal(struct super_block *p_s_sb, kdev_t dev, unsigned long bl, int size, int search_all, unsigned long *next_zero_bit) {
   struct reiserfs_journal_cnode *cn ;
   struct reiserfs_list_bitmap *jb ;
   int i ;
-  int bmap_nr = bl / (p_s_sb->s_blocksize << 3) ;
-  int bit_nr = bl % (p_s_sb->s_blocksize << 3) ;
-  int tmp_bit ;
-
-  *next_zero_bit = 0 ; /* always start this at zero. */
-
-  /* we aren't logging all blocks are safe for reuse */
+  int windex; 
+  
   if (reiserfs_dont_log(p_s_sb)) {
     return 0 ;
   }
 
+  windex = push_journal_writer("reiserfs_in_journal") ;
+
+  *next_zero_bit = 0 ; /* always start this at zero. */
+
   PROC_INFO_INC( p_s_sb, journal.in_journal );
   /* If we aren't doing a search_all, this is a metablock, and it will be logged before use.
   ** if we crash before the transaction that freed it commits,  this transaction won't
@@ -533,12 +418,10 @@ int reiserfs_in_journal(struct super_blo
     for (i = 0 ; i < JOURNAL_NUM_BITMAPS ; i++) {
       PROC_INFO_INC( p_s_sb, journal.in_journal_bitmap );
       jb = SB_JOURNAL(p_s_sb)->j_list_bitmap + i ;
-      if (jb->journal_list && jb->bitmaps[bmap_nr] &&
-          test_bit(bit_nr, jb->bitmaps[bmap_nr]->data)) {
-	tmp_bit = find_next_zero_bit((unsigned long *)
-	                             (jb->bitmaps[bmap_nr]->data),
-	                             p_s_sb->s_blocksize << 3, bit_nr+1) ; 
-	*next_zero_bit = bmap_nr * (p_s_sb->s_blocksize << 3) + tmp_bit ;
+      if (jb->journal_list && test_bit(bl, jb->bitmap)) {
+	*next_zero_bit = find_next_zero_bit((unsigned long *)(jb->bitmap),
+	                                   SB_BLOCK_COUNT(p_s_sb), bl+1) ; 
+	pop_journal_writer(windex) ;
 	return 1 ;
       }
     }
@@ -546,16 +429,19 @@ int reiserfs_in_journal(struct super_blo
 
   /* is it in any old transactions? */
   if (search_all && (cn = get_journal_hash_dev(SB_JOURNAL(p_s_sb)->j_list_hash_table, dev,bl,size))) {
+    pop_journal_writer(windex) ;
     return 1; 
   }
 
   /* is it in the current transaction.  This should never happen */
   if ((cn = get_journal_hash_dev(SB_JOURNAL(p_s_sb)->j_hash_table, dev,bl,size))) {
+    pop_journal_writer(windex) ;
     return 1; 
   }
 
   PROC_INFO_INC( p_s_sb, journal.in_journal_reusable );
   /* safe for reuse */
+  pop_journal_writer(windex) ;
   return 0 ;
 }
 
@@ -575,12 +461,12 @@ inline void insert_journal_hash(struct r
 
 /* lock the current transaction */
 inline static void lock_journal(struct super_block *p_s_sb) {
-  PROC_INFO_INC( p_s_sb, journal.lock_journal );
+  int windex = push_journal_writer("lock_journal") ;
   while(atomic_read(&(SB_JOURNAL(p_s_sb)->j_wlock)) > 0) {
-    PROC_INFO_INC( p_s_sb, journal.lock_journal_wait );
     sleep_on(&(SB_JOURNAL(p_s_sb)->j_wait)) ;
   }
   atomic_set(&(SB_JOURNAL(p_s_sb)->j_wlock), 1) ;
+  pop_journal_writer(windex) ;
 }
 
 /* unlock the current transaction */
@@ -596,10 +482,6 @@ inline static void unlock_journal(struct
 */
 static void cleanup_freed_for_journal_list(struct super_block *p_s_sb, struct reiserfs_journal_list *jl) {
 
-  struct reiserfs_list_bitmap *jb = jl->j_list_bitmap ;
-  if (jb) {
-    cleanup_bitmap_list(p_s_sb, jb) ;
-  }
   jl->j_list_bitmap->journal_list = NULL ;
   jl->j_list_bitmap = NULL ;
 }
@@ -619,10 +501,12 @@ static int flush_commit_list(struct supe
   int orig_commit_left = 0 ;
   struct buffer_head *tbh = NULL ;
   struct reiserfs_journal_list *other_jl ;
+  int windex = push_journal_writer("flush_commit_list") ;
 
   reiserfs_check_lock_depth("flush_commit_list") ;
 
   if (atomic_read(&jl->j_older_commits_done)) {
+    pop_journal_writer(windex) ;
     return 0 ;
   }
 
@@ -630,6 +514,7 @@ static int flush_commit_list(struct supe
   ** us is on disk too
   */
   if (jl->j_len <= 0) {
+    pop_journal_writer(windex) ;
     return 0 ;
   }
   if (flushall) {
@@ -649,6 +534,7 @@ static int flush_commit_list(struct supe
   count = 0 ;
   /* don't flush the commit list for the current transactoin */
   if (jl == ((SB_JOURNAL_LIST(s) + SB_JOURNAL_LIST_INDEX(s)))) {
+    pop_journal_writer(windex) ;
     return 0 ;
   }
 
@@ -658,6 +544,7 @@ static int flush_commit_list(struct supe
     if (flushall) {
       atomic_set(&(jl->j_older_commits_done), 1) ;
     }
+    pop_journal_writer(windex) ;
     return 0 ;
   }
   
@@ -666,18 +553,21 @@ static int flush_commit_list(struct supe
     if (flushall) {
       atomic_set(&(jl->j_older_commits_done), 1) ;
     }
+    pop_journal_writer(windex) ;
     return 0 ;
   }
-  /* keeps others from flushing while we are flushing */
-  atomic_set(&(jl->j_commit_flushing), 1) ; 
+  atomic_set(&(jl->j_commit_flushing), 1) ; /* keeps end_io from doing anything with commit_bh, and 
+                                            others from flushing while we are flushing */
 
 
   if (jl->j_len > JOURNAL_TRANS_MAX) {
     reiserfs_panic(s, "journal-512: flush_commit_list: length is %lu, list number %d\n", jl->j_len, jl - SB_JOURNAL_LIST(s)) ;
+    pop_journal_writer(windex) ;
     return 0 ;
   }
 
-  orig_commit_left = atomic_read(&(jl->j_commit_left)) ; 
+  orig_commit_left = atomic_read(&(jl->j_commit_left)) ; /* why? as log blocks get written j_commit_left goes 
+                                                            down without us knowing */
 
   /* start by checking all the commit blocks in this transaction.  
   ** Add anyone not on disk into tbh.  Stop checking once commit_left <= 1, because that means we
@@ -686,8 +576,8 @@ static int flush_commit_list(struct supe
 retry:
   count = 0 ;
   for (i = 0 ; atomic_read(&(jl->j_commit_left)) > 1 && i < (jl->j_len + 1) ; i++) {  /* everything but commit_bh */
-    bn = reiserfs_get_journal_block(s) + (jl->j_start+i) % JOURNAL_BLOCK_COUNT;
-    tbh = sb_get_hash_table(s, bn) ;
+    bn = SB_JOURNAL_BLOCK(s) + (jl->j_start + i) % JOURNAL_BLOCK_COUNT  ;
+    tbh = get_hash_table(s->s_dev, bn, s->s_blocksize) ;
 
 /* kill this sanity check */
 if (count > (orig_commit_left + 2)) {
@@ -703,8 +593,9 @@ reiserfs_panic(s, "journal-539: flush_co
       if (buffer_dirty(tbh)) {
 	printk("journal-569: flush_commit_list, block already dirty!\n") ;
       } else {				
-	mark_buffer_dirty(tbh) ;
+	mark_buffer_dirty(tbh, 0) ; 
       }
+      tbh->b_end_io = reiserfs_journal_end_io ; /* not needed */
       ll_rw_block(WRITE, 1, &tbh) ;
       count++ ;
       put_bh(tbh) ; /* once for our get_hash */
@@ -715,15 +606,15 @@ reiserfs_panic(s, "journal-539: flush_co
   if (count > 0) {
     for (i = 0 ; atomic_read(&(jl->j_commit_left)) > 1 && 
                  i < (jl->j_len + 1) ; i++) {  /* everything but commit_bh */
-      bn = reiserfs_get_journal_block(s) + (jl->j_start + i) % JOURNAL_BLOCK_COUNT  ;
-      tbh = sb_get_hash_table(s, bn) ;
+      bn = SB_JOURNAL_BLOCK(s) + (jl->j_start + i) % JOURNAL_BLOCK_COUNT  ;
+      tbh = get_hash_table(s->s_dev, bn, s->s_blocksize) ;
 
       wait_on_buffer(tbh) ;
       if (!buffer_uptodate(tbh)) {
 	reiserfs_panic(s, "journal-601, buffer write failed\n") ;
       }
-      put_bh(tbh) ; /* once for our get_hash */
-      bforget(tbh) ;    /* once due to original getblk in do_journal_end */
+      atomic_dec(&(tbh->b_count)) ; /* once for our get_hash */
+      brelse(tbh) ;    /* once due to original getblk in do_journal_end */
       atomic_dec(&(jl->j_commit_left)) ;
     }
   }
@@ -738,25 +629,27 @@ reiserfs_panic(s, "journal-539: flush_co
 		   atomic_read(&(jl->j_commit_left)));
   }
 
-  mark_buffer_dirty(jl->j_commit_bh) ;
+  mark_buffer_dirty(jl->j_commit_bh,0) ; 
   ll_rw_block(WRITE, 1, &(jl->j_commit_bh)) ;
   wait_on_buffer(jl->j_commit_bh) ;
   if (!buffer_uptodate(jl->j_commit_bh)) {
     reiserfs_panic(s, "journal-615: buffer write failed\n") ;
   }
   atomic_dec(&(jl->j_commit_left)) ;
-  bforget(jl->j_commit_bh) ;
+  brelse(jl->j_commit_bh) ;
 
   /* now, every commit block is on the disk.  It is safe to allow blocks freed during this transaction to be reallocated */
   cleanup_freed_for_journal_list(s, jl) ;
 
+  /* and it is safe to dirty/release all the real buffer heads */
+  dirty_journal_list(s, jl) ;
+
   if (flushall) {
     atomic_set(&(jl->j_older_commits_done), 1) ;
   }
   atomic_set(&(jl->j_commit_flushing), 0) ;
   wake_up(&(jl->j_commit_wait)) ;
-
-  s->s_dirt = 1 ;
+  pop_journal_writer(windex) ;
   return 0 ;
 }
 
@@ -787,6 +680,7 @@ static struct reiserfs_journal_list *fin
 static void remove_all_from_journal_list(struct super_block *p_s_sb, struct reiserfs_journal_list *jl, int debug) {
   struct buffer_head fake_bh ;
   struct reiserfs_journal_cnode *cn, *last ;
+  int windex = push_journal_writer("remove_all_from_journal_list") ;
   cn = jl->j_realblock ;
 
   /* which is better, to lock once around the whole loop, or
@@ -808,6 +702,7 @@ static void remove_all_from_journal_list
     free_cnode(p_s_sb, last) ;
   }
   jl->j_realblock = NULL ;
+  pop_journal_writer(windex) ;
 }
 
 /*
@@ -829,28 +724,34 @@ static int _update_journal_header_block(
     SB_JOURNAL(p_s_sb)->j_last_flush_trans_id = trans_id ;
     SB_JOURNAL(p_s_sb)->j_first_unflushed_offset = offset ;
     jh = (struct reiserfs_journal_header *)(SB_JOURNAL(p_s_sb)->j_header_bh->b_data) ;
-    jh->j_last_flush_trans_id = cpu_to_le32(trans_id) ;
-    jh->j_first_unflushed_offset = cpu_to_le32(offset) ;
-    jh->j_mount_id = cpu_to_le32(SB_JOURNAL(p_s_sb)->j_mount_id) ;
+    jh->j_last_flush_trans_id = trans_id ;
+    jh->j_first_unflushed_offset = offset ;
+    jh->j_mount_id = SB_JOURNAL(p_s_sb)->j_mount_id ;
     set_bit(BH_Dirty, &(SB_JOURNAL(p_s_sb)->j_header_bh->b_state)) ;
     ll_rw_block(WRITE, 1, &(SB_JOURNAL(p_s_sb)->j_header_bh)) ;
     wait_on_buffer((SB_JOURNAL(p_s_sb)->j_header_bh)) ; 
     if (!buffer_uptodate(SB_JOURNAL(p_s_sb)->j_header_bh)) {
-      printk( "reiserfs: journal-837: IO error during journal replay\n" );
-      return -EIO ;
+      reiserfs_panic(p_s_sb, "journal-712: buffer write failed\n") ;
     }
   }
   return 0 ;
 }
 
-static int update_journal_header_block(struct super_block *p_s_sb, 
-                                       unsigned long offset, 
-				       unsigned long trans_id) {
-    if (_update_journal_header_block(p_s_sb, offset, trans_id)) {
-	reiserfs_panic(p_s_sb, "journal-712: buffer write failed\n") ;
+/*
+** returns 1 if all older journal lists have been flushed
+*/
+static int older_journal_lists_are_flushed(struct super_block *p_s_sb, unsigned long trans_id) {
+  int i ;
+  struct reiserfs_journal_list *jl ;
+  for (i = 0 ; i < JOURNAL_LIST_COUNT ; i++) {
+    jl = SB_JOURNAL_LIST(p_s_sb) + i ;
+    if (jl && jl->j_len > 0 && jl->j_trans_id < trans_id && atomic_read(&(jl->j_nonzerolen)) > 0) {
+      return 0 ;
     }
-    return 0 ;
+  }
+  return 1 ;
 }
+
 /* 
 ** flush any and all journal lists older than you are 
 ** can only be called from flush_journal_list
@@ -866,42 +767,25 @@ static int flush_older_journal_lists(str
         other_jl->j_trans_id > 0 && 
 	other_jl->j_trans_id < trans_id && 
         other_jl != jl) {
-      /* do not flush all */
-      flush_journal_list(p_s_sb, other_jl, 0) ; 
+      /* not old only, not flush all */
+      flush_journal_list(p_s_sb, other_jl, 0, 0) ; 
     }
   }
   return 0 ;
 }
 
-static void reiserfs_end_buffer_io_sync(struct buffer_head *bh, int uptodate) {
-    if (buffer_journaled(bh)) {
-        reiserfs_warning("clm-2084: pinned buffer %lu:%s sent to disk\n",
-	                 bh->b_blocknr, kdevname(bh->b_dev)) ;
-    }
-    mark_buffer_uptodate(bh, uptodate) ;
-    unlock_buffer(bh) ;
-    put_bh(bh) ;
-}
-static void submit_logged_buffer(struct buffer_head *bh) {
-    lock_buffer(bh) ;
-    get_bh(bh) ;
-    bh->b_end_io = reiserfs_end_buffer_io_sync ;
-    mark_buffer_notjournal_new(bh) ;
-    clear_bit(BH_Dirty, &bh->b_state) ;
-    submit_bh(WRITE, bh) ;
-}
-
 /* flush a journal list, both commit and real blocks
+** set old_only to one if you only want to touch journal_lists that are fully flushed and done with.  This allows
+** you to free the memory they are using
 **
-** always set flushall to 1, unless you are calling from inside
+** always set flushall to 1, unless you are flushing all of them, or you are calling from inside
 ** flush_journal_list
 **
-** IMPORTANT.  This can only be called while there are no journal writers, 
-** and the journal is locked.  That means it can only be called from 
-** do_journal_end, or by journal_release
+** IMPORTANT.  This can only be called while there are no journal writers, and the journal is locked.  That means
+** it can only be called from do_journal_end.  If you set old_only, you can call from other places.  journal_release
+** can call this because there aren't any writers then.
 */
-static int flush_journal_list(struct super_block *s, 
-                              struct reiserfs_journal_list *jl, int flushall) {
+static int flush_journal_list(struct super_block *s, struct reiserfs_journal_list *jl, int old_only, int flushall) {
   struct reiserfs_journal_list *pjl ;
   struct reiserfs_journal_cnode *cn, *last ;
   int count ;
@@ -909,17 +793,19 @@ static int flush_journal_list(struct sup
   int was_dirty = 0 ;
   struct buffer_head *saved_bh ; 
   unsigned long j_len_saved = jl->j_len ;
+  int windex = push_journal_writer("flush_journal_list") ;
 
   if (j_len_saved <= 0) {
+    pop_journal_writer(windex) ;
     return 0 ;
   }
-
-  if (atomic_read(&SB_JOURNAL(s)->j_wcount) != 0) {
-    reiserfs_warning("clm-2048: flush_journal_list called with wcount %d\n",
-                      atomic_read(&SB_JOURNAL(s)->j_wcount)) ;
+  /* pretest to avoid the locking */
+  if (old_only && (atomic_read(&(jl->j_nonzerolen)) > 0 || 
+                   atomic_read(&(jl->j_flushing)))) {
+    pop_journal_writer(windex) ;
+    return 0 ;
   }
-  /* if someone is getting the commit list, we must wait for them */
-  while (atomic_read(&(jl->j_commit_flushing))) { 
+  while (atomic_read(&(jl->j_commit_flushing)) && !old_only) { /* if someone is getting the commit list, we must wait for them */
     sleep_on(&(jl->j_commit_wait)) ;
   }
   /* if someone is flushing this list, we must wait for them */
@@ -934,29 +820,63 @@ static int flush_journal_list(struct sup
   if (j_len_saved > JOURNAL_TRANS_MAX) {
     reiserfs_panic(s, "journal-715: flush_journal_list, length is %lu, list number %d\n", j_len_saved, jl - SB_JOURNAL_LIST(s)) ;
     atomic_dec(&(jl->j_flushing)) ;
+    pop_journal_writer(windex) ;
     return 0 ;
   }
 
   /* if all the work is already done, get out of here */
-  if (atomic_read(&(jl->j_nonzerolen)) <= 0 && 
-      atomic_read(&(jl->j_commit_left)) <= 0) {
-    goto flush_older_and_return ;
+  if (atomic_read(&(jl->j_nonzerolen)) <= 0 && atomic_read(&(jl->j_commit_left)) <= 0) {
+    if (flushall) {
+      flush_older_journal_lists(s, jl, jl->j_trans_id) ;
+    } else if (old_only && !older_journal_lists_are_flushed(s, jl->j_trans_id)) { /* only flush if we were called old_only */
+      atomic_dec(&(jl->j_flushing)) ;
+      wake_up(&(jl->j_flush_wait)) ;
+      pop_journal_writer(windex) ;
+      return 0 ;
+    } 
+    update_journal_header_block(s, (jl->j_start + jl->j_len + 2) % JOURNAL_BLOCK_COUNT, jl->j_trans_id) ;
+    remove_all_from_journal_list(s, jl, 0) ;
+    jl->j_len = 0 ;
+    jl->j_start = 0 ;
+    jl->j_commit_bh = NULL ;
+    jl->j_trans_id = 0 ;
+    atomic_dec(&(jl->j_flushing)) ;
+    wake_up(&(jl->j_flush_wait)) ;
+    pop_journal_writer(windex) ;
+    return 0 ;
   } 
 
-  /* start by putting the commit list on disk.  This will also flush 
-  ** the commit lists of any olders transactions
+  /* if we were called old_only, we're done. */
+  if (old_only) { 
+    atomic_dec(&(jl->j_flushing)) ;
+    wake_up(&(jl->j_flush_wait)) ;
+    pop_journal_writer(windex) ;
+    return 0 ;
+  }
+
+  /* not old only, start by putting the commit list on disk.  This will also flush the commit lists of any
+  ** olders transactions, which is important
   */
   flush_commit_list(s, jl, 1) ;
 
   /* are we done now? */
-  if (atomic_read(&(jl->j_nonzerolen)) <= 0 && 
-      atomic_read(&(jl->j_commit_left)) <= 0) {
-    goto flush_older_and_return ;
+  if (atomic_read(&(jl->j_nonzerolen)) <= 0 && atomic_read(&(jl->j_commit_left)) <= 0) {
+    if (flushall) {
+      flush_older_journal_lists(s, jl, jl->j_trans_id) ;
+    } 
+    update_journal_header_block(s, (jl->j_start + jl->j_len + 2) % JOURNAL_BLOCK_COUNT, jl->j_trans_id) ;
+    remove_all_from_journal_list(s, jl, 0) ;
+    jl->j_len = 0 ;
+    jl->j_start = 0 ;
+    jl->j_commit_bh = NULL ;
+    jl->j_trans_id = 0 ;
+    atomic_dec(&(jl->j_flushing)) ;
+    wake_up(&(jl->j_flush_wait)) ;
+    pop_journal_writer(windex) ;
+    return 0 ;
   }
 
-  /* loop through each cnode, see if we need to write it, 
-  ** or wait on a more recent transaction, or just ignore it 
-  */
+  /* loop through each cnode, see if we need to write it, or wait on a more recent transaction, or just ignore it */
   if (atomic_read(&(SB_JOURNAL(s)->j_wcount)) != 0) {
     reiserfs_panic(s, "journal-844: panic journal list is flushing, wcount is not 0\n") ;
   }
@@ -977,18 +897,15 @@ static int flush_journal_list(struct sup
     if (!pjl && cn->bh) {
       saved_bh = cn->bh ;
 
-      /* we do this to make sure nobody releases the buffer while 
-      ** we are working with it 
-      */
-      get_bh(saved_bh) ;
+      /* we do this to make sure nobody releases the buffer while we are working with it */
+      atomic_inc(&(saved_bh->b_count)) ;  
 
       if (buffer_journal_dirty(saved_bh)) {
         was_jwait = 1 ;
 	mark_buffer_notjournal_dirty(saved_bh) ;
-        /* undo the inc from journal_mark_dirty */
-	put_bh(saved_bh) ;
+	atomic_dec(&(saved_bh->b_count)) ; /* brelse the inc from journal_mark_dirty */
       }
-      if (can_dirty(cn)) {
+      if (buffer_dirty(saved_bh)) {
         was_dirty = 1 ;
       }
     }
@@ -1001,48 +918,41 @@ static int flush_journal_list(struct sup
       goto free_cnode ;
     }
 
-    /* bh == NULL when the block got to disk on its own, OR, 
-    ** the block got freed in a future transaction 
-    */
+    /* bh == NULL when the block got to disk on its own, OR, the block got freed in a future transaction */
     if (saved_bh == NULL) {
       goto free_cnode ;
     }
 
-    /* this should never happen.  kupdate_one_transaction has this list
-    ** locked while it works, so we should never see a buffer here that
-    ** is not marked JDirty_wait
+    /* the end_io task might not have run the buffer yet, so it is possible 
+    ** to have jwait buffer that isn't dirty.  It is not possible to have 
+    ** a buffer here that isn't mark BH_JDirty_wait
     */
+
     if ((!was_jwait) && !buffer_locked(saved_bh)) {
 printk("journal-813: BAD! buffer %lu %cdirty %cjwait, not in a newer tranasction\n", saved_bh->b_blocknr,
         was_dirty ? ' ' : '!', was_jwait ? ' ' : '!') ;
     }
-    /* kupdate_one_transaction waits on the buffers it is writing, so we
-    ** should never see locked buffers here
+    /* if it is locked, we wait on it so the end_io handler does not clobber something we are doing
+    ** we'll clear it out of the hash at the end with remove_all
     */
     if (buffer_locked(saved_bh)) {
-      printk("clm-2083: locked buffer %lu in flush_journal_list\n", 
-              saved_bh->b_blocknr) ;
       wait_on_buffer(saved_bh) ;
       if (!buffer_uptodate(saved_bh)) {
         reiserfs_panic(s, "journal-923: buffer write failed\n") ;
       }
-    } 
-    if (was_dirty) { 
+      goto free_cnode ;
+    } else if (buffer_dirty(saved_bh)) { /* it is still dirty, send to disk */
       /* we inc again because saved_bh gets decremented at free_cnode */
       get_bh(saved_bh) ;
       set_bit(BLOCK_NEEDS_FLUSH, &cn->state) ;
-      submit_logged_buffer(saved_bh) ;
+      ll_rw_block(WRITE, 1, &saved_bh) ;
       count++ ;
-    } else {
-      printk("clm-2082: Unable to flush buffer %lu in flush_journal_list\n",
-              saved_bh->b_blocknr) ;
-    }
+    } 
 free_cnode:
     last = cn ;
     cn = cn->next ;
     if (saved_bh) {
-      /* we incremented this to keep others from taking the buffer head away */
-      put_bh(saved_bh) ;
+      atomic_dec(&(saved_bh->b_count)); /* we incremented this to keep others from taking the buffer head away */
       if (atomic_read(&(saved_bh->b_count)) < 0) {
         printk("journal-945: saved_bh->b_count < 0") ;
       }
@@ -1062,34 +972,21 @@ free_cnode:
 	if (!buffer_uptodate(cn->bh)) {
 	  reiserfs_panic(s, "journal-949: buffer write failed\n") ;
 	}
-	refile_buffer(cn->bh) ;
         brelse(cn->bh) ;
       }
       cn = cn->next ;
     }
   }
 
-flush_older_and_return:
-  /* before we can update the journal header block, we _must_ flush all 
-  ** real blocks from all older transactions to disk.  This is because
-  ** once the header block is updated, this transaction will not be
-  ** replayed after a crash
-  */
+  /* before we can update the journal header block, we _must_ flush all real blocks from all older transactions to disk */
   if (flushall) {
     flush_older_journal_lists(s, jl, jl->j_trans_id) ;
   } 
   
-  /* before we can remove everything from the hash tables for this 
-  ** transaction, we must make sure it can never be replayed
-  **
-  ** since we are only called from do_journal_end, we know for sure there
-  ** are no allocations going on while we are flushing journal lists.  So,
-  ** we only need to update the journal header block for the last list
-  ** being flushed
+  /* before we can remove everything from the hash tables for this transaction, we must make sure it can
+  ** never be replayed
   */
-  if (flushall) {
-    update_journal_header_block(s, (jl->j_start + jl->j_len + 2) % JOURNAL_BLOCK_COUNT, jl->j_trans_id) ;
-  }
+  update_journal_header_block(s, (jl->j_start + jl->j_len + 2) % JOURNAL_BLOCK_COUNT, jl->j_trans_id) ;
   remove_all_from_journal_list(s, jl, 0) ;
   jl->j_len = 0 ;
   atomic_set(&(jl->j_nonzerolen), 0) ;
@@ -1099,175 +996,11 @@ flush_older_and_return:
   jl->j_trans_id = 0 ;
   atomic_dec(&(jl->j_flushing)) ;
   wake_up(&(jl->j_flush_wait)) ;
+  pop_journal_writer(windex) ;
   return 0 ;
 } 
 
 
-static int kupdate_one_transaction(struct super_block *s,
-                                    struct reiserfs_journal_list *jl) 
-{
-    struct reiserfs_journal_list *pjl ; /* previous list for this cn */
-    struct reiserfs_journal_cnode *cn, *walk_cn ;
-    unsigned long blocknr ;
-    int run = 0 ;
-    int orig_trans_id = jl->j_trans_id ;
-    struct buffer_head *saved_bh ; 
-    int ret = 0 ;
-
-    /* if someone is getting the commit list, we must wait for them */
-    while (atomic_read(&(jl->j_commit_flushing))) {
-        sleep_on(&(jl->j_commit_wait)) ;
-    }
-    /* if someone is flushing this list, we must wait for them */
-    while (atomic_read(&(jl->j_flushing))) {
-        sleep_on(&(jl->j_flush_wait)) ;
-    }
-    /* was it flushed while we slept? */
-    if (jl->j_len <= 0 || jl->j_trans_id != orig_trans_id) {
-        return 0 ;
-    }
-
-    /* this list is now ours, we can change anything we want */
-    atomic_set(&(jl->j_flushing), 1) ;
-
-loop_start:
-    cn = jl->j_realblock ;
-    while(cn) {
-        saved_bh = NULL ;
-        /* if the blocknr == 0, this has been cleared from the hash,
-        ** skip it
-        */
-        if (cn->blocknr == 0) {
-            goto next ;
-        }
-        /* look for a more recent transaction that logged this
-        ** buffer.  Only the most recent transaction with a buffer in
-        ** it is allowed to send that buffer to disk
-        */
-        pjl = find_newer_jl_for_cn(cn) ;
-        if (run == 0 && !pjl && cn->bh && buffer_journal_dirty(cn->bh) &&
-            can_dirty(cn)) 
-        {
-            if (!test_bit(BH_JPrepared, &cn->bh->b_state)) {
-                set_bit(BLOCK_NEEDS_FLUSH, &cn->state) ;
-		submit_logged_buffer(cn->bh) ;
-            } else {
-                /* someone else is using this buffer.  We can't 
-                ** send it to disk right now because they might
-                ** be changing/logging it.
-                */
-                ret = 1 ;
-            }
-        } else if (test_bit(BLOCK_NEEDS_FLUSH, &cn->state)) {
-            clear_bit(BLOCK_NEEDS_FLUSH, &cn->state) ;
-            if (!pjl && cn->bh) {
-                wait_on_buffer(cn->bh) ;
-            }
-            /* check again, someone could have logged while we scheduled */
-            pjl = find_newer_jl_for_cn(cn) ;
-
-            /* before the JDirty_wait bit is set, the 
-            ** buffer is added to the hash list.  So, if we are
-            ** run in the middle of a do_journal_end, we will notice
-            ** if this buffer was logged and added from the latest
-            ** transaction.  In this case, we don't want to decrement
-            ** b_count
-            */
-            if (!pjl && cn->bh && buffer_journal_dirty(cn->bh)) {
-                blocknr = cn->blocknr ;
-                walk_cn = cn ;
-                saved_bh= cn->bh ;
-                /* update all older transactions to show this block
-                ** was flushed
-                */
-                mark_buffer_notjournal_dirty(cn->bh) ;
-                while(walk_cn) {
-                    if (walk_cn->bh && walk_cn->blocknr == blocknr && 
-                         walk_cn->dev == cn->dev) {
-                        if (walk_cn->jlist) {
-                            atomic_dec(&(walk_cn->jlist->j_nonzerolen)) ;
-                        }
-                        walk_cn->bh = NULL ;
-                    }
-                    walk_cn = walk_cn->hnext ;
-                }
-                if (atomic_read(&saved_bh->b_count) < 1) {
-                    reiserfs_warning("clm-2081: bad count on %lu\n", 
-                                      saved_bh->b_blocknr) ;
-                }
-                brelse(saved_bh) ;
-            }
-        }
-        /*
-        ** if the more recent transaction is committed to the log,
-        ** this buffer can be considered flushed.  Decrement our
-        ** counters to reflect one less buffer that needs writing.
-        **
-        ** note, this relies on all of the above code being
-        ** schedule free once pjl comes back non-null.
-        */
-        if (pjl && cn->bh && atomic_read(&pjl->j_commit_left) == 0) {
-            atomic_dec(&cn->jlist->j_nonzerolen) ;
-            cn->bh = NULL ;
-        } 
-next:
-        cn = cn->next ;
-    }
-    /* the first run through the loop sends all the dirty buffers to
-    ** ll_rw_block.
-    ** the second run through the loop does all the accounting
-    */
-    if (run++ == 0) {
-        goto loop_start ;
-    }
-
-    atomic_set(&(jl->j_flushing), 0) ;
-    wake_up(&(jl->j_flush_wait)) ;
-    return ret ;
-}
-/* since we never give dirty buffers to bdflush/kupdate, we have to
-** flush them ourselves.  This runs through the journal lists, finds
-** old metadata in need of flushing and sends it to disk.
-** this does not end transactions, commit anything, or free
-** cnodes.
-**
-** returns the highest transaction id that was flushed last time
-*/
-static unsigned long reiserfs_journal_kupdate(struct super_block *s) {
-    struct reiserfs_journal_list *jl ;
-    int i ;
-    int start ;
-    time_t age ;
-    int ret = 0 ;
-
-    start = SB_JOURNAL_LIST_INDEX(s) ;
-
-    /* safety check to prevent flush attempts during a mount */
-    if (start < 0) {
-        return 0 ;
-    }
-    i = (start + 1) % JOURNAL_LIST_COUNT ;
-    while(i != start) {
-        jl = SB_JOURNAL_LIST(s) + i  ;
-        age = CURRENT_TIME - jl->j_timestamp ;
-        if (jl->j_len > 0 && // age >= (JOURNAL_MAX_COMMIT_AGE * 2) && 
-            atomic_read(&(jl->j_nonzerolen)) > 0 &&
-            atomic_read(&(jl->j_commit_left)) == 0) {
-
-            if (jl->j_trans_id == SB_JOURNAL(s)->j_trans_id) {
-                break ;
-            }
-            /* if ret was already 1, we want to preserve that */
-            ret |= kupdate_one_transaction(s, jl) ;
-        } 
-        if (atomic_read(&(jl->j_nonzerolen)) > 0) {
-            ret |= 1 ;
-        }
-        i = (i + 1) % JOURNAL_LIST_COUNT ;
-    }
-    return ret ;
-}
-
 /*
 ** removes any nodes in table with name block and dev as bh.
 ** only touchs the hnext and hprev pointers.
@@ -1307,17 +1040,6 @@ void remove_journal_hash(struct reiserfs
     cur = cur->hnext ;
   }
 }
-
-static void free_journal_ram(struct super_block *p_s_sb) {
-  vfree(SB_JOURNAL(p_s_sb)->j_cnode_free_orig) ;
-  free_list_bitmaps(p_s_sb, SB_JOURNAL(p_s_sb)->j_list_bitmap) ;
-  free_bitmap_nodes(p_s_sb) ; /* must be after free_list_bitmaps */
-  if (SB_JOURNAL(p_s_sb)->j_header_bh) {
-    brelse(SB_JOURNAL(p_s_sb)->j_header_bh) ;
-  }
-  vfree(SB_JOURNAL(p_s_sb)) ;
-}
-
 /*
 ** call on unmount.  Only set error to 1 if you haven't made your way out
 ** of read_super() yet.  Any other caller must keep error at 0.
@@ -1327,7 +1049,7 @@ static int do_journal_release(struct rei
 
   /* we only want to flush out transactions if we were called with error == 0
   */
-  if (!error && !(p_s_sb->s_flags & MS_RDONLY)) {
+  if (!error) {
     /* end the current trans */
     do_journal_end(th, p_s_sb,10, FLUSH_ALL) ;
 
@@ -1336,6 +1058,11 @@ static int do_journal_release(struct rei
     reiserfs_prepare_for_journal(p_s_sb, SB_BUFFER_WITH_SB(p_s_sb), 1) ;
     journal_mark_dirty(&myth, p_s_sb, SB_BUFFER_WITH_SB(p_s_sb)) ;
     do_journal_end(&myth, p_s_sb,1, FLUSH_ALL) ;
+
+    /* get any stragglers from the task queue */
+    down(&reiserfs_end_io_sem) ;
+    run_task_queue(&reiserfs_end_io_tq) ;
+    up(&reiserfs_end_io_sem) ;
   }
 
   /* we decrement before we wake up, because the commit thread dies off
@@ -1345,7 +1072,10 @@ static int do_journal_release(struct rei
   wake_up(&reiserfs_commit_thread_wait) ;
   sleep_on(&reiserfs_commit_thread_done) ;
 
-  free_journal_ram(p_s_sb) ;
+  vfree(SB_JOURNAL(p_s_sb)->j_cnode_free_orig) ;
+  free_list_bitmaps(p_s_sb) ;
+  brelse(SB_JOURNAL(p_s_sb)->j_header_bh) ;
+  vfree(SB_JOURNAL(p_s_sb)) ;
 
   return 0 ;
 }
@@ -1366,10 +1096,8 @@ int journal_release_error(struct reiserf
 /* compares description block with commit block.  returns 1 if they differ, 0 if they are the same */
 static int journal_compare_desc_commit(struct super_block *p_s_sb, struct reiserfs_journal_desc *desc, 
 			               struct reiserfs_journal_commit *commit) {
-  if (le32_to_cpu(commit->j_trans_id) != le32_to_cpu(desc->j_trans_id) || 
-      le32_to_cpu(commit->j_len) != le32_to_cpu(desc->j_len) || 
-      le32_to_cpu(commit->j_len) > JOURNAL_TRANS_MAX || 
-      le32_to_cpu(commit->j_len) <= 0 
+  if (commit->j_trans_id != desc->j_trans_id || commit->j_len != desc->j_len || commit->j_len > JOURNAL_TRANS_MAX || 
+      commit->j_len <= 0 
   ) {
     return 1 ;
   }
@@ -1382,6 +1110,7 @@ static int journal_compare_desc_commit(s
 static int journal_transaction_is_valid(struct super_block *p_s_sb, struct buffer_head *d_bh, unsigned long *oldest_invalid_trans_id, unsigned long *newest_mount_id) {
   struct reiserfs_journal_desc *desc ;
   struct reiserfs_journal_commit *commit ;
+  struct reiserfs_super_block *rs = SB_DISK_SUPER_BLOCK(p_s_sb) ;
   struct buffer_head *c_bh ;
   unsigned long offset ;
 
@@ -1389,48 +1118,35 @@ static int journal_transaction_is_valid(
       return 0 ;
 
   desc = (struct reiserfs_journal_desc *)d_bh->b_data ;
-  if (le32_to_cpu(desc->j_len) > 0 && !memcmp(desc->j_magic, JOURNAL_DESC_MAGIC, 8)) {
-    if (oldest_invalid_trans_id && *oldest_invalid_trans_id && le32_to_cpu(desc->j_trans_id) > *oldest_invalid_trans_id) {
-      reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-986: transaction "
-	              "is valid returning because trans_id %d is greater than "
-		      "oldest_invalid %lu\n", le32_to_cpu(desc->j_trans_id), 
-		       *oldest_invalid_trans_id);
+  if (desc->j_len > 0 && !memcmp(desc->j_magic, JOURNAL_DESC_MAGIC, 8)) {
+    if (oldest_invalid_trans_id && *oldest_invalid_trans_id && desc->j_trans_id > *oldest_invalid_trans_id) {
+printk("journal-986: transaction is valid returning because trans_id %d is greater than oldest_invalid %lu\n", 
+        desc->j_trans_id, *oldest_invalid_trans_id) ;
       return 0 ;
     }
-    if (newest_mount_id && *newest_mount_id > le32_to_cpu(desc->j_mount_id)) {
-      reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1087: transaction "
-                     "is valid returning because mount_id %d is less than "
-		     "newest_mount_id %lu\n", desc->j_mount_id, 
-		     *newest_mount_id) ;
+    if (newest_mount_id && *newest_mount_id > desc->j_mount_id) {
+      printk("journal-1087: transaction is valid returning because mount_id %d is less than newest_mount_id %lu\n", desc->j_mount_id, *newest_mount_id) ;
       return -1 ;
     }
-    offset = d_bh->b_blocknr - reiserfs_get_journal_block(p_s_sb) ;
+    offset = d_bh->b_blocknr - rs->s_journal_block ;
 
     /* ok, we have a journal description block, lets see if the transaction was valid */
-    c_bh = sb_bread(p_s_sb, reiserfs_get_journal_block(p_s_sb) + ((offset + le32_to_cpu(desc->j_len) + 1) % JOURNAL_BLOCK_COUNT)) ;
+    c_bh = bread(p_s_sb->s_dev, rs->s_journal_block + ((offset + desc->j_len + 1) % JOURNAL_BLOCK_COUNT), 
+    		p_s_sb->s_blocksize) ;
     if (!c_bh)
       return 0 ;
     commit = (struct reiserfs_journal_commit *)c_bh->b_data ;
     if (journal_compare_desc_commit(p_s_sb, desc, commit)) {
-      reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, 
-                     "journal_transaction_is_valid, commit offset %ld had bad "
-		     "time %d or length %d\n", 
-		     c_bh->b_blocknr - reiserfs_get_journal_block(p_s_sb),
-		     le32_to_cpu(commit->j_trans_id), 
-		     le32_to_cpu(commit->j_len));
+      printk("journal_transaction_is_valid, commit offset %ld had bad time %d or length %d\n", 
+	      c_bh->b_blocknr - rs->s_journal_block,commit->j_trans_id, commit->j_len);
       brelse(c_bh) ;
       if (oldest_invalid_trans_id)
-        *oldest_invalid_trans_id = le32_to_cpu(desc->j_trans_id) ;
-	reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1004: "
-	               "transaction_is_valid setting oldest invalid trans_id "
-		       "to %d\n", le32_to_cpu(desc->j_trans_id)) ;
+        *oldest_invalid_trans_id = desc->j_trans_id ;
+printk("journal-1004: transaction_is_valid setting oldest invalid trans_id to %d\n", desc->j_trans_id) ;
       return -1; 
     }
     brelse(c_bh) ;
-    reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1006: found valid "
-                   "transaction start offset %lu, len %d id %d\n", 
-		   d_bh->b_blocknr - reiserfs_get_journal_block(p_s_sb), 
-		   le32_to_cpu(desc->j_len), le32_to_cpu(desc->j_trans_id)) ;
+printk("journal-1006: found valid transaction start offset %lu, len %d id %d\n", d_bh->b_blocknr - rs->s_journal_block , desc->j_len, desc->j_trans_id) ;
     return 1 ;
   } else {
     return 0 ;
@@ -1453,6 +1169,7 @@ static int journal_read_transaction(stru
 				    unsigned long oldest_trans_id, unsigned long newest_mount_id) {
   struct reiserfs_journal_desc *desc ;
   struct reiserfs_journal_commit *commit ;
+  struct reiserfs_super_block *rs = SB_DISK_SUPER_BLOCK(p_s_sb) ;
   unsigned long trans_id = 0 ;
   struct buffer_head *c_bh ;
   struct buffer_head *d_bh ;
@@ -1465,63 +1182,54 @@ static int journal_read_transaction(stru
   if (!d_bh)
     return 1 ;
   desc = (struct reiserfs_journal_desc *)d_bh->b_data ;
-  trans_offset = d_bh->b_blocknr - reiserfs_get_journal_block(p_s_sb) ;
-  reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1037: "
-                 "journal_read_transaction, offset %lu, len %d mount_id %d\n", 
-		 d_bh->b_blocknr - reiserfs_get_journal_block(p_s_sb), 
-		 le32_to_cpu(desc->j_len), le32_to_cpu(desc->j_mount_id)) ;
-  if (le32_to_cpu(desc->j_trans_id) < oldest_trans_id) {
-    reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1039: "
-                   "journal_read_trans skipping because %lu is too old\n", 
-		   cur_dblock - reiserfs_get_journal_block(p_s_sb)) ;
+  trans_offset = d_bh->b_blocknr - rs->s_journal_block ;
+printk("journal-1037: journal_read_transaction, offset %lu, len %d mount_id %d\n", d_bh->b_blocknr - rs->s_journal_block, desc->j_len, desc->j_mount_id) ;
+  if (desc->j_trans_id < oldest_trans_id) {
+printk("journal-1039: journal_read_trans skipping because %lu is too old\n", cur_dblock - rs->s_journal_block) ;
     brelse(d_bh) ;
     return 1 ;
   }
-  if (le32_to_cpu(desc->j_mount_id) != newest_mount_id) {
-    reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1146: "
-                   "journal_read_trans skipping because %d is != "
-		   "newest_mount_id %lu\n", le32_to_cpu(desc->j_mount_id), 
-		    newest_mount_id) ;
+  if (desc->j_mount_id != newest_mount_id) {
+printk("journal-1146: journal_read_trans skipping because %d is != newest_mount_id %lu\n", desc->j_mount_id, newest_mount_id) ;
     brelse(d_bh) ;
     return 1 ;
   }
-  c_bh = sb_bread(p_s_sb, reiserfs_get_journal_block(p_s_sb) + ((trans_offset + le32_to_cpu(desc->j_len) + 1) % JOURNAL_BLOCK_COUNT)) ;
+  c_bh = bread(p_s_sb->s_dev, rs->s_journal_block + ((trans_offset + desc->j_len + 1) % JOURNAL_BLOCK_COUNT), 
+    		p_s_sb->s_blocksize) ;
   if (!c_bh) {
     brelse(d_bh) ;
     return 1 ;
   }
   commit = (struct reiserfs_journal_commit *)c_bh->b_data ;
   if (journal_compare_desc_commit(p_s_sb, desc, commit)) {
-    reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal_read_transaction, "
-                   "commit offset %ld had bad time %d or length %d\n", 
-		   c_bh->b_blocknr - reiserfs_get_journal_block(p_s_sb), 
-		   le32_to_cpu(commit->j_trans_id), le32_to_cpu(commit->j_len));
+    printk("journal_read_transaction, commit offset %ld had bad time %d or length %d\n", 
+	    c_bh->b_blocknr - rs->s_journal_block,commit->j_trans_id, commit->j_len);
     brelse(c_bh) ;
     brelse(d_bh) ;
     return 1; 
   }
-  trans_id = le32_to_cpu(desc->j_trans_id) ;
+  trans_id = desc->j_trans_id ;
   /* now we know we've got a good transaction, and it was inside the valid time ranges */
-  log_blocks = reiserfs_kmalloc(le32_to_cpu(desc->j_len) * sizeof(struct buffer_head *), GFP_NOFS, p_s_sb) ;
-  real_blocks = reiserfs_kmalloc(le32_to_cpu(desc->j_len) * sizeof(struct buffer_head *), GFP_NOFS, p_s_sb) ;
+  log_blocks = kmalloc(desc->j_len * sizeof(struct buffer_head *), GFP_KERNEL) ;
+  real_blocks = kmalloc(desc->j_len * sizeof(struct buffer_head *), GFP_KERNEL) ;
   if (!log_blocks  || !real_blocks) {
     brelse(c_bh) ;
     brelse(d_bh) ;
-    reiserfs_kfree(log_blocks, le32_to_cpu(desc->j_len) * sizeof(struct buffer_head *), p_s_sb) ;
-    reiserfs_kfree(real_blocks, le32_to_cpu(desc->j_len) * sizeof(struct buffer_head *), p_s_sb) ;
+    kfree(log_blocks) ;
+    kfree(real_blocks) ;
     reiserfs_warning("journal-1169: kmalloc failed, unable to mount FS\n") ;
     return -1 ;
   }
   /* get all the buffer heads */
-  for(i = 0 ; i < le32_to_cpu(desc->j_len) ; i++) {
-    log_blocks[i] = sb_getblk(p_s_sb, reiserfs_get_journal_block(p_s_sb) + (trans_offset + 1 + i) % JOURNAL_BLOCK_COUNT);
+  for(i = 0 ; i < desc->j_len ; i++) {
+    log_blocks[i] = getblk(p_s_sb->s_dev, rs->s_journal_block + (trans_offset + 1 + i) % JOURNAL_BLOCK_COUNT, p_s_sb->s_blocksize);
     if (i < JOURNAL_TRANS_HALF) {
-      real_blocks[i] = sb_getblk(p_s_sb, le32_to_cpu(desc->j_realblock[i])) ;
+      real_blocks[i] = getblk(p_s_sb->s_dev, desc->j_realblock[i], p_s_sb->s_blocksize) ;
     } else {
-      real_blocks[i] = sb_getblk(p_s_sb, le32_to_cpu(commit->j_realblock[i - JOURNAL_TRANS_HALF])) ;
+      real_blocks[i] = getblk(p_s_sb->s_dev, commit->j_realblock[i - JOURNAL_TRANS_HALF], p_s_sb->s_blocksize) ;
     }
-    if (real_blocks[i]->b_blocknr >= reiserfs_get_journal_block(p_s_sb) &&
-        real_blocks[i]->b_blocknr < (reiserfs_get_journal_block(p_s_sb)+JOURNAL_BLOCK_COUNT)) {
+    if (real_blocks[i]->b_blocknr >= rs->s_journal_block &&
+        real_blocks[i]->b_blocknr < (rs->s_journal_block+JOURNAL_BLOCK_COUNT)) {
       reiserfs_warning("journal-1204: REPLAY FAILURE fsck required! Trying to replay onto a log block\n") ;
       brelse_array(log_blocks, i) ;
       brelse_array(real_blocks, i) ;
@@ -1533,13 +1241,13 @@ static int journal_read_transaction(stru
     }
   }
   /* read in the log blocks, memcpy to the corresponding real block */
-  ll_rw_block(READ, le32_to_cpu(desc->j_len), log_blocks) ;
-  for (i = 0 ; i < le32_to_cpu(desc->j_len) ; i++) {
+  ll_rw_block(READ, desc->j_len, log_blocks) ;
+  for (i = 0 ; i < desc->j_len ; i++) {
     wait_on_buffer(log_blocks[i]) ;
     if (!buffer_uptodate(log_blocks[i])) {
       reiserfs_warning("journal-1212: REPLAY FAILURE fsck required! buffer write failed\n") ;
-      brelse_array(log_blocks + i, le32_to_cpu(desc->j_len) - i) ;
-      brelse_array(real_blocks, le32_to_cpu(desc->j_len)) ;
+      brelse_array(log_blocks + i, desc->j_len - i) ;
+      brelse_array(real_blocks, desc->j_len) ;
       brelse(c_bh) ;
       brelse(d_bh) ;
       reiserfs_kfree(log_blocks, le32_to_cpu(desc->j_len) * sizeof(struct buffer_head *), p_s_sb) ;
@@ -1551,15 +1259,15 @@ static int journal_read_transaction(stru
     brelse(log_blocks[i]) ;
   }
   /* flush out the real blocks */
-  for (i = 0 ; i < le32_to_cpu(desc->j_len) ; i++) {
+  for (i = 0 ; i < desc->j_len ; i++) {
     set_bit(BH_Dirty, &(real_blocks[i]->b_state)) ;
     ll_rw_block(WRITE, 1, real_blocks + i) ;
   }
-  for (i = 0 ; i < le32_to_cpu(desc->j_len) ; i++) {
+  for (i = 0 ; i < desc->j_len ; i++) {
     wait_on_buffer(real_blocks[i]) ; 
     if (!buffer_uptodate(real_blocks[i])) {
       reiserfs_warning("journal-1226: REPLAY FAILURE, fsck required! buffer write failed\n") ;
-      brelse_array(real_blocks + i, le32_to_cpu(desc->j_len) - i) ;
+      brelse_array(real_blocks + i, desc->j_len - i) ;
       brelse(c_bh) ;
       brelse(d_bh) ;
       reiserfs_kfree(log_blocks, le32_to_cpu(desc->j_len) * sizeof(struct buffer_head *), p_s_sb) ;
@@ -1568,13 +1276,11 @@ static int journal_read_transaction(stru
     }
     brelse(real_blocks[i]) ;
   }
-  cur_dblock = reiserfs_get_journal_block(p_s_sb) + ((trans_offset + le32_to_cpu(desc->j_len) + 2) % JOURNAL_BLOCK_COUNT) ;
-  reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1095: setting journal "
-                 "start to offset %ld\n", 
-		 cur_dblock - reiserfs_get_journal_block(p_s_sb)) ;
+  cur_dblock = rs->s_journal_block + ((trans_offset + desc->j_len + 2) % JOURNAL_BLOCK_COUNT) ;
+printk("journal-1095: setting journal start to offset %ld\n", cur_dblock - rs->s_journal_block) ;
   
   /* init starting values for the first transaction, in case this is the last transaction to be replayed. */
-  SB_JOURNAL(p_s_sb)->j_start = cur_dblock - reiserfs_get_journal_block(p_s_sb) ;
+  SB_JOURNAL(p_s_sb)->j_start = cur_dblock - rs->s_journal_block ;
   SB_JOURNAL(p_s_sb)->j_last_flush_trans_id = trans_id ;
   SB_JOURNAL(p_s_sb)->j_trans_id = trans_id + 1;
   brelse(c_bh) ;
@@ -1629,6 +1335,7 @@ struct buffer_head * reiserfs_breada (kd
 	return NULL;
 }
 static int journal_read(struct super_block *p_s_sb) {
+  struct reiserfs_super_block *rs = SB_DISK_SUPER_BLOCK(p_s_sb) ;
   struct reiserfs_journal_desc *desc ;
   unsigned long last_flush_trans_id = 0 ;
   unsigned long oldest_trans_id = 0;
@@ -1645,39 +1352,30 @@ static int journal_read(struct super_blo
   int continue_replay = 1 ;
   int ret ;
 
-  cur_dblock = reiserfs_get_journal_block(p_s_sb) ;
-  printk("reiserfs: checking transaction log (device %s) ...\n",
-          kdevname(p_s_sb->s_dev)) ;
-  start = CURRENT_TIME ;
-
-  /* step 1, read in the journal header block.  Check the transaction it says 
-  ** is the first unflushed, and if that transaction is not valid, 
-  ** replay is done
-  */
-  SB_JOURNAL(p_s_sb)->j_header_bh = sb_bread(p_s_sb, 
-                                          reiserfs_get_journal_block(p_s_sb) + 
-					  JOURNAL_BLOCK_COUNT) ;
+  cur_dblock = rs->s_journal_block ;
+printk("journal-1141: reading through journal entries\n") ;
+start = CURRENT_TIME ;
+
+  /* step 1, read in the journal header block.  Check the transaction is says is the first unflushed,
+  ** and if that transaction is not valid, replay is done
+  */
+  SB_JOURNAL(p_s_sb)->j_header_bh = bread(p_s_sb->s_dev, rs->s_journal_block + JOURNAL_BLOCK_COUNT, p_s_sb->s_blocksize) ;
   if (!SB_JOURNAL(p_s_sb)->j_header_bh) {
     return 1 ;
   }
   jh = (struct reiserfs_journal_header *)(SB_JOURNAL(p_s_sb)->j_header_bh->b_data) ;
-  if (le32_to_cpu(jh->j_first_unflushed_offset) >= 0 && 
-      le32_to_cpu(jh->j_first_unflushed_offset) < JOURNAL_BLOCK_COUNT &&
-      le32_to_cpu(jh->j_last_flush_trans_id) > 0) {
-    last_flush_start = reiserfs_get_journal_block(p_s_sb) + 
-                       le32_to_cpu(jh->j_first_unflushed_offset) ;
-    last_flush_trans_id = le32_to_cpu(jh->j_last_flush_trans_id) ;
-    reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1153: found in "
-                   "header: first_unflushed_offset %d, last_flushed_trans_id "
-		   "%lu\n", le32_to_cpu(jh->j_first_unflushed_offset), 
-		   last_flush_trans_id) ;
+  if (jh->j_first_unflushed_offset >= 0 && jh->j_first_unflushed_offset < JOURNAL_BLOCK_COUNT &&
+      jh->j_last_flush_trans_id > 0) {
+    last_flush_start = rs->s_journal_block + jh->j_first_unflushed_offset ;
+    last_flush_trans_id = jh->j_last_flush_trans_id ;
+printk("journal-1153: found in header: first_unflushed_offset %d, last_flushed_trans_id %lu\n", jh->j_first_unflushed_offset, 
+										 last_flush_trans_id) ;
     valid_journal_header = 1 ;
 
-    /* now, we try to read the first unflushed offset.  If it is not valid, 
-    ** there is nothing more we can do, and it makes no sense to read 
-    ** through the whole log.
+    /* now, we try to read the first unflushed offset.  If it is not valid, there is nothing more we can do,
+    ** and it makes no sense to read through the whole log.
     */
-    d_bh = sb_bread(p_s_sb, reiserfs_get_journal_block(p_s_sb) + le32_to_cpu(jh->j_first_unflushed_offset)) ;
+    d_bh = bread(p_s_sb->s_dev, rs->s_journal_block + jh->j_first_unflushed_offset, p_s_sb->s_blocksize) ;
     ret = journal_transaction_is_valid(p_s_sb, d_bh, NULL, NULL) ;
     if (!ret) {
       continue_replay = 0 ;
@@ -1685,46 +1383,30 @@ static int journal_read(struct super_blo
     brelse(d_bh) ;
   }
 
-  if (continue_replay && is_read_only(p_s_sb->s_dev)) {
-    printk("clm-2076: device is readonly, unable to replay log\n") ;
-    return -1 ;
-  }
-  if (continue_replay && (p_s_sb->s_flags & MS_RDONLY)) {
-    printk("Warning, log replay starting on readonly filesystem\n") ;    
-  }
-
   /* ok, there are transactions that need to be replayed.  start with the first log block, find
   ** all the valid transactions, and pick out the oldest.
   */
-  while(continue_replay && cur_dblock < (reiserfs_get_journal_block(p_s_sb) + JOURNAL_BLOCK_COUNT)) {
-    d_bh = reiserfs_breada(p_s_sb->s_dev, cur_dblock, p_s_sb->s_blocksize,
-			   reiserfs_get_journal_block(p_s_sb) + JOURNAL_BLOCK_COUNT) ;
+  while(continue_replay && cur_dblock < (rs->s_journal_block + JOURNAL_BLOCK_COUNT)) {
+    d_bh = bread(p_s_sb->s_dev, cur_dblock, p_s_sb->s_blocksize) ;
     ret = journal_transaction_is_valid(p_s_sb, d_bh, &oldest_invalid_trans_id, &newest_mount_id) ;
     if (ret == 1) {
       desc = (struct reiserfs_journal_desc *)d_bh->b_data ;
       if (oldest_start == 0) { /* init all oldest_ values */
-        oldest_trans_id = le32_to_cpu(desc->j_trans_id) ;
+        oldest_trans_id = desc->j_trans_id ;
 	oldest_start = d_bh->b_blocknr ;
-	newest_mount_id = le32_to_cpu(desc->j_mount_id) ;
-	reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1179: Setting "
-	               "oldest_start to offset %lu, trans_id %lu\n", 
-		       oldest_start - reiserfs_get_journal_block(p_s_sb), 
-		       oldest_trans_id) ;
-      } else if (oldest_trans_id > le32_to_cpu(desc->j_trans_id)) { 
-        /* one we just read was older */
-        oldest_trans_id = le32_to_cpu(desc->j_trans_id) ;
+	newest_mount_id = desc->j_mount_id ;
+printk("journal-1179: Setting oldest_start to offset %lu, trans_id %lu\n", oldest_start - rs->s_journal_block, oldest_trans_id) ;
+      } else if (oldest_trans_id > desc->j_trans_id) { /* one we just read was older */
+        oldest_trans_id = desc->j_trans_id ;
 	oldest_start = d_bh->b_blocknr ;
-	reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1180: Resetting "
-	               "oldest_start to offset %lu, trans_id %lu\n", 
-			oldest_start - reiserfs_get_journal_block(p_s_sb), 
-			oldest_trans_id) ;
-      }
-      if (newest_mount_id < le32_to_cpu(desc->j_mount_id)) {
-        newest_mount_id = le32_to_cpu(desc->j_mount_id) ;
-	reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1299: Setting "
-	              "newest_mount_id to %d\n", le32_to_cpu(desc->j_mount_id));
+printk("journal-1180: Resetting oldest_start to offset %lu, trans_id %lu\n", 
+        oldest_start - rs->s_journal_block, oldest_trans_id) ;
       }
-      cur_dblock += le32_to_cpu(desc->j_len) + 2 ;
+      if (newest_mount_id < desc->j_mount_id) {
+        newest_mount_id = desc->j_mount_id ;
+printk("journal-1299: Setting newest_mount_id to %d\n", desc->j_mount_id) ;
+      }
+      cur_dblock += desc->j_len + 2 ;
     } 
     else {
       cur_dblock++ ;
@@ -1737,13 +1419,9 @@ static int journal_read(struct super_blo
     oldest_trans_id = last_flush_trans_id + 1 ;
   } 
   cur_dblock = oldest_start ;
-  if (oldest_trans_id)  {
-    reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1206: Starting replay "
-                   "from offset %lu, trans_id %lu\n", 
-		   cur_dblock - reiserfs_get_journal_block(p_s_sb), 
-		   oldest_trans_id) ;
+  if (oldest_trans_id) 
+    printk("journal-1206: Starting replay from offset %lu, trans_id %lu\n", cur_dblock - rs->s_journal_block, oldest_trans_id) ;
 
-  }
   replay_count = 0 ;
   while(continue_replay && oldest_trans_id > 0) {
     ret = journal_read_transaction(p_s_sb, cur_dblock, oldest_start, oldest_trans_id, newest_mount_id) ;
@@ -1752,44 +1430,31 @@ static int journal_read(struct super_blo
     } else if (ret != 0) {
       break ;
     }
-    cur_dblock = reiserfs_get_journal_block(p_s_sb) + SB_JOURNAL(p_s_sb)->j_start ;
+    cur_dblock = rs->s_journal_block + SB_JOURNAL(p_s_sb)->j_start ;
     replay_count++ ;
    if (cur_dblock == oldest_start)
         break;
   }
 
   if (oldest_trans_id == 0) {
-    reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1225: No valid "
-                   "transactions found\n") ;
+    printk("journal-1225: No valid transactions found\n") ;
   }
   /* j_start does not get set correctly if we don't replay any transactions.
   ** if we had a valid journal_header, set j_start to the first unflushed transaction value,
   ** copy the trans_id from the header
   */
   if (valid_journal_header && replay_count == 0) { 
-    SB_JOURNAL(p_s_sb)->j_start = le32_to_cpu(jh->j_first_unflushed_offset) ;
-    SB_JOURNAL(p_s_sb)->j_trans_id = le32_to_cpu(jh->j_last_flush_trans_id) + 1;
-    SB_JOURNAL(p_s_sb)->j_last_flush_trans_id = le32_to_cpu(jh->j_last_flush_trans_id) ;
-    SB_JOURNAL(p_s_sb)->j_mount_id = le32_to_cpu(jh->j_mount_id) + 1;
+    SB_JOURNAL(p_s_sb)->j_start = jh->j_first_unflushed_offset ;
+    SB_JOURNAL(p_s_sb)->j_trans_id = jh->j_last_flush_trans_id + 1 ;
+    SB_JOURNAL(p_s_sb)->j_last_flush_trans_id = jh->j_last_flush_trans_id ;
+    SB_JOURNAL(p_s_sb)->j_mount_id = jh->j_mount_id + 1;
   } else {
     SB_JOURNAL(p_s_sb)->j_mount_id = newest_mount_id + 1 ;
   }
-  reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1299: Setting "
-                 "newest_mount_id to %lu\n", SB_JOURNAL(p_s_sb)->j_mount_id) ;
+printk("journal-1299: Setting newest_mount_id to %lu\n", SB_JOURNAL(p_s_sb)->j_mount_id) ;
   SB_JOURNAL(p_s_sb)->j_first_unflushed_offset = SB_JOURNAL(p_s_sb)->j_start ; 
-  if (replay_count > 0) {
-    printk("reiserfs: replayed %d transactions in %lu seconds\n", replay_count, 
-	    CURRENT_TIME - start) ;
-  }
-  if (!is_read_only(p_s_sb->s_dev) && 
-       _update_journal_header_block(p_s_sb, SB_JOURNAL(p_s_sb)->j_start, 
-                                   SB_JOURNAL(p_s_sb)->j_last_flush_trans_id))
-  {
-      /* replay failed, caller must call free_journal_ram and abort
-      ** the mount
-      */
-      return -1 ;
-  }
+  printk("journal-1230: Total replay time: %lu seconds\n", CURRENT_TIME - start) ;
+  update_journal_header_block(p_s_sb, SB_JOURNAL(p_s_sb)->j_start, SB_JOURNAL(p_s_sb)->j_last_flush_trans_id) ;
   return 0 ;
 }
 
@@ -1807,15 +1472,8 @@ struct reiserfs_journal_commit_task {
 
 static void reiserfs_journal_commit_task_func(struct reiserfs_journal_commit_task *ct) {
 
-  struct reiserfs_journal_list *jl ;
-  jl = SB_JOURNAL_LIST(ct->p_s_sb) + ct->jindex ;
-
   flush_commit_list(ct->p_s_sb, SB_JOURNAL_LIST(ct->p_s_sb) + ct->jindex, 1) ; 
-  if (jl->j_len > 0 && atomic_read(&(jl->j_nonzerolen)) > 0 && 
-      atomic_read(&(jl->j_commit_left)) == 0) {
-    kupdate_one_transaction(ct->p_s_sb, jl) ;
-  }
-  reiserfs_kfree(ct->self, sizeof(struct reiserfs_journal_commit_task), ct->p_s_sb) ;
+  kfree(ct->self) ;
 }
 
 static void setup_commit_task_arg(struct reiserfs_journal_commit_task *ct,
@@ -1827,7 +1485,7 @@ static void setup_commit_task_arg(struct
   ct->p_s_sb = p_s_sb ;
   ct->jindex = jindex ;
   ct->task_done = NULL ;
-  INIT_LIST_HEAD(&ct->task.list) ;
+  ct->task.next = NULL ;
   ct->task.sync = 0 ;
   ct->task.routine = (void *)(void *)reiserfs_journal_commit_task_func ; 
   ct->self = ct ;
@@ -1864,29 +1522,35 @@ static void commit_flush_async(struct su
 ** then run the per filesystem commit task queue when we wakeup.
 */
 static int reiserfs_journal_commit_thread(void *nullp) {
-
-  daemonize() ;
+  int windex ;
+  exit_files(current);
+  exit_mm(current);
 
   spin_lock_irq(&current->sigmask_lock);
   sigfillset(&current->blocked);
   recalc_sigpending(current);
   spin_unlock_irq(&current->sigmask_lock);
 
+  current->session = 1;
+  current->pgrp = 1;
   sprintf(current->comm, "kreiserfsd") ;
   lock_kernel() ;
   while(1) {
+    windex = push_journal_writer("commit thread") ;
 
-    while(TQ_ACTIVE(reiserfs_commit_thread_tq)) {
+    while(reiserfs_commit_thread_tq) {
       run_task_queue(&reiserfs_commit_thread_tq) ;
     }
 
     /* if there aren't any more filesystems left, break */
     if (reiserfs_mounted_fs_count <= 0) {
       run_task_queue(&reiserfs_commit_thread_tq) ;
+      pop_journal_writer(windex) ;
       break ;
     }
     wake_up(&reiserfs_commit_thread_done) ;
-    interruptible_sleep_on_timeout(&reiserfs_commit_thread_wait, 5 * HZ) ;
+    pop_journal_writer(windex) ;
+    interruptible_sleep_on_timeout(&reiserfs_commit_thread_wait, 5) ;
   }
   unlock_kernel() ;
   wake_up(&reiserfs_commit_thread_done) ;
@@ -1910,14 +1574,14 @@ int journal_init(struct super_block *p_s
   if (sizeof(struct reiserfs_journal_commit) != 4096 ||
       sizeof(struct reiserfs_journal_desc) != 4096
      ) {
-    printk("journal-1249: commit or desc struct not 4096 %Zd %Zd\n", sizeof(struct reiserfs_journal_commit), 
+    printk("journal-1249: commit or desc struct not 4096 %d %d\n", sizeof(struct reiserfs_journal_commit), 
         sizeof(struct reiserfs_journal_desc)) ;
     return 1 ;
   }
   /* sanity check to make sure they don't overflow the journal */
-  if (JOURNAL_BLOCK_COUNT > reiserfs_get_journal_orig_size(p_s_sb)) {
-    printk("journal-1393: current JOURNAL_BLOCK_COUNT (%d) is too big.  This FS was created with a journal size of %lu blocks\n",
-            JOURNAL_BLOCK_COUNT, reiserfs_get_journal_orig_size(p_s_sb)) ;
+  if (JOURNAL_BLOCK_COUNT > le32_to_cpu (SB_DISK_SUPER_BLOCK(p_s_sb)->s_orig_journal_size)) {
+    printk("journal-1393: current JOURNAL_BLOCK_COUNT (%d) is too big.  This FS was created with a journal size of %d blocks\n",
+            JOURNAL_BLOCK_COUNT, le32_to_cpu (SB_DISK_SUPER_BLOCK(p_s_sb)->s_orig_journal_size)) ;
     return 1 ;
   }
   SB_JOURNAL(p_s_sb) = vmalloc(sizeof (struct reiserfs_journal)) ;
@@ -1938,12 +1602,7 @@ int journal_init(struct super_block *p_s
   memset(SB_JOURNAL(p_s_sb)->j_list_hash_table, 0, JOURNAL_HASH_SIZE * sizeof(struct reiserfs_journal_cnode *)) ;
   memset(journal_writers, 0, sizeof(char *) * 512) ; /* debug code */
 
-  INIT_LIST_HEAD(&SB_JOURNAL(p_s_sb)->j_bitmap_nodes) ;
-  INIT_LIST_HEAD(&(SB_JOURNAL(p_s_sb)->j_dummy_inode.i_dirty_buffers)) ;
-  reiserfs_allocate_list_bitmaps(p_s_sb, SB_JOURNAL(p_s_sb)->j_list_bitmap, 
-                                 SB_BMAP_NR(p_s_sb)) ;
-  allocate_bitmap_nodes(p_s_sb) ;
-
+  allocate_list_bitmaps(p_s_sb) ;
   SB_JOURNAL(p_s_sb)->j_start = 0 ;
   SB_JOURNAL(p_s_sb)->j_len = 0 ;
   SB_JOURNAL(p_s_sb)->j_len_alloc = 0 ;
@@ -1973,7 +1632,6 @@ int journal_init(struct super_block *p_s
   }
   if (journal_read(p_s_sb) < 0) {
     reiserfs_warning("Replay Failure, unable to mount\n") ;
-    free_journal_ram(p_s_sb) ;
     return 1 ;
   }
   SB_JOURNAL_LIST_INDEX(p_s_sb) = 0 ; /* once the read is done, we can set this
@@ -2011,32 +1669,6 @@ int journal_transaction_should_end(struc
   return 0 ;
 }
 
-/* this must be called inside a transaction, and requires the 
-** kernel_lock to be held
-*/
-void reiserfs_block_writes(struct reiserfs_transaction_handle *th) {
-    struct super_block *s = th->t_super ;
-    SB_JOURNAL(s)->j_must_wait = 1 ;
-    set_bit(WRITERS_BLOCKED, &SB_JOURNAL(s)->j_state) ;
-    return ;
-}
-
-/* this must be called without a transaction started, and does not
-** require BKL
-*/
-void reiserfs_allow_writes(struct super_block *s) {
-    clear_bit(WRITERS_BLOCKED, &SB_JOURNAL(s)->j_state) ;
-    wake_up(&SB_JOURNAL(s)->j_join_wait) ;
-}
-
-/* this must be called without a transaction started, and does not
-** require BKL
-*/
-void reiserfs_wait_on_write_block(struct super_block *s) {
-    wait_event(SB_JOURNAL(s)->j_join_wait, 
-               !test_bit(WRITERS_BLOCKED, &SB_JOURNAL(s)->j_state)) ;
-}
-
 /* join == true if you must join an existing transaction.
 ** join == false if you can deal with waiting for others to finish
 **
@@ -2045,34 +1677,41 @@ void reiserfs_wait_on_write_block(struct
 */
 static int do_journal_begin_r(struct reiserfs_transaction_handle *th, struct super_block * p_s_sb,unsigned long nblocks,int join) {
   time_t now = CURRENT_TIME ;
+  int windex  ;
   int old_trans_id  ;
+  /*   int free_some_ram = 0 ; -Hans */
 
   reiserfs_check_lock_depth("journal_begin") ;
-  RFALSE( p_s_sb->s_flags & MS_RDONLY, 
-	  "clm-2078: calling journal_begin on readonly FS") ;
 
   if (reiserfs_dont_log(p_s_sb)) {
     th->t_super = p_s_sb ; /* others will check this for the don't log flag */
     return 0 ;
   }
-  PROC_INFO_INC( p_s_sb, journal.journal_being );
-
-relock:
-  lock_journal(p_s_sb) ;
 
-  if (test_bit(WRITERS_BLOCKED, &SB_JOURNAL(p_s_sb)->j_state)) {
-    unlock_journal(p_s_sb) ;
-    reiserfs_wait_on_write_block(p_s_sb) ;
-    PROC_INFO_INC( p_s_sb, journal.journal_relock_writers );
-    goto relock ;
+  /* we never want to make kswapd wait, never, ever.  So, the only time
+  ** we make it wait is when joining the transaction would result in
+  ** overflow.
+  **
+  ** ugly, nasty stuff, we need real callbacks from the VFS layer to do
+  ** this right.
+  */
+  if (!strcmp(current->comm, "kswapd")) {
+    /*
+    SB_JOURNAL(p_s_sb)->j_must_wait = 1 ;
+    flush_async_commits(p_s_sb) ;
+    */
+    if ((SB_JOURNAL(p_s_sb)->j_len_alloc + nblocks + 2) < JOURNAL_MAX_BATCH) {
+      join = 1 ;
+    }
   }
 
+  lock_journal(p_s_sb) ;
+
   /* if there is no room in the journal OR
   ** if this transaction is too old, and we weren't called joinable, wait for it to finish before beginning 
   ** we don't sleep if there aren't other writers
   */
 
-
   if (  (!join && SB_JOURNAL(p_s_sb)->j_must_wait > 0) ||
      ( !join && (SB_JOURNAL(p_s_sb)->j_len_alloc + nblocks + 2) >= JOURNAL_MAX_BATCH) || 
      (!join && atomic_read(&(SB_JOURNAL(p_s_sb)->j_wcount)) > 0 && SB_JOURNAL(p_s_sb)->j_trans_start_time > 0 && 
@@ -2088,8 +1727,10 @@ relock:
     if (atomic_read(&(SB_JOURNAL(p_s_sb)->j_wcount)) <= 0) {
       struct reiserfs_transaction_handle myth ;
       journal_join(&myth, p_s_sb, 1) ;
+      windex = push_journal_writer("journal_begin") ;
       reiserfs_prepare_for_journal(p_s_sb, SB_BUFFER_WITH_SB(p_s_sb), 1) ;
       journal_mark_dirty(&myth, p_s_sb, SB_BUFFER_WITH_SB(p_s_sb)) ;
+      pop_journal_writer(windex) ;
       do_journal_end(&myth, p_s_sb,1,COMMIT_NOW) ;
     } else {
       /* but if the writer count isn't zero, we have to wait for the current writers to finish.
@@ -2102,7 +1743,6 @@ relock:
 	sleep_on(&(SB_JOURNAL(p_s_sb)->j_join_wait)) ;
       }
     }
-    PROC_INFO_INC( p_s_sb, journal.journal_relock_wcount );
     goto relock ;
   }
 
@@ -2147,16 +1787,17 @@ int journal_prepare(struct super_block  
 int journal_mark_dirty(struct reiserfs_transaction_handle *th, struct super_block *p_s_sb, struct buffer_head *bh) {
   struct reiserfs_journal_cnode *cn = NULL;
   int count_already_incd = 0 ;
+  int windex ;
   int prepared = 0 ;
 
-  PROC_INFO_INC( p_s_sb, journal.mark_dirty );
   if (reiserfs_dont_log(th->t_super)) {
-    mark_buffer_dirty(bh) ;
+    mark_buffer_dirty(bh, 1) ;
     return 0 ;
   }
 
+  windex = push_journal_writer("journal_mark_dirty") ;
   if (th->t_trans_id != SB_JOURNAL(p_s_sb)->j_trans_id) {
-    reiserfs_panic(th->t_super, "journal-1577: handle trans id %ld != current trans id %ld\n", 
+    reiserfs_panic(th->t_super, "journal-1577: handle trans id %d != current trans id %d\n", 
                    th->t_trans_id, SB_JOURNAL(p_s_sb)->j_trans_id);
   }
   p_s_sb->s_dirt = 1 ;
@@ -2164,25 +1805,28 @@ int journal_mark_dirty(struct reiserfs_t
   prepared = test_and_clear_bit(BH_JPrepared, &bh->b_state) ;
   /* already in this transaction, we are done */
   if (buffer_journaled(bh)) {
-    PROC_INFO_INC( p_s_sb, journal.mark_dirty_already );
+    pop_journal_writer(windex) ;
     return 0 ;
   }
 
+#if 0
   /* this must be turned into a panic instead of a warning.  We can't allow
   ** a dirty or journal_dirty or locked buffer to be logged, as some changes
   ** could get to disk too early.  NOT GOOD.
   */
-  if (!prepared || buffer_locked(bh)) {
+  if (!prepared || buffer_locked(bh) || buffer_dirty(bh)) {
     printk("journal-1777: buffer %lu bad state %cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\n", bh->b_blocknr, prepared ? ' ' : '!', 
                             buffer_locked(bh) ? ' ' : '!',
 			    buffer_dirty(bh) ? ' ' : '!',
 			    buffer_journal_dirty(bh) ? ' ' : '!') ;
     show_reiserfs_locks() ;
   }
+#endif
   count_already_incd = clear_prepared_bits(bh) ;
 
   if (atomic_read(&(SB_JOURNAL(p_s_sb)->j_wcount)) <= 0) {
     printk("journal-1409: journal_mark_dirty returning because j_wcount was %d\n", atomic_read(&(SB_JOURNAL(p_s_sb)->j_wcount))) ;
+    pop_journal_writer(windex) ;
     return 1 ;
   }
   /* this error means I've screwed up, and we've overflowed the transaction.  
@@ -2194,7 +1838,6 @@ int journal_mark_dirty(struct reiserfs_t
 
   if (buffer_journal_dirty(bh)) {
     count_already_incd = 1 ;
-    PROC_INFO_INC( p_s_sb, journal.mark_dirty_notjournal );
     mark_buffer_notjournal_dirty(bh) ;
   }
 
@@ -2246,6 +1889,7 @@ int journal_mark_dirty(struct reiserfs_t
     SB_JOURNAL(p_s_sb)->j_last = cn ;
   }
 done:
+  pop_journal_writer(windex) ;
   return 0 ;
 }
 
@@ -2255,14 +1899,18 @@ done:
 ** that don't need journaling
 */
 int journal_mark_dirty_nolog(struct reiserfs_transaction_handle *th, struct super_block *p_s_sb, struct buffer_head *bh) {
+  int windex = push_journal_writer("dirty_nolog") ;
   if (reiserfs_dont_log(th->t_super) || buffer_journaled(bh) || 
       buffer_journal_dirty(bh)) {
+    pop_journal_writer(windex) ;
     return journal_mark_dirty(th, p_s_sb, bh) ;
   }
   if (get_journal_hash_dev(SB_JOURNAL(p_s_sb)->j_list_hash_table, bh->b_dev,bh->b_blocknr,bh->b_size)) {
+    pop_journal_writer(windex) ;
     return journal_mark_dirty(th, p_s_sb, bh) ;
   }
-  mark_buffer_dirty(bh) ;
+  mark_buffer_dirty(bh , 0) ;
+  pop_journal_writer(windex) ;
   return 0 ;
 }
 
@@ -2339,25 +1987,21 @@ static int can_dirty(struct reiserfs_jou
   struct reiserfs_journal_cnode *cur = cn->hprev ;
   int can_dirty = 1 ;
   
-  /* first test hprev.  These are all newer than cn, so any node here
-  ** with the name block number and dev means this node can't be sent
-  ** to disk right now.
-  */
+  /* first test backwards */
   while(cur && can_dirty) {
-    if (cur->jlist && cur->bh && cur->blocknr && cur->dev == dev && 
-        cur->blocknr == blocknr) {
+    if (cur->jlist && cur->jlist->j_len > 0 && atomic_read(&(cur->jlist->j_commit_left)) > 0 && cur->bh && cur->blocknr && 
+        cur->dev == dev && cur->blocknr == blocknr 
+    ) {
       can_dirty = 0 ;
     }
     cur = cur->hprev ;
   }
-  /* then test hnext.  These are all older than cn.  As long as they
-  ** are committed to the log, it is safe to write cn to disk
-  */
+  /* then test fowards */
   cur = cn->hnext ;
   while(cur && can_dirty) {
-    if (cur->jlist && cur->jlist->j_len > 0 && 
-        atomic_read(&(cur->jlist->j_commit_left)) > 0 && cur->bh && 
-        cur->blocknr && cur->dev == dev && cur->blocknr == blocknr) {
+    if (cur->jlist && cur->jlist->j_len > 0 && atomic_read(&(cur->jlist->j_commit_left)) > 0 && cur->bh && cur->blocknr && 
+        cur->dev == dev && cur->blocknr == blocknr 
+    ) {
       can_dirty = 0 ;
     }
     cur = cur->hnext ;
@@ -2365,6 +2009,47 @@ static int can_dirty(struct reiserfs_jou
   return can_dirty ;
 }
 
+/*
+** Whereever possible, this dirties and releases the real blocks associated 
+** with a transaction
+** 
+** called by flush_commit_list, after all the log blocks for a transaction 
+** are on disk.  
+*/
+static void dirty_journal_list(struct super_block *p_s_sb, struct reiserfs_journal_list *jl) {
+  struct buffer_head *tbh ;
+  struct reiserfs_journal_cnode *cn ;
+  int dirty_it  ;
+  int windex = push_journal_writer("dirty_journal_list") ;
+
+  cn = jl->j_realblock ;
+
+  while(cn) {
+    /* remove_from_journal_list invalidates the bh in j_realblock, must 
+    ** copy it first */
+    tbh = cn->bh ;
+
+    /* default to dirty the block */
+    dirty_it = 1 ;
+    if (cn->blocknr && tbh) {
+      /* we only want to dirty the block if all the log blocks in all 
+         his transactions are on disk */
+      dirty_it = can_dirty(cn) ;
+      if (dirty_it) {
+	if (buffer_journal_dirty(tbh)) {
+	  if (test_bit(BH_JPrepared, &tbh->b_state)) {
+	    set_bit(BH_JRestore_dirty, &tbh->b_state) ;
+	  } else {
+	    mark_buffer_dirty(tbh, 0) ;
+	  }
+	} 
+      }
+    }
+    cn = cn->next ;
+  }
+  pop_journal_writer(windex) ;
+}
+
 /* syncs the commit blocks, but does not force the real buffers to disk
 ** will wait until the current transaction is done/commited before returning 
 */
@@ -2395,12 +2080,15 @@ int show_reiserfs_locks(void) {
 */
 void flush_async_commits(struct super_block *p_s_sb) {
   int i ;
+  int windex ;
 
+  windex = push_journal_writer("flush_async_commits") ;
   for (i = 0 ; i < JOURNAL_LIST_COUNT ; i++) {
     if (i != SB_JOURNAL_LIST_INDEX(p_s_sb)) {
       flush_commit_list(p_s_sb, SB_JOURNAL_LIST(p_s_sb) + i, 1) ; 
     }
   }
+  pop_journal_writer(windex) ;
 }
 
 /*
@@ -2417,6 +2105,8 @@ int flush_old_commits(struct super_block
   int count = 0;
   int start ; 
   time_t now ; 
+  int windex ;
+  int keep_dirty = 0 ;
   struct reiserfs_transaction_handle th ; 
 
   start =  SB_JOURNAL_LIST_INDEX(p_s_sb) ;
@@ -2436,6 +2126,11 @@ int flush_old_commits(struct super_block
 	flush_commit_list(p_s_sb, SB_JOURNAL_LIST(p_s_sb) + i, 1) ;
       }
     }
+    /* now we free ram used by the old journal lists */
+    if (SB_JOURNAL_LIST(p_s_sb)[i].j_len > 0 && i != SB_JOURNAL_LIST_INDEX(p_s_sb))  {
+      flush_journal_list(p_s_sb, SB_JOURNAL_LIST(p_s_sb) + i, 1, 0) ; /* old_only, and don't flush all, 
+      					                                 we only want to reclaim nodes if it will be fast */
+    }
     i = (i + 1) % JOURNAL_LIST_COUNT ;
     count++ ;
   }
@@ -2446,9 +2141,15 @@ int flush_old_commits(struct super_block
      SB_JOURNAL(p_s_sb)->j_trans_start_time > 0 && 
      SB_JOURNAL(p_s_sb)->j_len > 0 && 
      (now - SB_JOURNAL(p_s_sb)->j_trans_start_time) > JOURNAL_MAX_TRANS_AGE) {
+/*
+printk("journal-1743: current trans is too old (%lu seconds)...flushing (immediate was %d)\n", 
+        now - SB_JOURNAL(p_s_sb)->j_trans_start_time, immediate) ;
+*/
     journal_join(&th, p_s_sb, 1) ;
+    windex = push_journal_writer("flush_old_commits") ;
     reiserfs_prepare_for_journal(p_s_sb, SB_BUFFER_WITH_SB(p_s_sb), 1) ;
     journal_mark_dirty(&th, p_s_sb, SB_BUFFER_WITH_SB(p_s_sb)) ;
+    pop_journal_writer(windex) ;
     do_journal_end(&th, p_s_sb,1, COMMIT_NOW) ;
   } else if (immediate) { /* belongs above, but I wanted this to be very explicit as a special case.  If they say to 
                              flush, we must be sure old transactions hit the disk too. */
@@ -2457,8 +2158,7 @@ int flush_old_commits(struct super_block
     journal_mark_dirty(&th, p_s_sb, SB_BUFFER_WITH_SB(p_s_sb)) ;
     do_journal_end(&th, p_s_sb,1, COMMIT_NOW | WAIT) ;
   }
-   reiserfs_journal_kupdate(p_s_sb) ;
-   return 0 ;
+  return keep_dirty ;
 }
 
 /*
@@ -2484,6 +2184,7 @@ static int check_journal_end(struct reis
     reiserfs_panic(th->t_super, "journal-1577: handle trans id %ld != current trans id %ld\n", 
                    th->t_trans_id, SB_JOURNAL(p_s_sb)->j_trans_id);
   }
+  PROC_INFO_INC( p_s_sb, journal.journal_being );
 
   SB_JOURNAL(p_s_sb)->j_len_alloc -= (th->t_blocks_allocated - th->t_blocks_logged) ;
   if (atomic_read(&(SB_JOURNAL(p_s_sb)->j_wcount)) > 0) { /* <= 0 is allowed.  unmounting might not call begin */
@@ -2576,6 +2277,7 @@ int journal_mark_freed(struct reiserfs_t
   struct buffer_head *bh = NULL ;
   struct reiserfs_list_bitmap *jb = NULL ;
   int cleaned = 0 ;
+  int windex = push_journal_writer("journal_mark_freed") ;
   
   if (reiserfs_dont_log(th->t_super)) {
     bh = sb_get_hash_table(p_s_sb, blocknr) ;
@@ -2584,6 +2286,7 @@ int journal_mark_freed(struct reiserfs_t
       BUG ();
     }
     brelse (bh);
+    pop_journal_writer(windex) ;
     return 0 ;
   }
   bh = sb_get_hash_table(p_s_sb, blocknr) ;
@@ -2598,7 +2301,7 @@ int journal_mark_freed(struct reiserfs_t
     if (!jb) {
       reiserfs_panic(p_s_sb, "journal-1702: journal_mark_freed, journal_list_bitmap is NULL\n") ;
     }
-    set_bit_in_list_bitmap(p_s_sb, blocknr, jb) ;
+    set_bit(blocknr, jb->bitmap) ;
 
     /* Note, the entire while loop is not allowed to schedule.  */
 
@@ -2641,6 +2344,7 @@ int journal_mark_freed(struct reiserfs_t
       printk("journal-2165: bh->b_count < 0\n") ;
     }
   }
+  pop_journal_writer(windex) ;
   return 0 ;
 }
 
@@ -2681,14 +2385,19 @@ void reiserfs_commit_for_inode(struct in
 
 void reiserfs_restore_prepared_buffer(struct super_block *p_s_sb, 
                                       struct buffer_head *bh) {
-  PROC_INFO_INC( p_s_sb, journal.restore_prepared );
   if (reiserfs_dont_log (p_s_sb))
     return;
 
   if (!bh) {
     return ;
   }
-  clear_bit(BH_JPrepared, &bh->b_state) ;
+  if (test_and_clear_bit(BH_JPrepared, &bh->b_state)) {
+    if (test_and_clear_bit(BH_JRestore_dirty, &bh->b_state)) {
+      if (!buffer_journaled(bh)) {
+	mark_buffer_dirty(bh, 0) ;
+      }
+    } 
+  } 
 }
 
 extern struct tree_balance *cur_tb ;
@@ -2701,27 +2410,255 @@ extern struct tree_balance *cur_tb ;
 */
 void reiserfs_prepare_for_journal(struct super_block *p_s_sb, 
                                   struct buffer_head *bh, int wait) {
+  int windex ;
   int retry_count = 0 ;
 
-  PROC_INFO_INC( p_s_sb, journal.prepare );
   if (reiserfs_dont_log (p_s_sb))
     return;
 
+  windex = push_journal_writer("prepare_for_journal") ;
   while(!test_bit(BH_JPrepared, &bh->b_state) ||
         (wait && buffer_locked(bh))) {
     if (buffer_journaled(bh)) {
       set_bit(BH_JPrepared, &bh->b_state) ;
+      pop_journal_writer(windex) ;
       return ;
     }
+    if (retry_count > 1) {
+printk("prepare_for_journal, retry count is %d\n", retry_count) ;
+    }
     set_bit(BH_JPrepared, &bh->b_state) ;
+    if (test_and_clear_bit(BH_Dirty, &bh->b_state)) {
+      set_bit(BH_JRestore_dirty, &bh->b_state) ;
+    }
     if (wait) {
-      RFALSE( buffer_locked(bh) && cur_tb != NULL,
-	      "waiting while do_balance was running\n") ;
+#ifdef CONFIG_REISERFS_CHECK
+      if (buffer_locked(bh) && cur_tb != NULL) {
+	char *crashnow = NULL ;
+printk("reiserfs_prepare_for_journal, waiting while do_balance was running\n") ;
+	*crashnow = 1 ;  
+      }
+#endif
       wait_on_buffer(bh) ;
     }
-    PROC_INFO_INC( p_s_sb, journal.prepare_retry );
     retry_count++ ;
   }
+  pop_journal_writer(windex) ;
+}
+
+/*
+** This can only be called from do_journal_end.
+** it runs through the list things that need flushing before the
+** transaction can commit, and writes each of them to disk
+**
+*/
+
+static void flush_pages_before_commit(struct reiserfs_transaction_handle *th,
+                                      struct super_block *p_s_sb) {
+  struct reiserfs_page_list *pl = SB_JOURNAL(p_s_sb)->j_flush_pages ;
+  struct reiserfs_page_list *pl_tmp ;
+  struct buffer_head *bh, *head ;
+  int count = 0 ;
+
+  /* first write each dirty unlocked buffer in the list */
+
+  while(pl) {
+    /* ugly.  journal_end can be called from get_block, which has a 
+    ** page locked.  So, we have to check to see if pl->page is the page
+    ** currently locked by the calling function, and if so, skip the
+    ** lock
+    */
+    if (!pl->do_not_lock) {
+      lock_page(pl->page) ;
+    }
+    if (!PageLocked(pl->page)) {
+      BUG() ;
+    }
+    if (pl->page->buffers) {
+      head = pl->page->buffers ;
+      bh = head ;
+      do {
+	if (bh->b_blocknr == pl->blocknr && buffer_dirty(bh) &&
+	    !buffer_locked(bh) && buffer_uptodate(bh) ) {
+	  ll_rw_block(WRITE, 1, &bh) ;
+	}
+	bh = bh->b_this_page ;
+      } while (bh != head) ;
+    }
+    if (!pl->do_not_lock) {
+      UnlockPage(pl->page) ;
+    }
+    pl = pl->next ;
+  }
+
+  /* now wait on them */
+
+  pl = SB_JOURNAL(p_s_sb)->j_flush_pages ;
+  while(pl) {
+    if (!pl->do_not_lock) {
+      lock_page(pl->page) ;
+    }
+    if (!PageLocked(pl->page)) {
+      BUG() ;
+    }
+    if (pl->page->buffers) {
+      head = pl->page->buffers ;
+      bh = head ;
+      do {
+	if (bh->b_blocknr == pl->blocknr) {
+	  count++ ;
+	  wait_on_buffer(bh) ;
+	  if (!buffer_uptodate(bh)) {
+	    reiserfs_panic(p_s_sb, "journal-2443: flush_pages_before_commit, error writing block %lu\n", bh->b_blocknr) ;
+	  }
+	}
+	bh = bh->b_this_page ;
+      } while (bh != head) ;
+    }
+    if (!pl->do_not_lock) {
+      UnlockPage(pl->page) ;
+    }
+
+    /* we've waited on the I/O, we can remove the page from the
+    ** list, and free our pointer struct to it.
+    */
+    if (pl->prev) {
+      pl->prev->next = pl->next ;
+    }
+    if (pl->next) {
+      pl->next->prev = pl->prev ;
+    }
+    put_page(pl->page) ;
+    pl_tmp = pl ;
+    pl = pl->next ;
+    reiserfs_kfree(pl_tmp, sizeof(struct reiserfs_page_list), p_s_sb) ;
+  }
+  SB_JOURNAL(p_s_sb)->j_flush_pages = NULL ;
+}
+
+/*
+** called when a indirect item is converted back into a tail.
+**
+** The reiserfs part of the inode stores enough information to find
+** our page_list struct in the flush list.  We remove it from the list
+** and free the struct.
+**
+** Note, it is possible for this to happen:
+**
+** reiserfs_add_page_to_flush_list(inode)
+** transaction ends, list is flushed
+** reiserfs_remove_page_from_flush_list(inode)
+**
+** This would be bad because the page_list pointer in the inode is not
+** updated when the list is flushed, so we can't know if the pointer is
+** valid.  So, in the inode, we also store the transaction id when the
+** page was added.  If we are trying to remove something from an old 
+** transaction, we just clear out the pointer in the inode and return.
+**
+** Normal case is to use the reiserfs_page_list pointer in the inode to 
+** find and remove the page from the flush list.
+*/
+int reiserfs_remove_page_from_flush_list(struct reiserfs_transaction_handle *th,
+                                         struct inode *inode) {
+  struct reiserfs_page_list *pl ;
+
+  /* was this conversion done in a previous transaction? If so, return */
+  if (inode->u.reiserfs_i.i_conversion_trans_id < th->t_trans_id) {
+    inode->u.reiserfs_i.i_converted_page = NULL ;
+    inode->u.reiserfs_i.i_conversion_trans_id = 0  ;
+    return 0 ;
+  }
+
+  /* remove the page_list struct from the list, release our hold on the
+  ** page, and free the page_list struct
+  */
+  pl = inode->u.reiserfs_i.i_converted_page ;
+  if (pl) {
+    if (pl->next) {
+      pl->next->prev = pl->prev ;
+    }
+    if (pl->prev) {
+      pl->prev->next = pl->next ;
+    }
+    if (SB_JOURNAL(inode->i_sb)->j_flush_pages == pl) {
+      SB_JOURNAL(inode->i_sb)->j_flush_pages = pl->next ;
+    }
+    put_page(pl->page) ;
+    reiserfs_kfree(pl, sizeof(struct reiserfs_page_list), inode->i_sb) ;
+    inode->u.reiserfs_i.i_converted_page = NULL ;
+    inode->u.reiserfs_i.i_conversion_trans_id = 0 ;
+  }
+  return 0 ;
+}
+
+/*
+** Called after a direct to indirect transaction.  The unformatted node
+** must be flushed to disk before the transaction commits, otherwise, we
+** risk losing the data from the direct item.  This adds the page
+** containing the unformatted node to a list of pages that need flushing.
+**
+** it calls get_page(page), so the page won't disappear until we've
+** flushed or removed it from our list.
+**
+** pointers to the reiserfs_page_list struct are stored in the inode, 
+** so this page can be quickly removed from the list after the tail is
+** converted back into a direct item.
+**
+** If we fail to find the memory for the reiserfs_page_list struct, we
+** just sync the page now.  Not good, but safe.
+**
+** since this must be called with the page locked, we always set
+** the do_not_lock field in the page_list struct we allocate
+**
+*/
+int reiserfs_add_page_to_flush_list(struct reiserfs_transaction_handle *th, 
+                                    struct inode *inode,
+				    struct buffer_head *bh) {
+  struct reiserfs_page_list *new_pl ;
+
+/* debugging use ONLY.  Do not define this on data you care about. */
+#ifdef REISERFS_NO_FLUSH_AFTER_CONVERT
+  return 0 ;
+#endif
+
+  get_page(bh->b_page) ;
+  new_pl = reiserfs_kmalloc(sizeof(struct reiserfs_page_list), GFP_NOFS,
+                            inode->i_sb) ;
+  if (!new_pl) {
+    put_page(bh->b_page) ;
+    reiserfs_warning("journal-2480: forced to flush page, out of memory\n") ;
+    ll_rw_block(WRITE, 1, &bh) ;
+    wait_on_buffer(bh) ;
+    if (!buffer_uptodate(bh)) {
+      reiserfs_panic(inode->i_sb, "journal-2484: error writing buffer %lu to disk\n", bh->b_blocknr) ;
+    }
+    inode->u.reiserfs_i.i_converted_page = NULL ;
+    return 0 ;
+  }
+
+  new_pl->page = bh->b_page ;
+  new_pl->do_not_lock = 1 ;
+  new_pl->blocknr = bh->b_blocknr ;
+  new_pl->next = SB_JOURNAL(inode->i_sb)->j_flush_pages; 
+  if (new_pl->next) {
+    new_pl->next->prev = new_pl ;
+  }
+  new_pl->prev = NULL ;
+  SB_JOURNAL(inode->i_sb)->j_flush_pages = new_pl ;
+  
+  /* if we have numbers from an old transaction, zero the converted
+  ** page, it has already been flushed and freed
+  */
+  if (inode->u.reiserfs_i.i_conversion_trans_id &&
+      inode->u.reiserfs_i.i_conversion_trans_id < th->t_trans_id) {
+    inode->u.reiserfs_i.i_converted_page = NULL ;
+  }
+  if (inode->u.reiserfs_i.i_converted_page) {
+    reiserfs_panic(inode->i_sb, "journal-2501: inode already had a converted page\n") ;
+  }
+  inode->u.reiserfs_i.i_converted_page = new_pl ;
+  inode->u.reiserfs_i.i_conversion_trans_id = th->t_trans_id ;
+  return 0 ;
 }
 
 /* 
@@ -2749,11 +2686,27 @@ static int do_journal_end(struct reiserf
   int commit_now = flags & COMMIT_NOW ;
   int wait_on_commit = flags & WAIT ;
   struct reiserfs_super_block *rs ; 
+  int windex = push_journal_writer("do_journal_end") ;
 
+  PROC_INFO_INC( p_s_sb, journal.mark_dirty );
   if (reiserfs_dont_log(th->t_super)) {
+    pop_journal_writer(windex) ;
     return 0 ;
   }
 
+  /* we must make sure all end_io tasks are done before we start marking
+  ** buffers as BH_JDirty_wait.  Otherwise, they could be released and
+  ** cleaned before they properly get to disk
+  **
+  ** we need the semaphore because other filesystems or journal writers
+  ** could be running the queue at the same time.  We have to make sure the
+  ** queue is *empty*, not just being worked on.
+  */
+  down(&reiserfs_end_io_sem) ;
+  run_task_queue(&reiserfs_end_io_tq) ;
+  up(&reiserfs_end_io_sem) ;
+
+
   lock_journal(p_s_sb) ;
   if (SB_JOURNAL(p_s_sb)->j_next_full_flush) {
     flags |= FLUSH_ALL ;
@@ -2768,6 +2721,7 @@ static int do_journal_end(struct reiserf
   ** it tells us if we should continue with the journal_end, or just return
   */
   if (!check_journal_end(th, p_s_sb, nblocks, flags)) {
+    pop_journal_writer(windex) ;
     return 0 ;
   }
 
@@ -2793,19 +2747,22 @@ static int do_journal_end(struct reiserf
   
   rs = SB_DISK_SUPER_BLOCK(p_s_sb) ;
   /* setup description block */
-  d_bh = sb_getblk(p_s_sb, reiserfs_get_journal_block(p_s_sb) + SB_JOURNAL(p_s_sb)->j_start) ; 
+  d_bh = getblk(p_s_sb->s_dev, rs->s_journal_block + SB_JOURNAL(p_s_sb)->j_start, p_s_sb->s_blocksize) ; 
   mark_buffer_uptodate(d_bh, 1) ;
   desc = (struct reiserfs_journal_desc *)(d_bh)->b_data ;
   memset(desc, 0, sizeof(struct reiserfs_journal_desc)) ;
   memcpy(desc->j_magic, JOURNAL_DESC_MAGIC, 8) ;
-  desc->j_trans_id = cpu_to_le32(SB_JOURNAL(p_s_sb)->j_trans_id) ;
+  desc->j_trans_id = SB_JOURNAL(p_s_sb)->j_trans_id ;
 
   /* setup commit block.  Don't write (keep it clean too) this one until after everyone else is written */
-  c_bh = sb_getblk(p_s_sb,  reiserfs_get_journal_block(p_s_sb) + 
-  				        ((SB_JOURNAL(p_s_sb)->j_start + SB_JOURNAL(p_s_sb)->j_len + 1) % JOURNAL_BLOCK_COUNT)) ;
+  c_bh = getblk(p_s_sb->s_dev,  rs->s_journal_block + 
+  				        ((SB_JOURNAL(p_s_sb)->j_start + SB_JOURNAL(p_s_sb)->j_len + 1) % JOURNAL_BLOCK_COUNT), 
+					 p_s_sb->s_blocksize) ;
+  d_bh->b_end_io = reiserfs_journal_end_io ;
+  c_bh->b_end_io = reiserfs_journal_end_io ; 
   commit = (struct reiserfs_journal_commit *)c_bh->b_data ;
   memset(commit, 0, sizeof(struct reiserfs_journal_commit)) ;
-  commit->j_trans_id = cpu_to_le32(SB_JOURNAL(p_s_sb)->j_trans_id) ;
+  commit->j_trans_id = SB_JOURNAL(p_s_sb)->j_trans_id ;
   mark_buffer_uptodate(c_bh, 1) ;
 
   /* init this journal list */
@@ -2845,39 +2802,43 @@ static int do_journal_end(struct reiserf
         last_cn->next = jl_cn ;
       }
       last_cn = jl_cn ;
-      if (cn->bh->b_blocknr >= reiserfs_get_journal_block(p_s_sb) &&
-          cn->bh->b_blocknr < (reiserfs_get_journal_block(p_s_sb) + JOURNAL_BLOCK_COUNT)) {
+      if (cn->bh->b_blocknr >= rs->s_journal_block &&
+          cn->bh->b_blocknr < (rs->s_journal_block + JOURNAL_BLOCK_COUNT)) {
         reiserfs_panic(p_s_sb, "journal-2332: Trying to log block %lu, which is a log block\n", cn->bh->b_blocknr) ;
       }
       jl_cn->blocknr = cn->bh->b_blocknr ; 
       jl_cn->state = 0 ;
       jl_cn->dev = cn->bh->b_dev ; 
       jl_cn->bh = cn->bh ;
+  if (cn->bh->b_end_io != reiserfs_end_buffer_io_sync) {
+printk("warning do_journal_end has buffers without our end_io\n") ;
+  }
       jl_cn->jlist = SB_JOURNAL_LIST(p_s_sb) + SB_JOURNAL_LIST_INDEX(p_s_sb) ;
       insert_journal_hash(SB_JOURNAL(p_s_sb)->j_list_hash_table, jl_cn) ; 
       if (i < JOURNAL_TRANS_HALF) {
-	desc->j_realblock[i] = cpu_to_le32(cn->bh->b_blocknr) ;
+	desc->j_realblock[i] = cn->bh->b_blocknr ;
       } else {
-	commit->j_realblock[i - JOURNAL_TRANS_HALF] = cpu_to_le32(cn->bh->b_blocknr) ;
+	commit->j_realblock[i - JOURNAL_TRANS_HALF] = cn->bh->b_blocknr ;
       }
     } else {
       i-- ;
     }
   }
 
-  desc->j_len = cpu_to_le32(SB_JOURNAL(p_s_sb)->j_len)  ;
-  desc->j_mount_id = cpu_to_le32(SB_JOURNAL(p_s_sb)->j_mount_id) ;
-  desc->j_trans_id = cpu_to_le32(SB_JOURNAL(p_s_sb)->j_trans_id) ;
-  commit->j_len = cpu_to_le32(SB_JOURNAL(p_s_sb)->j_len) ;
+  desc->j_len = SB_JOURNAL(p_s_sb)->j_len  ;
+  desc->j_mount_id = SB_JOURNAL(p_s_sb)->j_mount_id ;
+  desc->j_trans_id = SB_JOURNAL(p_s_sb)->j_trans_id ;
+  commit->j_len = SB_JOURNAL(p_s_sb)->j_len  ;
 
   /* special check in case all buffers in the journal were marked for not logging */
-  if (SB_JOURNAL(p_s_sb)->j_len == 0) {
+  if (desc->j_len == 0) {
     brelse(d_bh) ;
     brelse(c_bh) ;
     unlock_journal(p_s_sb) ;
 printk("journal-2020: do_journal_end: BAD desc->j_len is ZERO\n") ;
     atomic_set(&(SB_JOURNAL(p_s_sb)->j_jlock), 0) ;
     wake_up(&(SB_JOURNAL(p_s_sb)->j_join_wait)) ;
+    pop_journal_writer(windex) ;
     return 0 ;
   }
 
@@ -2890,8 +2851,10 @@ printk("journal-2020: do_journal_end: BA
     /* copy all the real blocks into log area.  dirty log blocks */
     if (test_bit(BH_JDirty, &cn->bh->b_state)) {
       struct buffer_head *tmp_bh ;
-      tmp_bh = sb_getblk(p_s_sb, reiserfs_get_journal_block(p_s_sb) + 
-		     ((cur_write_start + jindex) % JOURNAL_BLOCK_COUNT)) ;
+      tmp_bh = getblk(p_s_sb->s_dev, rs->s_journal_block + 
+		     ((cur_write_start + jindex) % JOURNAL_BLOCK_COUNT), 
+				       p_s_sb->s_blocksize) ;
+      tmp_bh->b_end_io = reiserfs_journal_end_io ;
       mark_buffer_uptodate(tmp_bh, 1) ;
       memcpy(tmp_bh->b_data, cn->bh->b_data, cn->bh->b_size) ;  
       jindex++ ;
@@ -2905,7 +2868,7 @@ printk("journal-2020: do_journal_end: BA
 
   /* we are done  with both the c_bh and d_bh, but
   ** c_bh must be written after all other commit blocks,
-  ** so we dirty/relse c_bh in flush_commit_list, with commit_left <= 1.
+  ** so we dirty/relse c_bh in journal_end_io, with commit_left <= 1.
   */
 
   /* now loop through and mark all buffers from this transaction as JDirty_wait
@@ -2941,7 +2904,7 @@ printk("journal-2020: do_journal_end: BA
   if (flush) {
   
     flush_commit_list(p_s_sb, SB_JOURNAL_LIST(p_s_sb) + orig_jindex, 1) ;
-    flush_journal_list(p_s_sb,  SB_JOURNAL_LIST(p_s_sb) + orig_jindex , 1) ;  
+    flush_journal_list(p_s_sb,  SB_JOURNAL_LIST(p_s_sb) + orig_jindex , 0, 1) ;  /* flush all */
   } else if (commit_now) {
     if (wait_on_commit) {
       flush_commit_list(p_s_sb, SB_JOURNAL_LIST(p_s_sb) + orig_jindex, 1) ;
@@ -2968,32 +2931,33 @@ printk("journal-2020: do_journal_end: BA
 
   /* if the next transaction has any chance of wrapping, flush 
   ** transactions that might get overwritten.  If any journal lists are very 
-  ** old flush them as well.  
+  ** old flush them as well.  Since data will get to disk every 30 seconds or
+  ** so, any list that has unflushed members after 2 minutes was a victim to
+  ** memory shortages during the end_io handler.  Clean things up for them
+  **
   */
-  for (i = 0 ; i < JOURNAL_LIST_COUNT ; i++) {
+  for (i =0 ; i < JOURNAL_LIST_COUNT ; i++) {
     jindex = i ;
     if (SB_JOURNAL_LIST(p_s_sb)[jindex].j_len > 0 && SB_JOURNAL(p_s_sb)->j_start <= SB_JOURNAL_LIST(p_s_sb)[jindex].j_start) {
       if ((SB_JOURNAL(p_s_sb)->j_start + JOURNAL_TRANS_MAX + 1) >= SB_JOURNAL_LIST(p_s_sb)[jindex].j_start) {
-	flush_journal_list(p_s_sb, SB_JOURNAL_LIST(p_s_sb) + jindex, 1) ; 
+	flush_journal_list(p_s_sb, SB_JOURNAL_LIST(p_s_sb) + jindex, 0, 1) ; /* do flush all */
       }
     } else if (SB_JOURNAL_LIST(p_s_sb)[jindex].j_len > 0 && 
               (SB_JOURNAL(p_s_sb)->j_start + JOURNAL_TRANS_MAX + 1) > JOURNAL_BLOCK_COUNT) {
       if (((SB_JOURNAL(p_s_sb)->j_start + JOURNAL_TRANS_MAX + 1) % JOURNAL_BLOCK_COUNT) >= 
             SB_JOURNAL_LIST(p_s_sb)[jindex].j_start) {
-	flush_journal_list(p_s_sb, SB_JOURNAL_LIST(p_s_sb) + jindex, 1 ) ; 
+	flush_journal_list(p_s_sb, SB_JOURNAL_LIST(p_s_sb) + jindex, 0,1 ) ; /* do flush all */
       }
-    } 
-    /* this check should always be run, to send old lists to disk */
-    if (SB_JOURNAL_LIST(p_s_sb)[jindex].j_len > 0 && 
+    } else if (SB_JOURNAL_LIST(p_s_sb)[jindex].j_len > 0 && 
               SB_JOURNAL_LIST(p_s_sb)[jindex].j_timestamp < 
 	      (CURRENT_TIME - (JOURNAL_MAX_TRANS_AGE * 4))) {
-	flush_journal_list(p_s_sb, SB_JOURNAL_LIST(p_s_sb) + jindex, 1 ) ; 
+	flush_journal_list(p_s_sb, SB_JOURNAL_LIST(p_s_sb) + jindex, 0,1 ) ; 
     }
   }
 
   /* if the next journal_list is still in use, flush it */
   if (SB_JOURNAL_LIST(p_s_sb)[SB_JOURNAL_LIST_INDEX(p_s_sb)].j_len != 0) {
-    flush_journal_list(p_s_sb, SB_JOURNAL_LIST(p_s_sb) + SB_JOURNAL_LIST_INDEX(p_s_sb), 1) ; 
+    flush_journal_list(p_s_sb, SB_JOURNAL_LIST(p_s_sb) + SB_JOURNAL_LIST_INDEX(p_s_sb), 0, 1) ; /* do flush all */
   }
 
   /* we don't want anyone flushing the new transaction's list */
@@ -3009,6 +2973,7 @@ printk("journal-2020: do_journal_end: BA
   atomic_set(&(SB_JOURNAL(p_s_sb)->j_jlock), 0) ;
   /* wake up any body waiting to join. */
   wake_up(&(SB_JOURNAL(p_s_sb)->j_join_wait)) ;
+  pop_journal_writer(windex) ;
   return 0 ;
 }
 
diff -urp linux/fs/reiserfs/lbalance.c new_kernel_src/fs/reiserfs/lbalance.c
--- linux/fs/reiserfs/lbalance.c	2001-12-21 17:42:03.000000000 +0000
+++ new_kernel_src/fs/reiserfs/lbalance.c	2002-02-08 08:32:14.000000000 +0000
@@ -1,13 +1,20 @@
 /*
- * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README
+ * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
  */
 
-#include <linux/config.h>
+#ifdef __KERNEL__
+
 #include <asm/uaccess.h>
 #include <linux/string.h>
 #include <linux/sched.h>
 #include <linux/reiserfs_fs.h>
 
+#else
+
+#include "nokernel.h"
+
+#endif
+
 /* these are used in do_balance.c */
 
 /* leaf_move_items
diff -urp linux/fs/reiserfs/namei.c new_kernel_src/fs/reiserfs/namei.c
--- linux/fs/reiserfs/namei.c	2009-06-10 21:00:37.000000000 +0100
+++ new_kernel_src/fs/reiserfs/namei.c	2002-03-25 03:10:33.000000000 +0000
@@ -1,24 +1,21 @@
 /*
- * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README
- *
- * Trivial changes by Alan Cox to remove EHASHCOLLISION for compatibility
- *
- * Trivial Changes:
- * Rights granted to Hans Reiser to redistribute under other terms providing
- * he accepts all liability including but not limited to patent, fitness
- * for purpose, and direct or indirect claims arising from failure to perform.
- *
- * NO WARRANTY
+ * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
  */
 
-#include <linux/config.h>
+#ifdef __KERNEL__
+
 #include <linux/sched.h>
-#include <linux/bitops.h>
 #include <linux/reiserfs_fs.h>
 #include <linux/smp_lock.h>
 
-#define INC_DIR_INODE_NLINK(i) if (i->i_nlink != 1) { i->i_nlink++; if (i->i_nlink >= REISERFS_LINK_MAX) i->i_nlink=1; }
-#define DEC_DIR_INODE_NLINK(i) if (i->i_nlink != 1) i->i_nlink--;
+#else
+
+#include "nokernel.h"
+
+#endif
+
+
+
 
 // directory item contains array of entry headers. This performs
 // binary search through that array
@@ -50,7 +47,7 @@ static int bin_search_in_dir_item (struc
 }
 
 
-// comment?  maybe something like set de to point to what the path points to?
+//
 static inline void set_de_item_location (struct reiserfs_dir_entry * de, struct path * path)
 {
     de->de_bh = get_last_bh (path);
@@ -102,17 +99,11 @@ static inline void store_de_entry_key (s
 }
 
 
-/* We assign a key to each directory item, and place multiple entries
-in a single directory item.  A directory item has a key equal to the
-key of the first directory entry in it.
-
-This function first calls search_by_key, then, if item whose first
-entry matches is not found it looks for the entry inside directory
-item found by search_by_key. Fills the path to the entry, and to the
-entry position in the item 
-
-*/
-
+/* first calls search_by_key, then, if item is not found looks for the
+   entry inside directory item found by search_by_key. (We assign a
+   key to each directory item, and place multiple entries in a single
+   directory item.)  Fills the path to the entry, and to the entry
+   position in the item */
 /* The function is NOT SCHEDULE-SAFE! */
 int search_by_entry_key (struct super_block * sb, const struct cpu_key * key,
 			 struct path * path, struct reiserfs_dir_entry * de)
@@ -122,11 +113,10 @@ int search_by_entry_key (struct super_bl
     retval = search_item (sb, key, path);
     switch (retval) {
     case ITEM_NOT_FOUND:
-	if (!PATH_LAST_POSITION (path)) {
-	    reiserfs_warning ("vs-7000: search_by_entry_key: search_by_key returned item position == 0");
-	    pathrelse(path) ;
-	    return IO_ERROR ;
-	}
+#ifdef CONFIG_REISERFS_CHECK
+	if (!PATH_LAST_POSITION (path))
+	    reiserfs_panic (sb, "vs-7000: search_by_entry_key: search_by_key returned item position == 0");
+#endif /* CONFIG_REISERFS_CHECK */
 	PATH_LAST_POSITION (path) --;
 
     case ITEM_FOUND:
@@ -167,12 +157,6 @@ int search_by_entry_key (struct super_bl
 
 
 /* Keyed 32-bit hash function using TEA in a Davis-Meyer function */
-
-/* The third component is hashed, and you can choose from more than
-   one hash function.  Per directory hashes are not yet implemented
-   but are thought about. This function should be moved to hashes.c
-   Jedi, please do so.  -Hans */
-
 static __u32 get_third_component (struct super_block * s, 
 				  const char * name, int len)
 {
@@ -216,10 +200,6 @@ static int reiserfs_match (struct reiser
 
 
 /* de's de_bh, de_ih, de_deh, de_item_num, de_entry_num are set already */
-
-				/* used when hash collisions exist */
-
-
 static int linear_search_in_dir_item (struct cpu_key * key, struct reiserfs_dir_entry * de,
 				      const char * name, int namelen)
 {
@@ -347,7 +327,7 @@ static struct dentry * reiserfs_lookup (
     reiserfs_check_lock_depth("lookup") ;
 
     if (dentry->d_name.len > REISERFS_MAX_NAME_LEN (dir->i_sb->s_blocksize))
-	return ERR_PTR(-ENAMETOOLONG);
+      return ERR_PTR(-ENAMETOOLONG);
 
     de.de_gen_number_bit_string = 0;
     retval = reiserfs_find_entry (dir, dentry->d_name.name, dentry->d_name.len, &path_to_entry, &de);
@@ -373,13 +353,8 @@ static struct dentry * reiserfs_lookup (
 // at the ext2 code and comparing. It's subfunctions contain no code
 // used as a template unless they are so labeled.
 //
-
-/* add entry to the directory (entry can be hidden). 
-
-insert definition of when hidden directories are used here -Hans
-
- Does not mark dir   inode dirty, do it after successesfull call to it */
-
+/* add entry to the directory (entry can be hidden). Does not mark dir
+   inode dirty, do it after successesfull call to it */
 static int reiserfs_add_entry (struct reiserfs_transaction_handle *th, struct inode * dir,
                                const char * name, int namelen, struct inode * inode,
 			       int visible)
@@ -388,7 +363,7 @@ static int reiserfs_add_entry (struct re
     struct reiserfs_de_head * deh;
     INITIALIZE_PATH (path);
     struct reiserfs_dir_entry de;
-    int bit_string [MAX_GENERATION_NUMBER / (sizeof(int) * 8) + 1];
+    char bit_string [MAX_GENERATION_NUMBER / 8 + 1];
     int gen_number;
     char small_buf[32+DEH_SIZE] ; /* 48 bytes now and we avoid kmalloc
                                      if we create file with short name */
@@ -439,51 +414,41 @@ static int reiserfs_add_entry (struct re
 
     /* find the proper place for the new entry */
     memset (bit_string, 0, sizeof (bit_string));
-    de.de_gen_number_bit_string = (char *)bit_string;
-    retval = reiserfs_find_entry (dir, name, namelen, &path, &de);
-    if( retval != NAME_NOT_FOUND ) {
+    de.de_gen_number_bit_string = bit_string;
+    if (reiserfs_find_entry (dir, name, namelen, &path, &de) == NAME_FOUND) {
 	if (buffer != small_buf)
 	    reiserfs_kfree (buffer, buflen, dir->i_sb);
 	pathrelse (&path);
-
-	if ( retval == IO_ERROR ) {
-	    return -EIO;
-	}
-
-        if (retval != NAME_FOUND) {
-	    reiserfs_warning ("zam-7002:" __FUNCTION__ ": \"reiserfs_find_entry\" has returned"
-                              " unexpected value (%d)\n", retval);
-       }
-
 	return -EEXIST;
     }
 
-    gen_number = find_first_zero_bit (bit_string, MAX_GENERATION_NUMBER + 1);
-    if (gen_number > MAX_GENERATION_NUMBER) {
-      /* there is no free generation number */
-      reiserfs_warning ("reiserfs_add_entry: Congratulations! we have got hash function screwed up\n");
-      if (buffer != small_buf)
-          reiserfs_kfree (buffer, buflen, dir->i_sb);
-      pathrelse (&path);
-      return -EBUSY;
-    }
-    /* adjust offset of directory enrty */
-    put_deh_offset(deh, SET_GENERATION_NUMBER(deh_offset(deh), gen_number));
-    set_cpu_key_k_offset (&entry_key, deh_offset(deh));
- 
-    /* update max-hash-collisions counter in reiserfs_sb_info */
-    PROC_INFO_MAX( th -> t_super, max_hash_collisions, gen_number );
- 		  
-    if (gen_number != 0) {	/* we need to re-search for the insertion point */
-      if (search_by_entry_key (dir->i_sb, &entry_key, &path, &de) != NAME_NOT_FOUND) {
-            reiserfs_warning ("vs-7032: reiserfs_add_entry: "
-                            "entry with this key (%K) already exists\n", &entry_key);
-
+    if (find_first_nonzero_bit (bit_string, MAX_GENERATION_NUMBER + 1) < MAX_GENERATION_NUMBER + 1) {
+	/* there are few names with given hash value */
+	gen_number = find_first_zero_bit (bit_string, MAX_GENERATION_NUMBER + 1);
+	if (gen_number > MAX_GENERATION_NUMBER) {
+	    /* there is no free generation number */
+	    reiserfs_warning ("reiserfs_add_entry: Congratulations! we have got hash function screwed up\n");
+	    if (buffer != small_buf)
+		reiserfs_kfree (buffer, buflen, dir->i_sb);
+	    pathrelse (&path);
+	    return -EBUSY; //HASHCOLLISION;//EBADSLT
+	}
+	/* adjust offset of directory enrty */
+	deh->deh_offset = cpu_to_le32 (SET_GENERATION_NUMBER (deh_offset (deh), gen_number));
+	set_cpu_key_k_offset (&entry_key, le32_to_cpu (deh->deh_offset));
+
+	/* find place for new entry */
+	if (search_by_entry_key (dir->i_sb, &entry_key, &path, &de) == NAME_FOUND) {
+	    reiserfs_warning ("vs-7032: reiserfs_add_entry: "
+			      "entry with this key (%k) already exists", &entry_key);
 	    if (buffer != small_buf)
 		reiserfs_kfree (buffer, buflen, dir->i_sb);
 	    pathrelse (&path);
 	    return -EBUSY;
 	}
+    } else {
+	deh->deh_offset = cpu_to_le32 (SET_GENERATION_NUMBER (le32_to_cpu (deh->deh_offset), 0));
+	set_cpu_key_k_offset (&entry_key, le32_to_cpu (deh->deh_offset));
     }
   
     /* perform the insertion of the entry that we have prepared */
@@ -640,10 +605,17 @@ static int reiserfs_mkdir (struct inode 
     journal_begin(&th, dir->i_sb, jbegin_count) ;
     windex = push_journal_writer("reiserfs_mkdir") ;
 
+    if (dir->i_nlink >= REISERFS_LINK_MAX) {
+	//FIXME: sd_nlink is 32 bit now
+	pop_journal_writer(windex) ;
+	journal_end(&th, dir->i_sb, jbegin_count) ;
+	iput(inode) ;
+	return -EMLINK;
+    }
     /* inc the link count now, so another writer doesn't overflow it while
     ** we sleep later on.
     */
-    INC_DIR_INODE_NLINK(dir)
+    dir->i_nlink ++; 
 
     mode = S_IFDIR | mode;
     inode = reiserfs_new_inode (&th, dir, mode, 0/*symlink*/,
@@ -666,7 +638,7 @@ static int reiserfs_mkdir (struct inode 
 				inode, 1/*visible*/);
     if (retval) {
 	inode->i_nlink = 0;
-	DEC_DIR_INODE_NLINK(dir);
+	dir->i_nlink-- ;
 	reiserfs_update_sd (&th, inode);
 	pop_journal_writer(windex) ;
 	journal_end(&th, dir->i_sb, jbegin_count) ;
@@ -747,20 +719,18 @@ static int reiserfs_rmdir (struct inode 
     }
 
     /* cut entry from dir directory */
-    retval = reiserfs_cut_from_item (&th, &path, &(de.de_entry_key), dir, 
-                                     NULL, /* page */ 
-				     0/*new file size - not used here*/);
+    retval = reiserfs_cut_from_item (&th, &path, &(de.de_entry_key), dir, 0/*new file size - not used here*/);
     if (retval < 0)
 	goto end_rmdir;
 
-    if ( inode->i_nlink != 2 && inode->i_nlink != 1 )
+    if (inode->i_nlink != 2)
 	printk ("reiserfs_rmdir: empty directory has nlink != 2 (%d)\n", inode->i_nlink);
 
     inode->i_nlink = 0;
     inode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;
     reiserfs_update_sd (&th, inode);
 
-    DEC_DIR_INODE_NLINK(dir)
+    dir->i_nlink --;
     dir->i_size -= (DEH_SIZE + de.de_entrylen);
     dir->i_blocks = ((dir->i_size + 511) >> 9);
     reiserfs_update_sd (&th, dir);
@@ -835,7 +805,7 @@ static int reiserfs_unlink (struct inode
 	inode->i_nlink = 1;
     }
 
-    retval = reiserfs_cut_from_item (&th, &path, &(de.de_entry_key), dir, NULL, 0);
+    retval = reiserfs_cut_from_item (&th, &path, &(de.de_entry_key), dir, 0);
     if (retval < 0)
 	goto end_unlink;
 
@@ -1028,7 +998,7 @@ static int entry_points_to_object (const
 }
 
 
-/* sets key of objectid the entry has to point to */
+/* sets key of objectd the entry has to point to */
 static void set_ino_in_dir_entry (struct reiserfs_dir_entry * de, struct key * key)
 {
     /* JDM These operations are endian safe - both are le */
@@ -1044,7 +1014,6 @@ static void set_ino_in_dir_entry (struct
 // at the ext2 code and comparing. It's subfunctions contain no code
 // used as a template unless they are so labeled.
 //
-
 /* 
  * process, that is going to call fix_nodes/do_balance must hold only
  * one path. If it holds 2 or more, it can get into endless waiting in
@@ -1079,10 +1048,10 @@ static int reiserfs_rename (struct inode
     retval = reiserfs_find_entry (old_dir, old_dentry->d_name.name, old_dentry->d_name.len,
 				  &old_entry_path, &old_de);
     pathrelse (&old_entry_path);
-    if (retval == IO_ERROR)
-	return -EIO;
-
-    if (retval != NAME_FOUND || old_de.de_objectid != old_inode->i_ino) {
+    if (retval != NAME_FOUND && old_de.de_objectid != old_inode->i_ino) {
+	// FIXME: IO error is possible here, but as ext2_rename does
+	// not detect it we do not as well
+	
 	return -ENOENT;
     }
 
@@ -1109,11 +1078,16 @@ static int reiserfs_rename (struct inode
 	/* inode number of .. must equal old_dir->i_ino */
 	if (dot_dot_de.de_objectid != old_dir->i_ino)
 	    return -EIO;
+
+	if (!new_inode && new_dir->i_nlink >= REISERFS_LINK_MAX)
+	    return -EMLINK;
     }
 
+
     journal_begin(&th, old_dir->i_sb, jbegin_count) ;
     windex = push_journal_writer("reiserfs_rename") ;
 
+
     /* add new entry (or find the existing one) */
     retval = reiserfs_add_entry (&th, new_dir, new_dentry->d_name.name, new_dentry->d_name.len, 
 				 old_inode, 0);
@@ -1170,15 +1144,7 @@ static int reiserfs_rename (struct inode
 	    // node containing ".." gets into transaction
 	    reiserfs_prepare_for_journal(old_inode->i_sb, dot_dot_de.de_bh, 1) ;
 	}
-				/* we should check seals here, not do
-                                   this stuff, yes? Then, having
-                                   gathered everything into RAM we
-                                   should lock the buffers, yes?  -Hans */
-				/* probably.  our rename needs to hold more 
-				** than one path at once.  The seals would 
-				** have to be written to deal with multi-path 
-				** issues -chris
-				*/
+
 	/* sanity checking before doing the rename - avoid races many
 	** of the above checks could have scheduled.  We have to be
 	** sure our items haven't been shifted by another process.
@@ -1228,26 +1194,22 @@ static int reiserfs_rename (struct inode
 
     if (new_inode) {
 	// adjust link number of the victim
-	if (S_ISDIR(new_inode->i_mode)) {
-	    new_inode->i_nlink  = 0;
-	} else {
-	    new_inode->i_nlink--;
-	}
+	new_inode->i_nlink--;
 	new_inode->i_ctime = CURRENT_TIME;
     }
 
     if (S_ISDIR(old_inode->i_mode)) {
-	// adjust ".." of renamed directory 
+      //if (dot_dot_de.de_bh) {
+	// adjust ".." of renamed directory
 	set_ino_in_dir_entry (&dot_dot_de, INODE_PKEY (new_dir));
 	journal_mark_dirty (&th, new_dir->i_sb, dot_dot_de.de_bh);
-	
-        if (!new_inode)
-	    /* there (in new_dir) was no directory, so it got new link
-	       (".."  of renamed directory) */
-	    INC_DIR_INODE_NLINK(new_dir);
-		
-	/* old directory lost one link - ".. " of renamed directory */
-	DEC_DIR_INODE_NLINK(old_dir);
+
+	old_dir->i_nlink--;
+	if (new_inode) {
+	    new_inode->i_nlink--;
+	} else {
+	    new_dir->i_nlink++;
+	}
     }
 
     // looks like in 2.3.99pre3 brelse is atomic. so we can use pathrelse
@@ -1257,41 +1219,19 @@ static int reiserfs_rename (struct inode
     // FIXME: this reiserfs_cut_from_item's return value may screw up
     // anybody, but it will panic if will not be able to find the
     // entry. This needs one more clean up
-    if (reiserfs_cut_from_item (&th, &old_entry_path, &(old_de.de_entry_key), old_dir, NULL, 0) < 0)
-	reiserfs_warning ("vs-7060: reiserfs_rename: couldn't not cut old name. Fsck later?\n");
+    if (reiserfs_cut_from_item (&th, &old_entry_path, &(old_de.de_entry_key), old_dir, 0) < 0)
+	reiserfs_warning ("vs-: reiserfs_rename: coudl not cut old name. Fsck later?\n");
 
     old_dir->i_size -= DEH_SIZE + old_de.de_entrylen;
     old_dir->i_blocks = ((old_dir->i_size + 511) >> 9);
 
     reiserfs_update_sd (&th, old_dir);
     reiserfs_update_sd (&th, new_dir);
-
-    if (new_inode) {
-	if (new_inode->i_nlink == 0)
-	    add_save_link (&th, new_inode, 0/* not truncate */);
+    if (new_inode)
 	reiserfs_update_sd (&th, new_inode);
-    }
 
     pop_journal_writer(windex) ;
     journal_end(&th, old_dir->i_sb, jbegin_count) ;
     return 0;
 }
 
-
-
-/*
- * directories can handle most operations...
- */
-struct inode_operations reiserfs_dir_inode_operations = {
-  //&reiserfs_dir_operations,	/* default_file_ops */
-    create:	reiserfs_create,
-    lookup:	reiserfs_lookup,
-    link:	reiserfs_link,
-    unlink:	reiserfs_unlink,
-    symlink:	reiserfs_symlink,
-    mkdir:	reiserfs_mkdir,
-    rmdir:	reiserfs_rmdir,
-    mknod:	reiserfs_mknod,
-    rename:	reiserfs_rename,
-};
-
diff -urp linux/fs/reiserfs/objectid.c new_kernel_src/fs/reiserfs/objectid.c
--- linux/fs/reiserfs/objectid.c	2009-06-10 21:00:37.000000000 +0100
+++ new_kernel_src/fs/reiserfs/objectid.c	2002-03-25 03:10:33.000000000 +0000
@@ -1,14 +1,20 @@
 /*
- * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README
+ * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
  */
+#ifdef __KERNEL__
 
-#include <linux/config.h>
 #include <linux/string.h>
 #include <linux/locks.h>
 #include <linux/random.h>
 #include <linux/sched.h>
 #include <linux/reiserfs_fs.h>
 
+#else
+
+#include "nokernel.h"
+
+#endif
+
 
 // find where objectid map starts
 #define objectid_map(s,rs) (old_format_only (s) ? \
diff -urp linux/fs/reiserfs/prints.c new_kernel_src/fs/reiserfs/prints.c
--- linux/fs/reiserfs/prints.c	2009-06-10 21:00:37.000000000 +0100
+++ new_kernel_src/fs/reiserfs/prints.c	2002-03-25 03:10:33.000000000 +0000
@@ -1,14 +1,21 @@
 /*
- * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README
+ * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
  */
 
-#include <linux/config.h>
+#include <stdarg.h>
 #include <linux/sched.h>
 #include <linux/fs.h>
 #include <linux/reiserfs_fs.h>
 #include <linux/string.h>
 
+#else
+
+#include "nokernel.h"
 #include <stdarg.h>
+#include <limits.h>
+
+#endif
+
 
 static char error_buf[1024];
 static char fmt_buf[1024];
@@ -18,11 +25,10 @@ static char off_buf[80];
 static char * reiserfs_cpu_offset (struct cpu_key * key)
 {
   if (cpu_key_k_type(key) == TYPE_DIRENTRY)
-    sprintf (off_buf, "%Lu(%Lu)", 
-	     (unsigned long long)GET_HASH_VALUE (cpu_key_k_offset (key)),
-	     (unsigned long long)GET_GENERATION_NUMBER (cpu_key_k_offset (key)));
+    sprintf (off_buf, "%Lu(%Lu)", GET_HASH_VALUE (cpu_key_k_offset (key)),
+	     GET_GENERATION_NUMBER (cpu_key_k_offset (key)));
   else
-    sprintf (off_buf, "0x%Lx", (unsigned long long)cpu_key_k_offset (key));
+    sprintf (off_buf, "0x%Lx", cpu_key_k_offset (key));
   return off_buf;
 }
 
@@ -33,11 +39,10 @@ static char * le_offset (struct key * ke
 
   version = le_key_version (key);
   if (le_key_k_type (version, key) == TYPE_DIRENTRY)
-    sprintf (off_buf, "%Lu(%Lu)", 
-	     (unsigned long long)GET_HASH_VALUE (le_key_k_offset (version, key)),
-	     (unsigned long long)GET_GENERATION_NUMBER (le_key_k_offset (version, key)));
+    sprintf (off_buf, "%Lu(%Lu)", GET_HASH_VALUE (le_key_k_offset (version, key)),
+	     GET_GENERATION_NUMBER (le_key_k_offset (version, key)));
   else
-    sprintf (off_buf, "0x%Lx", (unsigned long long)le_key_k_offset (version, key));
+    sprintf (off_buf, "0x%Lx", le_key_k_offset (version, key));
   return off_buf;
 }
 
@@ -263,18 +268,10 @@ void reiserfs_warning (const char * fmt,
 {
   do_reiserfs_warning(fmt);
   /* console_print (error_buf); */
-  printk (KERN_WARNING "%s", error_buf);
+  printk ("%s", error_buf);
 }
 
-void reiserfs_debug (struct super_block *s, int level, const char * fmt, ...)
-{
-#ifdef CONFIG_REISERFS_CHECK
-  do_reiserfs_warning(fmt);
-  printk (KERN_DEBUG "%s", error_buf);
-#else
-  ; 
-#endif
-}
+
 
 /* The format:
 
@@ -328,12 +325,33 @@ extern struct tree_balance * cur_tb;
 
 void reiserfs_panic (struct super_block * sb, const char * fmt, ...)
 {
+#ifdef __KERNEL__
   show_reiserfs_locks() ;
-  do_reiserfs_warning(fmt);
-  printk ( KERN_EMERG "%s", error_buf);
+#endif
+  do_reiserfs_warning;
+  printk ("%s", error_buf);
   BUG ();
+  /* console_print (error_buf); */
+
+#ifdef __KERNEL__
+
+  /* comment before release */
+  //for (;;);
+
+#if 0 /* this is not needed, the state is ignored */
+  if (sb && !(sb->s_flags & MS_RDONLY)) {
+    sb->u.reiserfs_sb.s_mount_state |= REISERFS_ERROR_FS;
+    sb->u.reiserfs_sb.s_rs->s_state = REISERFS_ERROR_FS;
+    
+    mark_buffer_dirty(sb->u.reiserfs_sb.s_sbh, 1);
+    sb->s_dirt = 1;
+  }
+#endif
+
+  /* this is to prevent panic from syncing this filesystem */
+  if (sb)
+    sb->s_flags |= MS_RDONLY;
 
-  /* this is not actually called, but makes reiserfs_panic() "noreturn" */
   panic ("REISERFS: panic (device %s): %s\n",
 	 sb ? kdevname(sb->s_dev) : "sb == 0", error_buf);
 }
diff -urp linux/fs/reiserfs/resize.c new_kernel_src/fs/reiserfs/resize.c
--- linux/fs/reiserfs/resize.c	2002-02-25 19:38:09.000000000 +0000
+++ new_kernel_src/fs/reiserfs/resize.c	2002-02-08 09:17:39.000000000 +0000
@@ -1,8 +1,5 @@
-/* 
- * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README
- */
- 
-/* 
+/* Copyright 1999 Hans Reiser, see README file for licensing details.
+ *
  * Written by Alexander Zarochentcev.
  *
  * The kernel part of the (on-line) reiserfs resizer.
@@ -12,7 +9,6 @@
 #include <linux/vmalloc.h>
 #include <linux/locks.h>
 #include <linux/string.h>
-#include <linux/errno.h>
 #include <linux/reiserfs_fs.h>
 #include <linux/reiserfs_fs_sb.h>
 
@@ -25,35 +21,35 @@ int reiserfs_resize (struct super_block 
 	unsigned int block_r_new, block_r;
 	
 	struct reiserfs_list_bitmap * jb;
-	struct reiserfs_list_bitmap jbitmap[JOURNAL_NUM_BITMAPS];
+	char * jbitmap[JOURNAL_NUM_BITMAPS];
 	
 	unsigned long int block_count, free_blocks;
 	int i;
-	int copy_size ;
 
 	sb = SB_DISK_SUPER_BLOCK(s);
 
 	if (SB_BLOCK_COUNT(s) >= block_count_new) {
 		printk("can\'t shrink filesystem on-line\n");
-		return -EINVAL;
+		return 1;
 	}
 
 	/* check the device size */
 	bh = sb_bread(s, block_count_new - 1);
 	if (!bh) {
 		printk("reiserfs_resize: can\'t read last block\n");
-		return -EINVAL;
+		return 1;
 	}	
-	bforget(bh);
+	brelse(bh);
 
 	/* old disk layout detection; those partitions can be mounted, but
 	 * cannot be resized */
 	if (SB_BUFFER_WITH_SB(s)->b_blocknr *	SB_BUFFER_WITH_SB(s)->b_size 
 		!= REISERFS_DISK_OFFSET_IN_BYTES ) {
 		printk("reiserfs_resize: unable to resize a reiserfs without distributed bitmap (fs version < 3.5.12)\n");
-		return -ENOTSUPP;
+		return 1;
 	}
-       
+
+	
 	/* count used bits in last bitmap block */
 	block_r = SB_BLOCK_COUNT(s) -
 	        (SB_BMAP_NR(s) - 1) * s->s_blocksize * 8;
@@ -70,90 +66,98 @@ int reiserfs_resize (struct super_block 
 	block_count = SB_BLOCK_COUNT(s);
 	bmap_nr     = SB_BMAP_NR(s);
 
-	/* resizing of reiserfs bitmaps (journal and real), if needed */
-	if (bmap_nr_new > bmap_nr) {	    
-	    /* reallocate journal bitmaps */
-	    if (reiserfs_allocate_list_bitmaps(s, jbitmap, bmap_nr_new) < 0) {
-		printk("reiserfs_resize: unable to allocate memory for journal bitmaps\n");
-		unlock_super(s) ;
-		return -ENOMEM ;
-	    }
-	    /* the new journal bitmaps are zero filled, now we copy in the bitmap
-	    ** node pointers from the old journal bitmap structs, and then
-	    ** transfer the new data structures into the journal struct.
-	    **
-	    ** using the copy_size var below allows this code to work for
-	    ** both shrinking and expanding the FS.
-	    */
-	    copy_size = bmap_nr_new < bmap_nr ? bmap_nr_new : bmap_nr ;
-	    copy_size = copy_size * sizeof(struct reiserfs_list_bitmap_node *) ;
-	    for (i = 0 ; i < JOURNAL_NUM_BITMAPS ; i++) {
-		struct reiserfs_bitmap_node **node_tmp ;
-		jb = SB_JOURNAL(s)->j_list_bitmap + i ;
-		memcpy(jbitmap[i].bitmaps, jb->bitmaps, copy_size) ;
-
-		/* just in case vfree schedules on us, copy the new
-		** pointer into the journal struct before freeing the 
-		** old one
-		*/
-		node_tmp = jb->bitmaps ;
-		jb->bitmaps = jbitmap[i].bitmaps ;
-		vfree(node_tmp) ;
-	    }	
-	
-	    /* allocate additional bitmap blocks, reallocate array of bitmap
-	     * block pointers */
-	    bitmap = reiserfs_kmalloc(sizeof(struct buffer_head *) * bmap_nr_new, GFP_KERNEL, s);
-	    if (!bitmap) {
-		printk("reiserfs_resize: unable to allocate memory.\n");
-		return -ENOMEM;
-	    }
-	    for (i = 0; i < bmap_nr; i++)
-		bitmap[i] = SB_AP_BITMAP(s)[i];
-	    for (i = bmap_nr; i < bmap_nr_new; i++) {
-		bitmap[i] = getblk(s->s_dev, i * s->s_blocksize * 8, s->s_blocksize);
-		memset(bitmap[i]->b_data, 0, sb->s_blocksize);
-		reiserfs_test_and_set_le_bit(0, bitmap[i]->b_data);
-
-		mark_buffer_dirty(bitmap[i]) ;
-		mark_buffer_uptodate(bitmap[i], 1);
-		ll_rw_block(WRITE, 1, bitmap + i);
-		wait_on_buffer(bitmap[i]);
-	    }	
-	    /* free old bitmap blocks array */
-	    reiserfs_kfree(SB_AP_BITMAP(s), 
-			   sizeof(struct buffer_head *) * bmap_nr, s);
-	    SB_AP_BITMAP(s) = bitmap;
+
+	/* reallocate journal bitmaps */
+	for (i = 0 ; i < JOURNAL_NUM_BITMAPS ; i++) {
+		jb = SB_JOURNAL(s)->j_list_bitmap + i;
+		jbitmap[i] = vmalloc(block_count_new / 8);
+		if (!jbitmap[i]) {
+			printk("reiserfs_resize: unable to allocate memory for journal bitmaps\n");
+			while (--i >= 0) 
+				vfree(jbitmap[i]);
+				journal_end(&th, s, 10);
+			return 1;
+		}
+		/* note these bitmaps exist only in memory */
+		memset(jbitmap[i], 0, block_count_new / 8);
+		memcpy(jbitmap[i], jb->bitmap, block_count / 8);
+/*		for(j = bmap_nr; j < bmap_nr_new ; j++)
+			set_bit(j * s->s_blocksize * 8, jbitmap[i]); */
+	}
+	for (i = 0 ; i < JOURNAL_NUM_BITMAPS ; i++) {
+		jb = SB_JOURNAL(s)->j_list_bitmap + i;
+		vfree(jb->bitmap);
+		jb->bitmap = jbitmap[i];
+	}	
+	
+	/* allocate additional bitmap blocks, reallocate array of bitmap
+	 * block pointers */
+	if (bmap_nr_new > bmap_nr) {
+		bitmap = reiserfs_kmalloc(sizeof(struct buffer_head *) * bmap_nr_new,
+								   GFP_KERNEL, s);
+		if (!bitmap) {
+			printk("reiserfs_resize: unable to allocate memory.\n");
+			return 1;
+		}
+		for (i = 0; i < bmap_nr; i++)
+			bitmap[i] = SB_AP_BITMAP(s)[i];
+		for (i = bmap_nr; i < bmap_nr_new; i++) {
+			bitmap[i] = reiserfs_getblk(s->s_dev, i * s->s_blocksize * 8, s->s_blocksize);
+			if(!bitmap[i]) {
+				printk("reiserfs_resize: getblk() failed");
+				while (--i >= bmap_nr) 
+					brelse(bitmap[i]);
+				reiserfs_kfree(bitmap, 
+					sizeof(struct buffer_head *) * bmap_nr_new, s);
+				return 1;
+			}
+			memset(bitmap[i]->b_data, 0, sb->s_blocksize);
+			reiserfs_test_and_set_le_bit(0, bitmap[i]->b_data);
+
+			mark_buffer_dirty(bitmap[i], 0);
+			mark_buffer_uptodate(bitmap[i], 1);
+			ll_rw_block(WRITE, 1, bitmap + i);
+			wait_on_buffer(bitmap[i]);
+		}	
+		/* free old bitmap blocks array */
+		reiserfs_kfree(SB_AP_BITMAP(s), 
+			sizeof(struct buffer_head *) * bmap_nr, s);
+		SB_AP_BITMAP(s) = bitmap;
 	}
 	
+	unlock_super(s) ; /* deadlock avoidance */
 	/* begin transaction */
 	journal_begin(&th, s, 10);
+	lock_super(s) ; /* must keep super locked during these ops */
 
 	/* correct last bitmap blocks in old and new disk layout */
 	reiserfs_prepare_for_journal(s, SB_AP_BITMAP(s)[bmap_nr - 1], 1);
 	for (i = block_r; i < s->s_blocksize * 8; i++)
-	    reiserfs_test_and_clear_le_bit(i, 
-					   SB_AP_BITMAP(s)[bmap_nr - 1]->b_data);
+		reiserfs_test_and_clear_le_bit(i, 
+		                         SB_AP_BITMAP(s)[bmap_nr - 1]->b_data);
 	journal_mark_dirty(&th, s, SB_AP_BITMAP(s)[bmap_nr - 1]);
 
 	reiserfs_prepare_for_journal(s, SB_AP_BITMAP(s)[bmap_nr_new - 1], 1);
 	for (i = block_r_new; i < s->s_blocksize * 8; i++)
-	    reiserfs_test_and_set_le_bit(i,
-					 SB_AP_BITMAP(s)[bmap_nr_new - 1]->b_data);
+		reiserfs_test_and_set_le_bit(i,
+		                      SB_AP_BITMAP(s)[bmap_nr_new - 1]->b_data);
 	journal_mark_dirty(&th, s, SB_AP_BITMAP(s)[bmap_nr_new - 1]);
  
  	/* update super */
-	reiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1) ;
 	free_blocks = SB_FREE_BLOCKS(s);
-	PUT_SB_FREE_BLOCKS(s, free_blocks + (block_count_new - block_count - (bmap_nr_new - bmap_nr)));
-	PUT_SB_BLOCK_COUNT(s, block_count_new);
-	PUT_SB_BMAP_NR(s, bmap_nr_new);
+	reiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1) ;
+	sb->s_free_blocks = cpu_to_le32(free_blocks + (block_count_new 
+		- block_count - (bmap_nr_new - bmap_nr)));
+	sb->s_block_count = cpu_to_le32(block_count_new);
+	sb->s_bmap_nr = cpu_to_le16(bmap_nr_new);
 	s->s_dirt = 1;
 
 	journal_mark_dirty(&th, s, SB_BUFFER_WITH_SB(s));
 	
 	SB_JOURNAL(s)->j_must_wait = 1;
+	unlock_super(s) ; /* see comments in reiserfs_put_super() */
 	journal_end(&th, s, 10);
+	lock_super(s);
 
 	return 0;
 }
diff -urp linux/fs/reiserfs/stree.c new_kernel_src/fs/reiserfs/stree.c
--- linux/fs/reiserfs/stree.c	2009-06-10 21:00:37.000000000 +0100
+++ new_kernel_src/fs/reiserfs/stree.c	2002-03-25 03:10:33.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README
+ *  Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
  */
 
 /*
@@ -53,7 +53,6 @@
  * reiserfs_insert_item
  */
 
-#include <linux/config.h>
 #include <linux/sched.h>
 #include <linux/string.h>
 #include <linux/locks.h>
@@ -480,7 +479,7 @@ void  pathrelse (
   RFALSE( n_path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,
 	  "PAP-5090: illegal path offset");
   
-  while ( n_path_offset > ILLEGAL_PATH_ELEMENT_OFFSET )  
+  while ( n_path_offset > ILLEGAL_PATH_ELEMENT_OFFSET ) 
     brelse(PATH_OFFSET_PBUFFER(p_s_search_path, n_path_offset--));
 
   p_s_search_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;
@@ -488,7 +487,7 @@ void  pathrelse (
 
 
 
-static int is_leaf (char * buf, int blocksize, struct buffer_head * bh)
+static int is_leaf (char * buf, int blocksize)
 {
     struct block_head * blkh;
     struct item_head * ih;
@@ -498,24 +497,19 @@ static int is_leaf (char * buf, int bloc
     int nr;
 
     blkh = (struct block_head *)buf;
-    if ( blkh_level(blkh) != DISK_LEAF_NODE_LEVEL) {
-	printk ("is_leaf: this should be caught earlier\n");
+    if (le16_to_cpu (blkh->blk_level) != DISK_LEAF_NODE_LEVEL)
 	return 0;
-    }
 
-    nr = blkh_nr_item(blkh);
-    if (nr < 1 || nr > ((blocksize - BLKH_SIZE) / (IH_SIZE + MIN_ITEM_LEN))) {
+    nr = le16_to_cpu (blkh->blk_nr_item);
+    if (nr < 1 || nr > ((blocksize - BLKH_SIZE) / (IH_SIZE + MIN_ITEM_LEN)))
 	/* item number is too big or too small */
-	reiserfs_warning ("is_leaf: nr_item seems wrong: %z\n", bh);
 	return 0;
-    }
+
     ih = (struct item_head *)(buf + BLKH_SIZE) + nr - 1;
     used_space = BLKH_SIZE + IH_SIZE * nr + (blocksize - ih_location (ih));
-    if (used_space != blocksize - blkh_free_space(blkh)) {
+    if (used_space != blocksize - le16_to_cpu (blkh->blk_free_space))
 	/* free space does not match to calculated amount of use space */
-	reiserfs_warning ("is_leaf: free space seems wrong: %z\n", bh);
 	return 0;
-    }
 
     // FIXME: it is_leaf will hit performance too much - we may have
     // return 1 here
@@ -524,22 +518,12 @@ static int is_leaf (char * buf, int bloc
     ih = (struct item_head *)(buf + BLKH_SIZE);
     prev_location = blocksize;
     for (i = 0; i < nr; i ++, ih ++) {
-	if ( le_ih_k_type(ih) == TYPE_ANY) {
-	    reiserfs_warning ("is_leaf: wrong item type for item %h\n",ih);
+	if (ih_location (ih) >= blocksize || ih_location (ih) < IH_SIZE * nr)
 	    return 0;
-	}
-	if (ih_location (ih) >= blocksize || ih_location (ih) < IH_SIZE * nr) {
-	    reiserfs_warning ("is_leaf: item location seems wrong: %h\n", ih);
+	if (ih_item_len (ih) < 1 || ih_item_len (ih) > MAX_ITEM_LEN (blocksize))
 	    return 0;
-	}
-	if (ih_item_len (ih) < 1 || ih_item_len (ih) > MAX_ITEM_LEN (blocksize)) {
-	    reiserfs_warning ("is_leaf: item length seems wrong: %h\n", ih);
+	if (prev_location - ih_location (ih) != ih_item_len (ih))
 	    return 0;
-	}
-	if (prev_location - ih_location (ih) != ih_item_len (ih)) {
-	    reiserfs_warning ("is_leaf: item location seems wrong (second one): %h\n", ih);
-	    return 0;
-	}
 	prev_location = ih_location (ih);
     }
 
@@ -549,32 +533,26 @@ static int is_leaf (char * buf, int bloc
 
 
 /* returns 1 if buf looks like an internal node, 0 otherwise */
-static int is_internal (char * buf, int blocksize, struct buffer_head * bh)
+static int is_internal (char * buf, int blocksize)
 {
     struct block_head * blkh;
     int nr;
     int used_space;
 
     blkh = (struct block_head *)buf;
-    nr = blkh_level(blkh);
-    if (nr <= DISK_LEAF_NODE_LEVEL || nr > MAX_HEIGHT) {
+    if (le16_to_cpu (blkh->blk_level) <= DISK_LEAF_NODE_LEVEL ||
+	le16_to_cpu (blkh->blk_level) > MAX_HEIGHT)
 	/* this level is not possible for internal nodes */
-	printk ("is_internal: this should be caught earlier\n");
 	return 0;
-    }
     
-    nr = blkh_nr_item(blkh);
-    if (nr > (blocksize - BLKH_SIZE - DC_SIZE) / (KEY_SIZE + DC_SIZE)) {
+    nr = le16_to_cpu (blkh->blk_nr_item);
+   if (nr > (blocksize - BLKH_SIZE - DC_SIZE) / (KEY_SIZE + DC_SIZE))
 	/* for internal which is not root we might check min number of keys */
-	reiserfs_warning ("is_internal: number of key seems wrong: %z\n", bh);
 	return 0;
-    }
 
     used_space = BLKH_SIZE + KEY_SIZE * nr + DC_SIZE * (nr + 1);
-    if (used_space != blocksize - blkh_free_space(blkh)) {
-	reiserfs_warning ("is_internal: free space seems wrong: %z\n", bh);
+    if (used_space != blocksize - le16_to_cpu (blkh->blk_free_space))
 	return 0;
-    }
 
     // one may imagine much more checks
     return 1;
@@ -583,17 +561,14 @@ static int is_internal (char * buf, int 
 
 // make sure that bh contains formatted node of reiserfs tree of
 // 'level'-th level
-static int is_tree_node (struct buffer_head * bh, int level)
+int is_tree_node (struct buffer_head * bh, int level)
 {
-    if (B_LEVEL (bh) != level) {
-	printk ("is_tree_node: node level %d does not match to the expected one %d\n",
-		B_LEVEL (bh), level);
+    if (B_LEVEL (bh) != level)
 	return 0;
-    }
     if (level == DISK_LEAF_NODE_LEVEL)
-	return is_leaf (bh->b_data, bh->b_size, bh);
+	return is_leaf (bh->b_data, bh->b_size);
 
-    return is_internal (bh->b_data, bh->b_size, bh);
+    return is_internal (bh->b_data, bh->b_size);
 }
 
 
@@ -1269,7 +1244,6 @@ int reiserfs_delete_item (struct reiserf
 
     if ( p_s_un_bh )  {
 	int off;
-        char *data ;
 
 	/* We are in direct2indirect conversion, so move tail contents
            to the unformatted node */
@@ -1282,25 +1256,36 @@ int reiserfs_delete_item (struct reiserf
 	** the unformatted node, which might schedule, meaning we'd have to
 	** loop all the way back up to the start of the while loop.
 	**
-	** The unformatted node must be dirtied later on.  We can't be
-	** sure here if the entire tail has been deleted yet.
-        **
-        ** p_s_un_bh is from the page cache (all unformatted nodes are
-        ** from the page cache) and might be a highmem page.  So, we
-        ** can't use p_s_un_bh->b_data.  But, the page has already been
-        ** kmapped, so we can use page_address()
+	** The unformatted node is prepared and logged after the do_balance.
 	** -clm
 	*/
 
-        data = page_address(p_s_un_bh->b_page) ;
-	off = ((le_ih_k_offset (&s_ih) - 1) & (PAGE_CACHE_SIZE - 1));
-	memcpy(data + off,
+	off = ((le_ih_k_offset (&s_ih) - 1) & (p_s_sb->s_blocksize - 1));
+	memcpy(p_s_un_bh->b_data + off,
 	       B_I_PITEM(PATH_PLAST_BUFFER(p_s_path), &s_ih), n_ret_value);
+
     }
 
     /* Perform balancing after all resources have been collected at once. */ 
     do_balance(&s_del_balance, NULL, NULL, M_DELETE);
 
+    /* see comment above for why this is after the do_balance */
+    if (p_s_un_bh) {
+        mark_buffer_dirty(p_s_un_bh, 0) ;
+#if 0
+	if (reiserfs_dont_log(p_s_sb)) {
+	    mark_buffer_dirty(p_s_un_bh, 0) ;
+	} else {
+	    if (p_s_un_bh->b_end_io == reiserfs_end_buffer_io_sync) {
+		reiserfs_prepare_for_journal(p_s_sb, p_s_un_bh, 1) ;
+		journal_mark_dirty(th, p_s_sb, p_s_un_bh) ;
+	    } else {
+		mark_buffer_dirty(p_s_un_bh, 0) ;
+	    }
+	}
+#endif
+    }
+
     /* Return deleted body length */
     return n_ret_value;
 }
@@ -1384,7 +1369,7 @@ void reiserfs_delete_object (struct reis
     inode->i_size = 0;
 
     /* for directory this deletes item containing "." and ".." */
-    reiserfs_do_truncate (th, inode, NULL, 0/*no timestamp updates*/);
+    reiserfs_do_truncate (th, inode, 0/*no timestamp updates*/);
     
 #if defined( USE_INODE_GENERATION_COUNTER )
     if( !old_format_only ( th -> t_super ) )
@@ -1401,9 +1386,8 @@ void reiserfs_delete_object (struct reis
 }
 
 
-static int maybe_indirect_to_direct (struct reiserfs_transaction_handle *th, 
+int maybe_indirect_to_direct (struct reiserfs_transaction_handle *th, 
 			      struct inode * p_s_inode,
-			      struct page *page, 
 			      struct path         * p_s_path,
 			      const struct cpu_key      * p_s_item_key,
 			      loff_t         n_new_file_size,
@@ -1415,14 +1399,7 @@ static int maybe_indirect_to_direct (str
 
     if (n_new_file_size != p_s_inode->i_size)
 	BUG ();
-
-    /* the page being sent in could be NULL if there was an i/o error
-    ** reading in the last block.  The user will hit problems trying to
-    ** read the file, but for now we just skip the indirect2direct
-    */
-    if (atomic_read(&p_s_inode->i_count) > 1 || 
-        !tail_has_to_be_packed (p_s_inode) || 
-        !page || (p_s_inode->u.reiserfs_i.i_flags & i_nopack_mask)) {
+    if (atomic_read(&p_s_inode->i_count) > 1 || !tail_has_to_be_packed (p_s_inode)) {
 	// leave tail in an unformatted node	
 	*p_c_mode = M_SKIP_BALANCING;
 	cut_bytes = n_block_size - (n_new_file_size & (n_block_size - 1));
@@ -1431,7 +1408,7 @@ static int maybe_indirect_to_direct (str
     }
     /* Permorm the conversion to a direct_item. */
     /*return indirect_to_direct (p_s_inode, p_s_path, p_s_item_key, n_new_file_size, p_c_mode);*/
-    return indirect2direct (th, p_s_inode, page, p_s_path, p_s_item_key, n_new_file_size, p_c_mode);
+    return indirect2direct (th, p_s_inode, p_s_path, p_s_item_key, n_new_file_size, p_c_mode);
 }
 
 
@@ -1445,6 +1422,9 @@ static void indirect_to_direct_roll_back
     int tail_len;
     int removed;
 
+    if (!is_tail_convert_locked (inode))
+	BUG ();
+
     make_cpu_key (&tail_key, inode, inode->i_size + 1, TYPE_DIRECT, 4);// !!!!
     tail_key.key_length = 4;
 
@@ -1475,7 +1455,6 @@ int reiserfs_cut_from_item (struct reise
 			    struct path * p_s_path,
 			    struct cpu_key * p_s_item_key,
 			    struct inode * p_s_inode,
-			    struct page *page, 
 			    loff_t n_new_file_size)
 {
     struct super_block * p_s_sb = p_s_inode->i_sb;
@@ -1510,7 +1489,7 @@ int reiserfs_cut_from_item (struct reise
                tail in the unformatted node */
 	    RFALSE( n_ret_value != CARRY_ON, "PAP-5570: can not convert twice");
 
-	    n_ret_value = maybe_indirect_to_direct (th, p_s_inode, page, p_s_path, p_s_item_key,
+	    n_ret_value = maybe_indirect_to_direct (th, p_s_inode, p_s_path, p_s_item_key,
 						    n_new_file_size, &c_mode);
 	    if ( c_mode == M_SKIP_BALANCING )
 		/* tail has been left in the unformatted node */
@@ -1565,6 +1544,7 @@ int reiserfs_cut_from_item (struct reise
 	    // FIXME: this seems to be not needed: we are always able
 	    // to cut item
 	    indirect_to_direct_roll_back (th, p_s_inode, p_s_path);
+	    unlock_tail (p_s_inode);
 	}
 	if (n_ret_value == NO_DISK_SPACE)
 	    reiserfs_warning ("NO_DISK_SPACE");
@@ -1626,7 +1606,8 @@ int reiserfs_cut_from_item (struct reise
 	** be flushed before the transaction commits, so we don't need to 
 	** deal with it here.
 	*/
-	p_s_inode->u.reiserfs_i.i_flags &= ~i_pack_on_close_mask;
+	p_s_inode->u.reiserfs_i.i_pack_on_close = 0 ;
+	unlock_tail (p_s_inode);
     }
     return n_ret_value;
 }
@@ -1653,7 +1634,6 @@ static void truncate_directory (struct r
 void reiserfs_do_truncate (struct reiserfs_transaction_handle *th, 
 			   struct  inode * p_s_inode, /* ->i_size contains new
                                                          size */
-			   struct page *page, /* up to date for last block */
 			   int update_timestamps  /* when it is called by
 						     file_release to convert
 						     the tail - no timestamps
@@ -1682,6 +1662,9 @@ void reiserfs_do_truncate (struct reiser
     // FIXME: note, that key type is unimportant here
     make_cpu_key (&s_item_key, p_s_inode, max_reiserfs_offset (p_s_inode), TYPE_DIRECT, 3);
 
+    if (is_tail_convert_locked (p_s_inode))
+	BUG ();
+
     retval = search_for_position_by_key(p_s_inode->i_sb, &s_item_key, &s_search_path);
     if (retval == IO_ERROR) {
 	reiserfs_warning ("vs-5657: reiserfs_do_truncate: "
@@ -1691,7 +1674,7 @@ void reiserfs_do_truncate (struct reiser
     if (retval == POSITION_FOUND || retval == FILE_NOT_FOUND) {
 	pathrelse (&s_search_path);
 	reiserfs_warning ("PAP-5660: reiserfs_do_truncate: "
-			  "wrong result %d of search for %K\n", retval, &s_item_key);
+			  "wrong result %d of search for %K\n", &s_item_key);
 	return;
     }
 
@@ -1720,7 +1703,7 @@ void reiserfs_do_truncate (struct reiser
 
     do  {
 	/* Cut or delete file item. */
-	n_deleted = reiserfs_cut_from_item(th, &s_search_path, &s_item_key, p_s_inode,  page, n_new_file_size);
+	n_deleted = reiserfs_cut_from_item(th, &s_search_path, &s_item_key, p_s_inode,  n_new_file_size);
 	if (n_deleted < 0) {
 	    reiserfs_warning ("vs-5665: reiserfs_truncate_file: cut_from_item failed");
 	    reiserfs_check_path(&s_search_path) ;
@@ -1735,6 +1718,8 @@ void reiserfs_do_truncate (struct reiser
 	n_file_size -= n_deleted;
 
 	set_cpu_key_k_offset (&s_item_key, n_file_size);
+	if (is_tail_convert_locked (p_s_inode))
+	    BUG ();
 
 	/* While there are bytes to truncate and previous file item is presented in the tree. */
 
@@ -1772,11 +1757,10 @@ update_and_out:
     }
     reiserfs_update_sd (th, p_s_inode);
 
-    pathrelse(&s_search_path) ;
+    reiserfs_check_path(&s_search_path) ;
 }
 
 
-#ifdef CONFIG_REISERFS_CHECK
 // this makes sure, that we __append__, not overwrite or add holes
 static void check_research_for_paste (struct path * path, 
 				      const struct cpu_key * p_s_key)
@@ -1800,7 +1784,6 @@ static void check_research_for_paste (st
 			    found_ih, pos_in_item (path), p_s_key);
     }
 }
-#endif /* config reiserfs check */
 
 
 /* Paste bytes to the existing item. Returns bytes number pasted into the item. */
diff -urp linux/fs/reiserfs/super.c new_kernel_src/fs/reiserfs/super.c
--- linux/fs/reiserfs/super.c	2009-06-10 21:00:37.000000000 +0100
+++ new_kernel_src/fs/reiserfs/super.c	2002-03-25 03:10:33.000000000 +0000
@@ -1,17 +1,9 @@
 /*
- * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README
- *
- * Trivial changes by Alan Cox to add the LFS fixes
- *
- * Trivial Changes:
- * Rights granted to Hans Reiser to redistribute under other terms providing
- * he accepts all liability including but not limited to patent, fitness
- * for purpose, and direct or indirect claims arising from failure to perform.
- *
- * NO WARRANTY
+ * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
  */
 
-#include <linux/config.h>
+#ifdef __KERNEL__
+
 #include <linux/module.h>
 #include <linux/sched.h>
 #include <asm/uaccess.h>
@@ -23,6 +15,7 @@
 #define REISERFS_OLD_BLOCKSIZE 4096
 #define REISERFS_SUPER_MAGIC_STRING_OFFSET_NJ 20
 
+
 char reiserfs_super_magic_string[] = REISERFS_SUPER_MAGIC_STRING;
 char reiser2fs_super_magic_string[] = REISER2FS_SUPER_MAGIC_STRING;
 
@@ -42,12 +35,16 @@ static void reiserfs_write_super (struct
   int dirty = 0 ;
   lock_kernel() ;
   if (!(s->s_flags & MS_RDONLY)) {
+    unlock_super(s) ;
     dirty = flush_old_commits(s, 1) ;
+    lock_super(s) ;
   }
   s->s_dirt = dirty;
   unlock_kernel() ;
 }
 
+
+
 //
 // a portion of this function, particularly the VFS interface portion,
 // was derived from minix or ext2's analog and evolved as the
@@ -55,449 +52,126 @@ static void reiserfs_write_super (struct
 // at the ext2 code and comparing. It's subfunctions contain no code
 // used as a template unless they are so labeled.
 //
-static void reiserfs_write_super_lockfs (struct super_block * s)
+void reiserfs_put_super (struct super_block * s)
 {
-
-  int dirty = 0 ;
+  int i;
   struct reiserfs_transaction_handle th ;
-  lock_kernel() ;
+  
+  /* the end_io task has to call get_super, which locks the super, which
+  ** will deadlock with the journal.  So, we unlock, and then relock
+  ** when the journal is done.
+  ** 
+  ** this sucks.
+  */
+  unlock_super(s) ;
+  journal_begin(&th, s, 10) ;
+
+  /* change file system state to current state if it was mounted with read-write permissions */
   if (!(s->s_flags & MS_RDONLY)) {
-    journal_begin(&th, s, 1) ;
-    reiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1);
+    reiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1) ;
+    set_sb_state( SB_DISK_SUPER_BLOCK(s), s->u.reiserfs_sb.s_mount_state );
     journal_mark_dirty(&th, s, SB_BUFFER_WITH_SB (s));
-    reiserfs_block_writes(&th) ;
-    journal_end(&th, s, 1) ;
   }
-  s->s_dirt = dirty;
-  unlock_kernel() ;
-}
 
-void reiserfs_unlockfs(struct super_block *s) {
-  reiserfs_allow_writes(s) ;
-}
+  journal_release(&th, s) ;
+  lock_super(s) ;
 
-extern const struct key  MAX_KEY;
+  for (i = 0; i < SB_BMAP_NR (s); i ++)
+    brelse (SB_AP_BITMAP (s)[i]);
 
+  reiserfs_kfree (SB_AP_BITMAP (s), sizeof (struct buffer_head *) * SB_BMAP_NR (s), s);
 
-/* this is used to delete "save link" when there are no items of a
-   file it points to. It can either happen if unlink is completed but
-   "save unlink" removal, or if file has both unlink and truncate
-   pending and as unlink completes first (because key of "save link"
-   protecting unlink is bigger that a key lf "save link" which
-   protects truncate), so there left no items to make truncate
-   completion on */
-static void remove_save_link_only (struct super_block * s, struct key * key, int oid_free)
-{
-    struct reiserfs_transaction_handle th;
+  brelse (SB_BUFFER_WITH_SB (s));
 
-     /* we are going to do one balancing */
-     journal_begin (&th, s, JOURNAL_PER_BALANCE_CNT);
- 
-     reiserfs_delete_solid_item (&th, key);
-     if (oid_free)
-        /* removals are protected by direct items */
-        reiserfs_release_objectid (&th, le32_to_cpu (key->k_objectid));
+  print_statistics (s);
 
-     journal_end (&th, s, JOURNAL_PER_BALANCE_CNT);
+  if (s->u.reiserfs_sb.s_kmallocs != 0) {
+    reiserfs_warning ("vs-2004: reiserfs_put_super: allocated memory left %d\n",
+		      s->u.reiserfs_sb.s_kmallocs);
+  }
+
+  reiserfs_proc_unregister( s, "journal" );
+  reiserfs_proc_unregister( s, "oidmap" );
+  reiserfs_proc_unregister( s, "on-disk-super" );
+  reiserfs_proc_unregister( s, "bitmap" );
+  reiserfs_proc_unregister( s, "per-level" );
+  reiserfs_proc_unregister( s, "super" );
+  reiserfs_proc_unregister( s, "version" );
+  reiserfs_proc_info_done( s );
+  return;
 }
- 
- 
-/* look for uncompleted unlinks and truncates and complete them */
-static void finish_unfinished (struct super_block * s)
-{
-    INITIALIZE_PATH (path);
-    struct cpu_key max_cpu_key, obj_key;
-    struct key save_link_key;
-    int retval;
-    struct item_head * ih;
-    struct buffer_head * bh;
-    int item_pos;
-    char * item;
-    int done;
-    struct inode * inode;
-    int truncate;
- 
- 
-    /* compose key to look for "save" links */
-    max_cpu_key.version = KEY_FORMAT_3_5;
-    max_cpu_key.on_disk_key = MAX_KEY;
-    max_cpu_key.key_length = 3;
- 
-    done = 0;
-    s -> u.reiserfs_sb.s_is_unlinked_ok = 1;
-    while (1) {
-        retval = search_item (s, &max_cpu_key, &path);
-        if (retval != ITEM_NOT_FOUND) {
-            reiserfs_warning ("vs-2140: finish_unfinished: search_by_key returned %d\n",
-                              retval);
-            break;
-        }
-        
-        bh = get_last_bh (&path);
-        item_pos = get_item_pos (&path);
-        if (item_pos != B_NR_ITEMS (bh)) {
-            reiserfs_warning ("vs-2060: finish_unfinished: wrong position found\n");
-            break;
-        }
-        item_pos --;
-        ih = B_N_PITEM_HEAD (bh, item_pos);
- 
-        if (le32_to_cpu (ih->ih_key.k_dir_id) != MAX_KEY_OBJECTID)
-            /* there are no "save" links anymore */
-            break;
- 
-        save_link_key = ih->ih_key;
-        if (is_indirect_le_ih (ih))
-            truncate = 1;
-        else
-            truncate = 0;
- 
-        /* reiserfs_iget needs k_dirid and k_objectid only */
-        item = B_I_PITEM (bh, ih);
-        obj_key.on_disk_key.k_dir_id = le32_to_cpu (*(__u32 *)item);
-        obj_key.on_disk_key.k_objectid = le32_to_cpu (ih->ih_key.k_objectid);
-	obj_key.on_disk_key.u.k_offset_v1.k_offset = 0;
-	obj_key.on_disk_key.u.k_offset_v1.k_uniqueness = 0;
-	
-        pathrelse (&path);
- 
-        inode = reiserfs_iget (s, &obj_key);
-        if (!inode) {
-            /* the unlink almost completed, it just did not manage to remove
-	       "save" link and release objectid */
-            reiserfs_warning ("vs-2180: finish_unfinished: iget failed for %K\n",
-                              &obj_key);
-            remove_save_link_only (s, &save_link_key, 1);
-            continue;
-        }
 
-	if (!truncate && inode->i_nlink) {
-	    /* file is not unlinked */
-            reiserfs_warning ("vs-2185: finish_unfinished: file %K is not unlinked\n",
-                              &obj_key);
-            remove_save_link_only (s, &save_link_key, 0);
-            continue;
-	}
+struct super_operations reiserfs_sops = 
+{
+  read_inode: reiserfs_read_inode,
+  read_inode2: reiserfs_read_inode2,
+  write_inode: reiserfs_write_inode,
+  dirty_inode: reiserfs_dirty_inode,
+  delete_inode: reiserfs_delete_inode,
+  put_super: reiserfs_put_super,
+  write_super: reiserfs_write_super,
+  statfs: reiserfs_statfs,
+  remount_fs: reiserfs_remount,
+};
 
-	if (truncate && S_ISDIR (inode->i_mode) ) {
-	    /* We got a truncate request for a dir which is impossible.
-	       The only imaginable way is to execute unfinished truncate request
-	       then boot into old kernel, remove the file and create dir with
-	       the same key. */
-	    reiserfs_warning("green-2101: impossible truncate on a directory %k. Please report\n", INODE_PKEY (inode));
-	    remove_save_link_only (s, &save_link_key, 0);
-	    truncate = 0;
-	    iput (inode); 
-	    continue;
+/* this was (ext2)parse_options */
+static int parse_options (char * options, unsigned long * mount_options, unsigned long * blocks)
+{
+    char * this_char;
+    char * value;
+  
+    *blocks = 0;
+    if (!options)
+	/* use default configuration: complex read, create tails, preserve on */
+	return 1;
+    for (this_char = strtok (options, ","); this_char != NULL; this_char = strtok (NULL, ",")) {
+	if ((value = strchr (this_char, '=')) != NULL)
+	    *value++ = 0;
+	if (!strcmp (this_char, "notail")) {
+	    set_bit (NOTAIL, mount_options);
+	} else if (!strcmp (this_char, "conv")) {
+	    // if this is set, we update super block such that
+	    // the partition will not be mounable by 3.5.x anymore
+	    set_bit (REISERFS_CONVERT, mount_options);
+	} else if (!strcmp (this_char, "nolog")) {
+	    reiserfs_warning("reiserfs: nolog mount option not supported yet\n");
+	} else if (!strcmp (this_char, "replayonly")) {
+	    set_bit (REPLAYONLY, mount_options);
+	} else if (!strcmp (this_char, "resize")) {
+	    if (!value || !*value){
+	  	printk("reiserfs: resize option requires a value\n");
+	    }
+	    *blocks = simple_strtoul (value, &value, 0);
+	} else if (!strcmp (this_char, "hash")) {
+	    if (value && *value) {
+		/* if they specify any hash option, we force detection
+		** to make sure they aren't using the wrong hash
+		*/
+	        if (!strcmp(value, "rupasov")) {
+		    set_bit (FORCE_RUPASOV_HASH, mount_options);
+		    set_bit (FORCE_HASH_DETECT, mount_options);
+		} else if (!strcmp(value, "tea")) {
+		    set_bit (FORCE_TEA_HASH, mount_options);
+		    set_bit (FORCE_HASH_DETECT, mount_options);
+		} else if (!strcmp(value, "r5")) {
+		    set_bit (FORCE_R5_HASH, mount_options);
+		    set_bit (FORCE_HASH_DETECT, mount_options);
+		} else if (!strcmp(value, "detect")) {
+		    set_bit (FORCE_HASH_DETECT, mount_options);
+		} else {
+		    printk("reiserfs: invalid hash function specified\n") ;
+		    return 0 ;
+		}
+	    } else {
+	  	printk("reiserfs: hash option requires a value\n");
+		return 0 ;
+	    }
+	} else {
+	    printk ("reiserfs: Unrecognized mount option %s\n", this_char);
+	    return 0;
 	}
- 
-        if (truncate) {
-            inode -> u.reiserfs_i.i_flags |= i_link_saved_truncate_mask;
-            /* not completed truncate found. New size was committed together
-	       with "save" link */
-            reiserfs_warning ("Truncating %k to %Ld ..",
-                              INODE_PKEY (inode), inode->i_size);
-            reiserfs_truncate_file (inode, 0/*don't update modification time*/);
-            remove_save_link (inode, truncate);
-        } else {
-            inode -> u.reiserfs_i.i_flags |= i_link_saved_unlink_mask;
-            /* not completed unlink (rmdir) found */
-            reiserfs_warning ("Removing %k..", INODE_PKEY (inode));
-            /* removal gets completed in iput */
-        }
- 
-        iput (inode);
-        printk ("done\n");
-        done ++;
     }
-    s -> u.reiserfs_sb.s_is_unlinked_ok = 0;
-     
-    pathrelse (&path);
-    if (done)
-        reiserfs_warning ("There were %d uncompleted unlinks/truncates. "
-                          "Completed\n", done);
-}
- 
-/* to protect file being unlinked from getting lost we "safe" link files
-   being unlinked. This link will be deleted in the same transaction with last
-   item of file. mounting the filesytem we scan all these links and remove
-   files which almost got lost */
-void add_save_link (struct reiserfs_transaction_handle * th,
-		    struct inode * inode, int truncate)
-{
-    INITIALIZE_PATH (path);
-    int retval;
-    struct cpu_key key;
-    struct item_head ih;
-    __u32 link;
-
-    /* file can only get one "save link" of each kind */
-    RFALSE( truncate && 
-	    ( inode -> u.reiserfs_i.i_flags & i_link_saved_truncate_mask ),
-	    "saved link already exists for truncated inode %lx",
-	    ( long ) inode -> i_ino );
-    RFALSE( !truncate && 
-	    ( inode -> u.reiserfs_i.i_flags & i_link_saved_unlink_mask ),
-	    "saved link already exists for unlinked inode %lx",
-	    ( long ) inode -> i_ino );
-
-    /* setup key of "save" link */
-    key.version = KEY_FORMAT_3_5;
-    key.on_disk_key.k_dir_id = MAX_KEY_OBJECTID;
-    key.on_disk_key.k_objectid = inode->i_ino;
-    if (!truncate) {
-	/* unlink, rmdir, rename */
-	set_cpu_key_k_offset (&key, 1 + inode->i_sb->s_blocksize);
-	set_cpu_key_k_type (&key, TYPE_DIRECT);
-
-	/* item head of "safe" link */
-	make_le_item_head (&ih, &key, key.version, 1 + inode->i_sb->s_blocksize, TYPE_DIRECT,
-			   4/*length*/, 0xffff/*free space*/);
-    } else {
-	/* truncate */
-	if (S_ISDIR (inode->i_mode))
-	    reiserfs_warning("green-2102: Adding a truncate savelink for a directory %k! Please report\n", INODE_PKEY(inode));
-	set_cpu_key_k_offset (&key, 1);
-	set_cpu_key_k_type (&key, TYPE_INDIRECT);
-
-	/* item head of "safe" link */
-	make_le_item_head (&ih, &key, key.version, 1, TYPE_INDIRECT,
-			   4/*length*/, 0/*free space*/);
-    }
-    key.key_length = 3;
-
-    /* look for its place in the tree */
-    retval = search_item (inode->i_sb, &key, &path);
-    if (retval != ITEM_NOT_FOUND) {
-	if ( retval != -ENOSPC )
-	    reiserfs_warning ("vs-2100: add_save_link:"
-			  "search_by_key (%K) returned %d\n", &key, retval);
-	pathrelse (&path);
-	return;
-    }
-
-    /* body of "save" link */
-    link = cpu_to_le32 (INODE_PKEY (inode)->k_dir_id);
-
-    /* put "save" link inot tree */
-    retval = reiserfs_insert_item (th, &path, &key, &ih, (char *)&link);
-    if (retval) {
-	if (retval != -ENOSPC)
-	    reiserfs_warning ("vs-2120: add_save_link: insert_item returned %d\n",
-			  retval);
-    } else {
-	if( truncate )
-	    inode -> u.reiserfs_i.i_flags |= i_link_saved_truncate_mask;
-	else
-	    inode -> u.reiserfs_i.i_flags |= i_link_saved_unlink_mask;
-    }
-}
-
-
-/* this opens transaction unlike add_save_link */
-void remove_save_link (struct inode * inode, int truncate)
-{
-    struct reiserfs_transaction_handle th;
-    struct key key;
- 
- 
-    /* we are going to do one balancing only */
-    journal_begin (&th, inode->i_sb, JOURNAL_PER_BALANCE_CNT);
- 
-    /* setup key of "save" link */
-    key.k_dir_id = cpu_to_le32 (MAX_KEY_OBJECTID);
-    key.k_objectid = INODE_PKEY (inode)->k_objectid;
-    if (!truncate) {
-        /* unlink, rmdir, rename */
-        set_le_key_k_offset (KEY_FORMAT_3_5, &key,
-			     1 + inode->i_sb->s_blocksize);
-        set_le_key_k_type (KEY_FORMAT_3_5, &key, TYPE_DIRECT);
-    } else {
-        /* truncate */
-        set_le_key_k_offset (KEY_FORMAT_3_5, &key, 1);
-        set_le_key_k_type (KEY_FORMAT_3_5, &key, TYPE_INDIRECT);
-    }
- 
-    if( ( truncate && 
-          ( inode -> u.reiserfs_i.i_flags & i_link_saved_truncate_mask ) ) ||
-        ( !truncate && 
-          ( inode -> u.reiserfs_i.i_flags & i_link_saved_unlink_mask ) ) )
-	reiserfs_delete_solid_item (&th, &key);
-    if (!truncate) {
-	reiserfs_release_objectid (&th, inode->i_ino);
-	inode -> u.reiserfs_i.i_flags &= ~i_link_saved_unlink_mask;
-    } else
-	inode -> u.reiserfs_i.i_flags &= ~i_link_saved_truncate_mask;
- 
-    journal_end (&th, inode->i_sb, JOURNAL_PER_BALANCE_CNT);
-}
-
-
-//
-// a portion of this function, particularly the VFS interface portion,
-// was derived from minix or ext2's analog and evolved as the
-// prototype did. You should be able to tell which portion by looking
-// at the ext2 code and comparing. It's subfunctions contain no code
-// used as a template unless they are so labeled.
-//
-static void reiserfs_put_super (struct super_block * s)
-{
-  int i;
-  struct reiserfs_transaction_handle th ;
-  
-  /* change file system state to current state if it was mounted with read-write permissions */
-  if (!(s->s_flags & MS_RDONLY)) {
-    journal_begin(&th, s, 10) ;
-    reiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1) ;
-    set_sb_state( SB_DISK_SUPER_BLOCK(s), s->u.reiserfs_sb.s_mount_state );
-    journal_mark_dirty(&th, s, SB_BUFFER_WITH_SB (s));
-  }
-
-  /* note, journal_release checks for readonly mount, and can decide not
-  ** to do a journal_end
-  */
-  journal_release(&th, s) ;
-
-  for (i = 0; i < SB_BMAP_NR (s); i ++)
-    brelse (SB_AP_BITMAP (s)[i]);
-
-  reiserfs_kfree (SB_AP_BITMAP (s), sizeof (struct buffer_head *) * SB_BMAP_NR (s), s);
-
-  brelse (SB_BUFFER_WITH_SB (s));
-
-  print_statistics (s);
-
-  if (s->u.reiserfs_sb.s_kmallocs != 0) {
-    reiserfs_warning ("vs-2004: reiserfs_put_super: allocated memory left %d\n",
-		      s->u.reiserfs_sb.s_kmallocs);
-  }
-
-  reiserfs_proc_unregister( s, "journal" );
-  reiserfs_proc_unregister( s, "oidmap" );
-  reiserfs_proc_unregister( s, "on-disk-super" );
-  reiserfs_proc_unregister( s, "bitmap" );
-  reiserfs_proc_unregister( s, "per-level" );
-  reiserfs_proc_unregister( s, "super" );
-  reiserfs_proc_unregister( s, "version" );
-  reiserfs_proc_info_done( s );
-  return;
-}
-
-/* we don't mark inodes dirty, we just log them */
-static void reiserfs_dirty_inode (struct inode * inode) {
-    struct reiserfs_transaction_handle th ;
-
-    if (inode->i_sb->s_flags & MS_RDONLY) {
-        reiserfs_warning("clm-6006: writing inode %lu on readonly FS\n", 
-	                  inode->i_ino) ;
-        return ;
-    }
-    lock_kernel() ;
-
-    /* this is really only used for atime updates, so they don't have
-    ** to be included in O_SYNC or fsync
-    */
-    journal_begin(&th, inode->i_sb, 1) ;
-    reiserfs_update_sd (&th, inode);
-    journal_end(&th, inode->i_sb, 1) ;
-    unlock_kernel() ;
-}
-
-struct super_operations reiserfs_sops = 
-{
-  read_inode: reiserfs_read_inode,
-  read_inode2: reiserfs_read_inode2,
-  write_inode: reiserfs_write_inode,
-  dirty_inode: reiserfs_dirty_inode,
-  delete_inode: reiserfs_delete_inode,
-  put_super: reiserfs_put_super,
-  write_super: reiserfs_write_super,
-  write_super_lockfs: reiserfs_write_super_lockfs,
-  unlockfs: reiserfs_unlockfs,
-  statfs: reiserfs_statfs,
-  remount_fs: reiserfs_remount,
-
-  fh_to_dentry: reiserfs_fh_to_dentry,
-  dentry_to_fh: reiserfs_dentry_to_fh,
-
-};
-
-/* this was (ext2)parse_options */
-static int parse_options (char * options, unsigned long * mount_options, unsigned long * blocks)
-{
-    char * this_char;
-    char * value;
-  
-    *blocks = 0;
-    if (!options)
-	/* use default configuration: create tails, journaling on, no
-           conversion to newest format */
-	return 1;
-    for (this_char = strtok (options, ","); this_char != NULL; this_char = strtok (NULL, ",")) {
-	if ((value = strchr (this_char, '=')) != NULL)
-	    *value++ = 0;
-	if (!strcmp (this_char, "notail")) {
-	    set_bit (NOTAIL, mount_options);
-	} else if (!strcmp (this_char, "conv")) {
-	    // if this is set, we update super block such that
-	    // the partition will not be mounable by 3.5.x anymore
-	    set_bit (REISERFS_CONVERT, mount_options);
-	} else if (!strcmp (this_char, "noborder")) {
-				/* this is used for benchmarking
-                                   experimental variations, it is not
-                                   intended for users to use, only for
-                                   developers who want to casually
-                                   hack in something to test */
-	    set_bit (REISERFS_NO_BORDER, mount_options);
-	} else if (!strcmp (this_char, "no_unhashed_relocation")) {
-	    set_bit (REISERFS_NO_UNHASHED_RELOCATION, mount_options);
-	} else if (!strcmp (this_char, "hashed_relocation")) {
-	    set_bit (REISERFS_HASHED_RELOCATION, mount_options);
-	} else if (!strcmp (this_char, "test4")) {
-	    set_bit (REISERFS_TEST4, mount_options);
-	} else if (!strcmp (this_char, "nolog")) {
-	    reiserfs_warning("reiserfs: nolog mount option not supported yet\n");
-	} else if (!strcmp (this_char, "replayonly")) {
-	    set_bit (REPLAYONLY, mount_options);
-	} else if (!strcmp (this_char, "resize")) {
-	    if (value && *value){
-		*blocks = simple_strtoul (value, &value, 0);
-	    } else {
-	  	printk("reiserfs: resize option requires a value\n");
-		return 0;
-	    }
-	} else if (!strcmp (this_char, "hash")) {
-	    if (value && *value) {
-		/* if they specify any hash option, we force detection
-		** to make sure they aren't using the wrong hash
-		*/
-	        if (!strcmp(value, "rupasov")) {
-		    set_bit (FORCE_RUPASOV_HASH, mount_options);
-		    set_bit (FORCE_HASH_DETECT, mount_options);
-		} else if (!strcmp(value, "tea")) {
-		    set_bit (FORCE_TEA_HASH, mount_options);
-		    set_bit (FORCE_HASH_DETECT, mount_options);
-		} else if (!strcmp(value, "r5")) {
-		    set_bit (FORCE_R5_HASH, mount_options);
-		    set_bit (FORCE_HASH_DETECT, mount_options);
-		} else if (!strcmp(value, "detect")) {
-		    set_bit (FORCE_HASH_DETECT, mount_options);
-		} else {
-		    printk("reiserfs: invalid hash function specified\n") ;
-		    return 0 ;
-		}
-	    } else {
-	  	printk("reiserfs: hash option requires a value\n");
-		return 0 ;
-	    }
-	} else if (!strcmp (this_char, "attrs")) {
-	    set_bit (REISERFS_ATTRS, mount_options);
-	} else {
-	    printk ("reiserfs: Unrecognized mount option %s\n", this_char);
-	    return 0;
-	}
-    }
-    return 1;
+    return 1;
 }
 
 
@@ -506,24 +180,6 @@ int reiserfs_is_super(struct super_block
 }
 
 
-static void handle_attrs( struct super_block *s )
-{
-	struct reiserfs_super_block * rs;
-
-	if( reiserfs_attrs( s ) ) {
-		rs = SB_DISK_SUPER_BLOCK (s);
-		if( old_format_only(s) ) {
-			reiserfs_warning( "reiserfs: cannot support attributes on 3.5.x disk format\n" );
-			s -> u.reiserfs_sb.s_mount_opt &= ~ ( 1 << REISERFS_ATTRS );
-			return;
-		}
-		if( !( le32_to_cpu( rs -> s_flags ) & reiserfs_attrs_cleared ) ) {
-				reiserfs_warning( "reiserfs: cannot support attributes until flag is set in super-block\n" );
-				s -> u.reiserfs_sb.s_mount_opt &= ~ ( 1 << REISERFS_ATTRS );
-		}
-	}
-}
-
 //
 // a portion of this function, particularly the VFS interface portion,
 // was derived from minix or ext2's analog and evolved as the
@@ -531,38 +187,20 @@ static void handle_attrs( struct super_b
 // at the ext2 code and comparing. It's subfunctions contain no code
 // used as a template unless they are so labeled.
 //
-static int reiserfs_remount (struct super_block * s, int * flags, char * data)
+int reiserfs_remount (struct super_block * s, int * flags, char * data)
 {
   struct reiserfs_super_block * rs;
   struct reiserfs_transaction_handle th ;
   unsigned long blocks;
-  unsigned long mount_options = 0;
+  unsigned long mount_options;
 
   rs = SB_DISK_SUPER_BLOCK (s);
 
   if (!parse_options(data, &mount_options, &blocks))
   	return 0;
 
-#define SET_OPT( opt, bits, super )					\
-    if( ( bits ) & ( 1 << ( opt ) ) )					\
-	    ( super ) -> u.reiserfs_sb.s_mount_opt |= ( 1 << ( opt ) )
-
-  /* set options in the super-block bitmask */
-  SET_OPT( NOTAIL, mount_options, s );
-  SET_OPT( REISERFS_NO_BORDER, mount_options, s );
-  SET_OPT( REISERFS_NO_UNHASHED_RELOCATION, mount_options, s );
-  SET_OPT( REISERFS_HASHED_RELOCATION, mount_options, s );
-  SET_OPT( REISERFS_TEST4, mount_options, s );
-  SET_OPT( REISERFS_ATTRS, mount_options, s );
-#undef SET_OPT
-
-  handle_attrs( s );
-
-  if(blocks) {
-      int rc = reiserfs_resize(s, blocks);
-      if (rc != 0)
-	  return rc;
-  }
+  if(blocks) 
+  	reiserfs_resize(s, blocks);
 
   if ((unsigned long)(*flags & MS_RDONLY) == (s->s_flags & MS_RDONLY)) {
     /* there is nothing to do to remount read-only fs as read-only fs */
@@ -571,26 +209,28 @@ static int reiserfs_remount (struct supe
   
   if (*flags & MS_RDONLY) {
     /* try to remount file system with read-only permissions */
-    if (sb_state(rs) == REISERFS_VALID_FS || s->u.reiserfs_sb.s_mount_state != REISERFS_VALID_FS) {
+    if (le16_to_cpu (rs->s_state) == REISERFS_VALID_FS || s->u.reiserfs_sb.s_mount_state != REISERFS_VALID_FS) {
       return 0;
     }
 
+    unlock_super(s) ;
     journal_begin(&th, s, 10) ;
+    lock_super(s) ;
     /* Mounting a rw partition read-only. */
     reiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1) ;
-    set_sb_state( rs, s->u.reiserfs_sb.s_mount_state );
+    rs->s_state = cpu_to_le16 (s->u.reiserfs_sb.s_mount_state);
     journal_mark_dirty(&th, s, SB_BUFFER_WITH_SB (s));
     s->s_dirt = 0;
   } else {
-    s->u.reiserfs_sb.s_mount_state = sb_state(rs) ;
-    s->s_flags &= ~MS_RDONLY ; /* now it is safe to call journal_begin */
+    unlock_super(s) ;
     journal_begin(&th, s, 10) ;
+    lock_super(s) ;
 
     /* Mount a partition which is read-only, read-write */
     reiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1) ;
-    s->u.reiserfs_sb.s_mount_state = sb_state(rs);
+    s->u.reiserfs_sb.s_mount_state = le16_to_cpu (rs->s_state);
     s->s_flags &= ~MS_RDONLY;
-    set_sb_state( rs, REISERFS_ERROR_FS );
+    rs->s_state = cpu_to_le16 (REISERFS_ERROR_FS);
     /* mark_buffer_dirty (SB_BUFFER_WITH_SB (s), 1); */
     journal_mark_dirty(&th, s, SB_BUFFER_WITH_SB (s));
     s->s_dirt = 0;
@@ -598,41 +238,37 @@ static int reiserfs_remount (struct supe
   }
   /* this will force a full flush of all journal lists */
   SB_JOURNAL(s)->j_must_wait = 1 ;
+  unlock_super(s) ;
   journal_end(&th, s, 10) ;
-
-  if (!( *flags & MS_RDONLY ) )
-    finish_unfinished( s );
-
+  lock_super(s) ;
   return 0;
 }
 
 
 static int read_bitmaps (struct super_block * s)
 {
-    int i, bmp;
+    int i, bmp, dl ;
+    struct reiserfs_super_block * rs = SB_DISK_SUPER_BLOCK(s);
 
-    SB_AP_BITMAP (s) = reiserfs_kmalloc (sizeof (struct buffer_head *) * SB_BMAP_NR(s), GFP_NOFS, s);
+    SB_AP_BITMAP (s) = reiserfs_kmalloc (sizeof (struct buffer_head *) * le16_to_cpu (rs->s_bmap_nr), GFP_KERNEL, s);
     if (SB_AP_BITMAP (s) == 0)
-      return 1;
-    for (i = 0, bmp = REISERFS_DISK_OFFSET_IN_BYTES / s->s_blocksize + 1;
- 	 i < SB_BMAP_NR(s); i++, bmp = s->s_blocksize * 8 * i) {
-      SB_AP_BITMAP (s)[i] = getblk (s->s_dev, bmp, s->s_blocksize);
-      if (!buffer_uptodate(SB_AP_BITMAP(s)[i]))
-	ll_rw_block(READ, 1, SB_AP_BITMAP(s) + i); 
-    }
-    for (i = 0; i < SB_BMAP_NR(s); i++) {
-      wait_on_buffer(SB_AP_BITMAP (s)[i]);
-      if (!buffer_uptodate(SB_AP_BITMAP(s)[i])) {
-	reiserfs_warning("sh-2029: reiserfs read_bitmaps: "
-			 "bitmap block (#%lu) reading failed\n",
-			 SB_AP_BITMAP(s)[i]->b_blocknr);
-	for (i = 0; i < SB_BMAP_NR(s); i++)
-	  brelse(SB_AP_BITMAP(s)[i]);
-	reiserfs_kfree(SB_AP_BITMAP(s), sizeof(struct buffer_head *) * SB_BMAP_NR(s), s);
-	SB_AP_BITMAP(s) = NULL;
 	return 1;
-      }
-    }   
+    memset (SB_AP_BITMAP (s), 0, sizeof (struct buffer_head *) * le16_to_cpu (rs->s_bmap_nr));
+
+    /* reiserfs leaves the first 64k unused so that any partition
+       labeling scheme currently used will have enough space. Then we
+       need one block for the super.  -Hans */
+    bmp = (REISERFS_DISK_OFFSET_IN_BYTES / s->s_blocksize) + 1;	/* first of bitmap blocks */
+    SB_AP_BITMAP (s)[0] = reiserfs_bread (s, bmp, s->s_blocksize);
+    if(!SB_AP_BITMAP(s)[0])
+	return 1;
+    for (i = 1, bmp = dl = s->s_blocksize * 8; i < sb_bmap_nr(rs); i ++) {
+	SB_AP_BITMAP (s)[i] = reiserfs_bread (s, bmp, s->s_blocksize);
+	if (!SB_AP_BITMAP (s)[i])
+	    return 1;
+	bmp += dl;
+    }
+
     return 0;
 }
 
@@ -643,14 +279,14 @@ static int read_old_bitmaps (struct supe
   int bmp1 = (REISERFS_OLD_DISK_OFFSET_IN_BYTES / s->s_blocksize) + 1;  /* first of bitmap blocks */
 
   /* read true bitmap */
-  SB_AP_BITMAP (s) = reiserfs_kmalloc (sizeof (struct buffer_head *) * sb_bmap_nr(rs), GFP_NOFS, s);
+  SB_AP_BITMAP (s) = reiserfs_kmalloc (sizeof (struct buffer_head *) * le16_to_cpu (rs->s_bmap_nr), GFP_KERNEL, s);
   if (SB_AP_BITMAP (s) == 0)
     return 1;
 
-  memset (SB_AP_BITMAP (s), 0, sizeof (struct buffer_head *) * sb_bmap_nr(rs));
+  memset (SB_AP_BITMAP (s), 0, sizeof (struct buffer_head *) * le16_to_cpu (rs->s_bmap_nr));
 
-  for (i = 0; i < sb_bmap_nr(rs); i ++) {
-    SB_AP_BITMAP (s)[i] = reiserfs_bread (s, bmp1 + i, s->s_blocksize);
+  for (i = 0; i < le16_to_cpu (rs->s_bmap_nr); i ++) {
+    SB_AP_BITMAP (s)[i] = reiserfs_bread (s->s_dev, bmp1 + i, s->s_blocksize);
     if (!SB_AP_BITMAP (s)[i])
       return 1;
   }
@@ -735,26 +371,16 @@ static int read_super_block (struct supe
     ** will work.  If block we've just read in is inside the
     ** journal for that super, it can't be valid.  
     */
-    if (bh->b_blocknr >= sb_journal_block(rs) && 
-	bh->b_blocknr < (sb_journal_block(rs) + JOURNAL_BLOCK_COUNT)) {
+    if (bh->b_blocknr >= rs->s_journal_block && 
+	bh->b_blocknr < (rs->s_journal_block + JOURNAL_BLOCK_COUNT)) {
 	brelse(bh) ;
 	printk("super-459: read_super_block: "
 	       "super found at block %lu is within its own log. "
 	       "It must not be of this format type.\n", bh->b_blocknr) ;
 	return 1 ;
     }
-
-    if ( rs->s_root_block == -1 ) {
-	brelse(bh) ;
-	printk("dev %s: Unfinished reiserfsck --rebuild-tree run detected. Please run\n"
-	       "reiserfsck --rebuild-tree and wait for a completion. If that fails\n"
-	       "get newer reiserfsprogs package\n", kdevname (s->s_dev));
-	return 1;
-    }
-
     SB_BUFFER_WITH_SB (s) = bh;
     SB_DISK_SUPER_BLOCK (s) = rs;
-
     s->s_op = &reiserfs_sops;
 
     /* new format is limited by the 32 bit wide i_blocks field, want to
@@ -783,166 +409,411 @@ static int reread_meta_blocks(struct sup
       printk("reread_meta_blocks, error reading bitmap block number %d at %ld\n", i, SB_AP_BITMAP(s)[i]->b_blocknr) ;
       return 1 ;
     }
-  }
-  return 0 ;
-
+  }
+  return 0 ;
+
+}
+
+
+/////////////////////////////////////////////////////
+// hash detection stuff
+
+
+// if root directory is empty - we set default - Yura's - hash and
+// warn about it
+// FIXME: we look for only one name in a directory. If tea and yura
+// bith have the same value - we ask user to send report to the
+// mailing list
+__u32 find_hash_out (struct super_block * s)
+{
+    int retval;
+    struct inode * inode;
+    struct cpu_key key;
+    INITIALIZE_PATH (path);
+    struct reiserfs_dir_entry de;
+    __u32 hash = DEFAULT_HASH;
+
+    inode = s->s_root->d_inode;
+
+    while (1) {
+	make_cpu_key (&key, inode, ~0, TYPE_DIRENTRY, 3);
+	retval = search_by_entry_key (s, &key, &path, &de);
+	if (retval == IO_ERROR) {
+	    pathrelse (&path);
+	    return UNSET_HASH ;
+	}
+	if (retval == NAME_NOT_FOUND)
+	    de.de_entry_num --;
+	set_de_name_and_namelen (&de);
+	if (deh_offset( &(de.de_deh[de.de_entry_num]) ) == DOT_DOT_OFFSET) {
+	    /* allow override in this case */
+	    if (reiserfs_rupasov_hash(s)) {
+		hash = YURA_HASH ;
+	    }
+	    reiserfs_warning("reiserfs: FS seems to be empty, autodetect "
+	                     "is using the default hash\n");
+	    break;
+	}
+	if (GET_HASH_VALUE(yura_hash (de.de_name, de.de_namelen)) == 
+	    GET_HASH_VALUE(keyed_hash (de.de_name, de.de_namelen))) {
+	    reiserfs_warning ("reiserfs: Could not detect hash function "
+			      "please mount with -o hash={tea,rupasov,r5}\n") ;
+	    hash = UNSET_HASH ;
+	    break;
+	}
+	if (GET_HASH_VALUE( deh_offset(&(de.de_deh[de.de_entry_num])) ) ==
+	    GET_HASH_VALUE (yura_hash (de.de_name, de.de_namelen)))
+	    hash = YURA_HASH;
+	else
+	    hash = TEA_HASH;
+	break;
+    }
+
+    pathrelse (&path);
+    return hash;
+}
+
+// finds out which hash names are sorted with
+static int what_hash (struct super_block * s)
+{
+    __u32 code;
+
+    code = sb_hash_function_code(SB_DISK_SUPER_BLOCK(s));
+
+    /* reiserfs_hash_detect() == true if any of the hash mount options
+    ** were used.  We must check them to make sure the user isn't
+    ** using a bad hash value
+    */
+    if (code == UNSET_HASH || reiserfs_hash_detect(s))
+	code = find_hash_out (s);
+
+    if (code != UNSET_HASH && reiserfs_hash_detect(s)) {
+	/* detection has found the hash, and we must check against the 
+	** mount options 
+	*/
+	if (reiserfs_rupasov_hash(s) && code != YURA_HASH) {
+	    printk("REISERFS: Error, tea hash detected, "
+		   "unable to force rupasov hash\n") ;
+	    code = UNSET_HASH ;
+	} else if (reiserfs_tea_hash(s) && code != TEA_HASH) {
+	    printk("REISERFS: Error, rupasov hash detected, "
+		   "unable to force tea hash\n") ;
+	    code = UNSET_HASH ;
+	} else if (reiserfs_r5_hash(s) && code != R5_HASH) {
+	    printk("REISERFS: Error, r5 hash detected, "
+		   "unable to force r5 hash\n") ;
+	    code = UNSET_HASH ;
+	} 
+    } else { 
+        /* find_hash_out was not called or could not determine the hash */
+	if (reiserfs_rupasov_hash(s)) {
+	    code = YURA_HASH ;
+	} else if (reiserfs_tea_hash(s)) {
+	    code = TEA_HASH ;
+	} else if (reiserfs_r5_hash(s)) {
+	    code = R5_HASH ;
+	} 
+    }
+
+    /* if we are mounted RW, and we have a new valid hash code, update 
+    ** the super
+    */
+    if (code != UNSET_HASH && 
+	!(s->s_flags & MS_RDONLY) && 
+        code != sb_hash_function_code(SB_DISK_SUPER_BLOCK(s))) {
+        set_sb_hash_function_code(SB_DISK_SUPER_BLOCK(s), code);
+    }
+    return code;
+}
+
+// return pointer to appropriate function
+static hashf_t hash_function (struct super_block * s)
+{
+    switch (what_hash (s)) {
+    case TEA_HASH:
+	reiserfs_warning ("Using tea hash to sort names\n");
+	return keyed_hash;
+    case YURA_HASH:
+	reiserfs_warning ("Using rupasov hash to sort names\n");
+	return yura_hash;
+    case R5_HASH:
+	reiserfs_warning ("Using r5 hash to sort names\n");
+	return r5_hash;
+    }
+    return NULL;
+}
+
+// this is used to set up correct value for old partitions
+int function2code (hashf_t func)
+{
+    if (func == keyed_hash)
+	return TEA_HASH;
+    if (func == yura_hash)
+	return YURA_HASH;
+    if (func == r5_hash)
+	return R5_HASH;
+
+    BUG() ; // should never happen 
+
+    return 0;
+}
+
+extern const struct key  MAX_KEY;
+
+
+/* this is used to delete "save link" when there are no items of a
+   file it points to. It can either happen if unlink is completed but
+   "save unlink" removal, or if file has both unlink and truncate
+   pending and as unlink completes first (because key of "save link"
+   protecting unlink is bigger that a key lf "save link" which
+   protects truncate), so there left no items to make truncate
+   completion on */
+static void remove_save_link_only (struct super_block * s, struct key * key, int oid_free)
+{
+    struct reiserfs_transaction_handle th;
+
+     /* we are going to do one balancing */
+     journal_begin (&th, s, JOURNAL_PER_BALANCE_CNT);
+ 
+     reiserfs_delete_solid_item (&th, key);
+     if (oid_free)
+        /* removals are protected by direct items */
+        reiserfs_release_objectid (&th, le32_to_cpu (key->k_objectid));
+
+     journal_end (&th, s, JOURNAL_PER_BALANCE_CNT);
+}
+ 
+ 
+/* look for uncompleted unlinks and truncates and complete them */
+static void finish_unfinished (struct super_block * s)
+{
+    INITIALIZE_PATH (path);
+    struct cpu_key max_cpu_key, obj_key;
+    struct key save_link_key;
+    int retval;
+    struct item_head * ih;
+    struct buffer_head * bh;
+    int item_pos;
+    char * item;
+    int done;
+    struct inode * inode;
+    int truncate;
+ 
+ 
+    /* compose key to look for "save" links */
+    max_cpu_key.version = KEY_FORMAT_3_5;
+    max_cpu_key.on_disk_key = MAX_KEY;
+    max_cpu_key.key_length = 3;
+ 
+    done = 0;
+    s -> u.reiserfs_sb.s_is_unlinked_ok = 1;
+    while (1) {
+        retval = search_item (s, &max_cpu_key, &path);
+        if (retval != ITEM_NOT_FOUND) {
+            reiserfs_warning ("vs-2140: finish_unfinished: search_by_key returned %d\n",
+                              retval);
+            break;
+        }
+        
+        bh = get_last_bh (&path);
+        item_pos = get_item_pos (&path);
+        if (item_pos != B_NR_ITEMS (bh)) {
+            reiserfs_warning ("vs-2060: finish_unfinished: wrong position found\n");
+            break;
+        }
+        item_pos --;
+        ih = B_N_PITEM_HEAD (bh, item_pos);
+ 
+        if (le32_to_cpu (ih->ih_key.k_dir_id) != MAX_KEY_OBJECTID)
+            /* there are no "save" links anymore */
+            break;
+ 
+        save_link_key = ih->ih_key;
+        if (is_indirect_le_ih (ih))
+            truncate = 1;
+        else
+            truncate = 0;
+ 
+        /* reiserfs_iget needs k_dirid and k_objectid only */
+        item = B_I_PITEM (bh, ih);
+        obj_key.on_disk_key.k_dir_id = le32_to_cpu (*(__u32 *)item);
+        obj_key.on_disk_key.k_objectid = le32_to_cpu (ih->ih_key.k_objectid);
+	obj_key.on_disk_key.u.k_offset_v1.k_offset = 0;
+	obj_key.on_disk_key.u.k_offset_v1.k_uniqueness = 0;
+	
+        pathrelse (&path);
+ 
+        inode = reiserfs_iget (s, &obj_key);
+        if (!inode) {
+            /* the unlink almost completed, it just did not manage to remove
+	       "save" link and release objectid */
+            reiserfs_warning ("vs-2180: finish_unfinished: iget failed for %K\n",
+                              &obj_key);
+            remove_save_link_only (s, &save_link_key, 1);
+            continue;
+        }
+
+	if (!truncate && inode->i_nlink) {
+	    /* file is not unlinked */
+            reiserfs_warning ("vs-2185: finish_unfinished: file %K is not unlinked\n",
+                              &obj_key);
+            remove_save_link_only (s, &save_link_key, 0);
+            continue;
+	}
+
+	if (truncate && S_ISDIR (inode->i_mode) ) {
+	    /* We got a truncate request for a dir which is impossible.
+	       The only imaginable way is to execute unfinished truncate request
+	       then boot into old kernel, remove the file and create dir with
+	       the same key. */
+	    reiserfs_warning("green-2101: impossible truncate on a directory %k. Please report\n", INODE_PKEY (inode));
+	    remove_save_link_only (s, &save_link_key, 0);
+	    truncate = 0;
+	    iput (inode); 
+	    continue;
+	}
+ 
+        if (truncate) {
+            inode -> u.reiserfs_i.i_flags |= i_link_saved_truncate_mask;
+            /* not completed truncate found. New size was committed together
+	       with "save" link */
+            reiserfs_warning ("Truncating %k to %Ld ..",
+                              INODE_PKEY (inode), inode->i_size);
+            reiserfs_truncate_file (inode, 0/*don't update modification time*/);
+            remove_save_link (inode, truncate);
+        } else {
+            inode -> u.reiserfs_i.i_flags |= i_link_saved_unlink_mask;
+            /* not completed unlink (rmdir) found */
+            reiserfs_warning ("Removing %k..", INODE_PKEY (inode));
+            /* removal gets completed in iput */
+        }
+ 
+        iput (inode);
+        printk ("done\n");
+        done ++;
+    }
+    s -> u.reiserfs_sb.s_is_unlinked_ok = 0;
+     
+    pathrelse (&path);
+    if (done)
+        reiserfs_warning ("There were %d uncompleted unlinks/truncates. "
+                          "Completed\n", done);
 }
-
-
-/////////////////////////////////////////////////////
-// hash detection stuff
-
-
-// if root directory is empty - we set default - Yura's - hash and
-// warn about it
-// FIXME: we look for only one name in a directory. If tea and yura
-// bith have the same value - we ask user to send report to the
-// mailing list
-__u32 find_hash_out (struct super_block * s)
+ 
+/* to protect file being unlinked from getting lost we "safe" link files
+   being unlinked. This link will be deleted in the same transaction with last
+   item of file. mounting the filesytem we scan all these links and remove
+   files which almost got lost */
+void add_save_link (struct reiserfs_transaction_handle * th,
+		    struct inode * inode, int truncate)
 {
+    INITIALIZE_PATH (path);
     int retval;
-    struct inode * inode;
     struct cpu_key key;
-    INITIALIZE_PATH (path);
-    struct reiserfs_dir_entry de;
-    __u32 hash = DEFAULT_HASH;
-
-    inode = s->s_root->d_inode;
-
-    do { // Some serious "goto"-hater was there ;)
-	u32 teahash, r5hash, yurahash;
-
-	make_cpu_key (&key, inode, ~0, TYPE_DIRENTRY, 3);
-	retval = search_by_entry_key (s, &key, &path, &de);
-	if (retval == IO_ERROR) {
-	    pathrelse (&path);
-	    return UNSET_HASH ;
-	}
-	if (retval == NAME_NOT_FOUND)
-	    de.de_entry_num --;
-	set_de_name_and_namelen (&de);
-	if (deh_offset( &(de.de_deh[de.de_entry_num]) ) == DOT_DOT_OFFSET) {
-	    /* allow override in this case */
-	    if (reiserfs_rupasov_hash(s)) {
-		hash = YURA_HASH ;
-	    }
-	    reiserfs_warning("reiserfs: FS seems to be empty, autodetect "
-	                     "is using the default hash\n");
-	    break;
-	}
-	r5hash=GET_HASH_VALUE (r5_hash (de.de_name, de.de_namelen));
-	teahash=GET_HASH_VALUE (keyed_hash (de.de_name, de.de_namelen));
-	yurahash=GET_HASH_VALUE (yura_hash (de.de_name, de.de_namelen));
-	if ( ( (teahash == r5hash) && (GET_HASH_VALUE( deh_offset(&(de.de_deh[de.de_entry_num]))) == r5hash) ) ||
-	     ( (teahash == yurahash) && (yurahash == GET_HASH_VALUE( deh_offset(&(de.de_deh[de.de_entry_num])))) ) ||
-	     ( (r5hash == yurahash) && (yurahash == GET_HASH_VALUE( deh_offset(&(de.de_deh[de.de_entry_num])))) ) ) {
-	    reiserfs_warning("reiserfs: Unable to automatically detect hash"
-		"function for device %s\n"
-		"please mount with -o hash={tea,rupasov,r5}\n", kdevname (s->s_dev));
-	    hash = UNSET_HASH;
-	    break;
-	}
-	if (GET_HASH_VALUE( deh_offset(&(de.de_deh[de.de_entry_num])) ) == yurahash)
-	    hash = YURA_HASH;
-	else if (GET_HASH_VALUE( deh_offset(&(de.de_deh[de.de_entry_num])) ) == teahash)
-	    hash = TEA_HASH;
-	else if (GET_HASH_VALUE( deh_offset(&(de.de_deh[de.de_entry_num])) ) == r5hash)
-	    hash = R5_HASH;
-	else {
-	    reiserfs_warning("reiserfs: Unrecognised hash function for "
-			     "device %s\n", kdevname (s->s_dev));
-	    hash = UNSET_HASH;
-	}
-    } while (0);
+    struct item_head ih;
+    __u32 link;
 
-    pathrelse (&path);
-    return hash;
-}
+    /* file can only get one "save link" of each kind */
+    RFALSE( truncate && 
+	    ( inode -> u.reiserfs_i.i_flags & i_link_saved_truncate_mask ),
+	    "saved link already exists for truncated inode %lx",
+	    ( long ) inode -> i_ino );
+    RFALSE( !truncate && 
+	    ( inode -> u.reiserfs_i.i_flags & i_link_saved_unlink_mask ),
+	    "saved link already exists for unlinked inode %lx",
+	    ( long ) inode -> i_ino );
 
-// finds out which hash names are sorted with
-static int what_hash (struct super_block * s)
-{
-    __u32 code;
+    /* setup key of "save" link */
+    key.version = KEY_FORMAT_3_5;
+    key.on_disk_key.k_dir_id = MAX_KEY_OBJECTID;
+    key.on_disk_key.k_objectid = inode->i_ino;
+    if (!truncate) {
+	/* unlink, rmdir, rename */
+	set_cpu_key_k_offset (&key, 1 + inode->i_sb->s_blocksize);
+	set_cpu_key_k_type (&key, TYPE_DIRECT);
 
-    code = sb_hash_function_code(SB_DISK_SUPER_BLOCK(s));
+	/* item head of "safe" link */
+	make_le_item_head (&ih, &key, key.version, 1 + inode->i_sb->s_blocksize, TYPE_DIRECT,
+			   4/*length*/, 0xffff/*free space*/);
+    } else {
+	/* truncate */
+	if (S_ISDIR (inode->i_mode))
+	    reiserfs_warning("green-2102: Adding a truncate savelink for a directory %k! Please report\n", INODE_PKEY(inode));
+	set_cpu_key_k_offset (&key, 1);
+	set_cpu_key_k_type (&key, TYPE_INDIRECT);
 
-    /* reiserfs_hash_detect() == true if any of the hash mount options
-    ** were used.  We must check them to make sure the user isn't
-    ** using a bad hash value
-    */
-    if (code == UNSET_HASH || reiserfs_hash_detect(s))
-	code = find_hash_out (s);
+	/* item head of "safe" link */
+	make_le_item_head (&ih, &key, key.version, 1, TYPE_INDIRECT,
+			   4/*length*/, 0/*free space*/);
+    }
+    key.key_length = 3;
 
-    if (code != UNSET_HASH && reiserfs_hash_detect(s)) {
-	/* detection has found the hash, and we must check against the 
-	** mount options 
-	*/
-	if (reiserfs_rupasov_hash(s) && code != YURA_HASH) {
-	    printk("REISERFS: Error, %s hash detected, "
-		   "unable to force rupasov hash\n", reiserfs_hashname(code)) ;
-	    code = UNSET_HASH ;
-	} else if (reiserfs_tea_hash(s) && code != TEA_HASH) {
-	    printk("REISERFS: Error, %s hash detected, "
-		   "unable to force tea hash\n", reiserfs_hashname(code)) ;
-	    code = UNSET_HASH ;
-	} else if (reiserfs_r5_hash(s) && code != R5_HASH) {
-	    printk("REISERFS: Error, %s hash detected, "
-		   "unable to force r5 hash\n", reiserfs_hashname(code)) ;
-	    code = UNSET_HASH ;
-	} 
-    } else { 
-        /* find_hash_out was not called or could not determine the hash */
-	if (reiserfs_rupasov_hash(s)) {
-	    code = YURA_HASH ;
-	} else if (reiserfs_tea_hash(s)) {
-	    code = TEA_HASH ;
-	} else if (reiserfs_r5_hash(s)) {
-	    code = R5_HASH ;
-	} 
+    /* look for its place in the tree */
+    retval = search_item (inode->i_sb, &key, &path);
+    if (retval != ITEM_NOT_FOUND) {
+	if ( retval != -ENOSPC )
+	    reiserfs_warning ("vs-2100: add_save_link:"
+			  "search_by_key (%K) returned %d\n", &key, retval);
+	pathrelse (&path);
+	return;
     }
 
-    /* if we are mounted RW, and we have a new valid hash code, update 
-    ** the super
-    */
-    if (code != UNSET_HASH && 
-	!(s->s_flags & MS_RDONLY) && 
-        code != sb_hash_function_code(SB_DISK_SUPER_BLOCK(s))) {
-        set_sb_hash_function_code(SB_DISK_SUPER_BLOCK(s), code);
+    /* body of "save" link */
+    link = cpu_to_le32 (INODE_PKEY (inode)->k_dir_id);
+
+    /* put "save" link inot tree */
+    retval = reiserfs_insert_item (th, &path, &key, &ih, (char *)&link);
+    if (retval) {
+	if (retval != -ENOSPC)
+	    reiserfs_warning ("vs-2120: add_save_link: insert_item returned %d\n",
+			  retval);
+    } else {
+	if( truncate )
+	    inode -> u.reiserfs_i.i_flags |= i_link_saved_truncate_mask;
+	else
+	    inode -> u.reiserfs_i.i_flags |= i_link_saved_unlink_mask;
     }
-    return code;
 }
 
-// return pointer to appropriate function
-static hashf_t hash_function (struct super_block * s)
+
+/* this opens transaction unlike add_save_link */
+void remove_save_link (struct inode * inode, int truncate)
 {
-    switch (what_hash (s)) {
-    case TEA_HASH:
-	reiserfs_warning ("Using tea hash to sort names\n");
-	return keyed_hash;
-    case YURA_HASH:
-	reiserfs_warning ("Using rupasov hash to sort names\n");
-	return yura_hash;
-    case R5_HASH:
-	reiserfs_warning ("Using r5 hash to sort names\n");
-	return r5_hash;
+    struct reiserfs_transaction_handle th;
+    struct key key;
+ 
+ 
+    /* we are going to do one balancing only */
+    journal_begin (&th, inode->i_sb, JOURNAL_PER_BALANCE_CNT);
+ 
+    /* setup key of "save" link */
+    key.k_dir_id = cpu_to_le32 (MAX_KEY_OBJECTID);
+    key.k_objectid = INODE_PKEY (inode)->k_objectid;
+    if (!truncate) {
+        /* unlink, rmdir, rename */
+        set_le_key_k_offset (KEY_FORMAT_3_5, &key,
+			     1 + inode->i_sb->s_blocksize);
+        set_le_key_k_type (KEY_FORMAT_3_5, &key, TYPE_DIRECT);
+    } else {
+        /* truncate */
+        set_le_key_k_offset (KEY_FORMAT_3_5, &key, 1);
+        set_le_key_k_type (KEY_FORMAT_3_5, &key, TYPE_INDIRECT);
     }
-    return NULL;
+ 
+    if( ( truncate && 
+          ( inode -> u.reiserfs_i.i_flags & i_link_saved_truncate_mask ) ) ||
+        ( !truncate && 
+          ( inode -> u.reiserfs_i.i_flags & i_link_saved_unlink_mask ) ) )
+	reiserfs_delete_solid_item (&th, &key);
+    if (!truncate) {
+	reiserfs_release_objectid (&th, inode->i_ino);
+	inode -> u.reiserfs_i.i_flags &= ~i_link_saved_unlink_mask;
+    } else
+	inode -> u.reiserfs_i.i_flags &= ~i_link_saved_truncate_mask;
+ 
+    journal_end (&th, inode->i_sb, JOURNAL_PER_BALANCE_CNT);
 }
 
-// this is used to set up correct value for old partitions
-int function2code (hashf_t func)
-{
-    if (func == keyed_hash)
-	return TEA_HASH;
-    if (func == yura_hash)
-	return YURA_HASH;
-    if (func == r5_hash)
-	return R5_HASH;
-
-    BUG() ; // should never happen 
-
-    return 0;
-}
 
 //
 // a portion of this function, particularly the VFS interface portion,
@@ -995,8 +866,6 @@ static struct super_block * reiserfs_rea
 	    old_format = 1;
     }
 
-    rs = SB_DISK_SUPER_BLOCK (s);
-
     s->u.reiserfs_sb.s_mount_state = SB_REISERFS_STATE(s);
     s->u.reiserfs_sb.s_mount_state = REISERFS_VALID_FS ;
 
@@ -1004,12 +873,7 @@ static struct super_block * reiserfs_rea
 	printk ("reiserfs_read_super: unable to read bitmap\n");
 	goto error;
     }
-#ifdef CONFIG_REISERFS_CHECK
-    printk("reiserfs:warning: CONFIG_REISERFS_CHECK is set ON\n");
-    printk("reiserfs:warning: - it is slow mode for debugging.\n");
-#endif
 
-    // set_device_ro(s->s_dev, 1) ;
     if (journal_init(s)) {
 	printk("reiserfs_read_super: unable to initialize journal space\n") ;
 	goto error ;
@@ -1026,10 +890,6 @@ static struct super_block * reiserfs_rea
     if (replay_only (s))
 	goto error;
 
-    if (is_read_only(s->s_dev) && !(s->s_flags & MS_RDONLY)) {
-        printk("clm-7000: Detected readonly device, marking FS readonly\n") ;
-	s->s_flags |= MS_RDONLY ;
-    }
     args.objectid = REISERFS_ROOT_PARENT_OBJECTID ;
     root_inode = iget4 (s, REISERFS_ROOT_OBJECTID, 0, (void *)(&args));
     if (!root_inode) {
@@ -1068,36 +928,30 @@ static struct super_block * reiserfs_rea
 
         if ( old_magic ) {
 	    // filesystem created under 3.5.x found
-	    if (convert_reiserfs (s)) {
-		reiserfs_warning("reiserfs: converting 3.5.x filesystem to the new format\n") ;
+	    if (!old_format_only (s)) {
+		reiserfs_warning("reiserfs: WARNING! Mounting a 3.5.X disk. Converting to new format\n") ;
 		// after this 3.5.x will not be able to mount this partition
 		memcpy (rs->s_magic, REISER2FS_SUPER_MAGIC_STRING, 
 			sizeof (REISER2FS_SUPER_MAGIC_STRING));
 
 		reiserfs_convert_objectid_map_v1(s) ;
-		set_bit(REISERFS_3_6, &(s->u.reiserfs_sb.s_properties));
-		clear_bit(REISERFS_3_5, &(s->u.reiserfs_sb.s_properties));
-	    } else {
-		reiserfs_warning("reiserfs: using 3.5.x disk format\n") ;
-	    }
+	    } else
+		reiserfs_warning("reiserfs: WARNING! Mounting a 3.5.X disk. Keeping old format\n") ;
+	} else {
+	    // new format found
+	    set_bit (REISERFS_CONVERT, &(s->u.reiserfs_sb.s_mount_opt));	    
 	}
 
+	// mark hash in super block: it could be unset. overwrite should be ok
+        set_sb_hash_function_code( rs, function2code(s->u.reiserfs_sb.s_hash_function ) );
+
 	journal_mark_dirty(&th, s, SB_BUFFER_WITH_SB (s));
 	journal_end(&th, s, 1) ;
-	
-	/* look for files which were to be removed in previous session */
-	finish_unfinished (s);
-
 	s->s_dirt = 0;
-    } else {
-	if ( old_magic ) {
-	    reiserfs_warning("reiserfs: using 3.5.x disk format\n") ;
-	}
     }
-    // mark hash in super block: it could be unset. overwrite should be ok
-    set_sb_hash_function_code( rs, function2code(s->u.reiserfs_sb.s_hash_function ) );
 
-    handle_attrs( s );
+    /* we have to do this to make journal writes work correctly */
+    SB_BUFFER_WITH_SB(s)->b_end_io = reiserfs_end_buffer_io_sync ;
 
     reiserfs_proc_info_init( s );
     reiserfs_proc_register( s, "version", reiserfs_version_in_proc );
@@ -1131,6 +985,24 @@ static struct super_block * reiserfs_rea
 }
 
 
+static void handle_attrs( struct super_block *s )
+{
+	struct reiserfs_super_block * rs;
+
+	if( reiserfs_attrs( s ) ) {
+		rs = SB_DISK_SUPER_BLOCK (s);
+		if( old_format_only(s) ) {
+			reiserfs_warning( "reiserfs: cannot support attributes on 3.5.x disk format\n" );
+			s -> u.reiserfs_sb.s_mount_opt &= ~ ( 1 << REISERFS_ATTRS );
+			return;
+		}
+		if( !( le32_to_cpu( rs -> s_flags ) & reiserfs_attrs_cleared ) ) {
+				reiserfs_warning( "reiserfs: cannot support attributes until flag is set in super-block\n" );
+				s -> u.reiserfs_sb.s_mount_opt &= ~ ( 1 << REISERFS_ATTRS );
+		}
+	}
+}
+
 //
 // a portion of this function, particularly the VFS interface portion,
 // was derived from minix or ext2's analog and evolved as the
diff -urp linux/fs/reiserfs/tail_conversion.c new_kernel_src/fs/reiserfs/tail_conversion.c
--- linux/fs/reiserfs/tail_conversion.c	2009-06-10 21:00:37.000000000 +0100
+++ new_kernel_src/fs/reiserfs/tail_conversion.c	2002-03-25 03:10:33.000000000 +0000
@@ -2,12 +2,20 @@
  * Copyright 1999 Hans Reiser, see reiserfs/README for licensing and copyright details
  */
 
-#include <linux/config.h>
+#ifdef __KERNEL__
+
 #include <linux/sched.h>
 #include <linux/pagemap.h>
 #include <linux/reiserfs_fs.h>
 #include <linux/locks.h>
 
+#else
+
+#include "nokernel.h"
+
+#endif
+
+
 /* access to tail : when one is going to read tail it must make sure, that is not running.
  direct2indirect and indirect2direct can not run concurrently */
 
@@ -21,7 +29,6 @@ int direct2indirect (struct reiserfs_tra
 		     loff_t tail_offset)
 {
     struct super_block * sb = inode->i_sb;
-    struct buffer_head *up_to_date_bh ;
     struct item_head * p_le_ih = PATH_PITEM_HEAD (path);
     unsigned long total_tail = 0 ;
     struct cpu_key end_key;  /* Key to search for the last byte of the
@@ -45,6 +52,12 @@ int direct2indirect (struct reiserfs_tra
     set_le_ih_k_offset (&ind_ih, tail_offset);
     set_le_ih_k_type (&ind_ih, TYPE_INDIRECT);
 
+    if (is_tail_convert_locked (inode))
+	BUG ();
+    wait_on_tail (inode);
+    lock_tail (inode, CONVERT_TAIL_LOCK);
+
+
     /* Set the key to search for the place for new unfm pointer */
     make_cpu_key (&end_key, inode, tail_offset, TYPE_INDIRECT, 4);
 
@@ -75,6 +88,7 @@ int direct2indirect (struct reiserfs_tra
 					    (char *)&unfm_ptr, UNFM_P_SIZE);
     }
     if ( n_retval ) {
+	unlock_tail (inode);
 	return n_retval;
     }
 
@@ -102,35 +116,17 @@ int direct2indirect (struct reiserfs_tra
         tail_size = (le_ih_k_offset (p_le_ih) & (n_blk_size - 1))
             + ih_item_len(p_le_ih) - 1;
 
-	/* we only send the unbh pointer if the buffer is not up to date.
-	** this avoids overwriting good data from writepage() with old data
-	** from the disk or buffer cache
-	*/
-	if (buffer_uptodate(unbh) || Page_Uptodate(unbh->b_page)) {
-	    up_to_date_bh = NULL ;
-	} else {
-	    up_to_date_bh = unbh ;
-	}
-	n_retval = reiserfs_delete_item (th, path, &end_key, inode, 
-	                                 up_to_date_bh) ;
-
-	total_tail += n_retval ;
-	if (tail_size == n_retval)
+	n_retval = reiserfs_delete_item (th, path, &end_key, inode, unbh);
+	if (first_direct && item_len == n_retval)
 	    // done: file does not have direct items anymore
 	    break;
 
     }
-    /* if we've copied bytes from disk into the page, we need to zero
-    ** out the unused part of the block (it was not up to date before)
-    ** the page is still kmapped (by whoever called reiserfs_get_block)
-    */
-    if (up_to_date_bh) {
-        unsigned pgoff = (tail_offset + total_tail - 1) & (PAGE_CACHE_SIZE - 1);
-	memset(page_address(unbh->b_page) + pgoff, 0, n_blk_size - total_tail) ;
-    }
 
     inode->u.reiserfs_i.i_first_direct_byte = U32_MAX;
 
+    unlock_tail (inode);
+
     return 0;
 }
 
@@ -142,45 +138,46 @@ void reiserfs_unmap_buffer(struct buffer
       BUG() ;
     }
     mark_buffer_clean(bh) ;
-    lock_buffer(bh) ;
+    wait_on_buffer(bh) ;
+    clear_bit(BH_Uptodate, &bh->b_state) ;
     clear_bit(BH_Mapped, &bh->b_state) ;
     clear_bit(BH_Req, &bh->b_state) ;
     clear_bit(BH_New, &bh->b_state) ;
-    unlock_buffer(bh) ;
   }
 }
 
 static void
-unmap_buffers(struct page *page, loff_t pos) {
+unmap_buffers(struct inode *p_s_inode, loff_t pos) {
+  loff_t cur_pos = pos ;
+  struct page *page ;
+  unsigned long index; 
   struct buffer_head *bh ;
   struct buffer_head *head ;
   struct buffer_head *next ;
-  unsigned long tail_index ;
-  unsigned long cur_index ;
 
-  if (page) {
-    if (page->buffers) {
-      tail_index = pos & (PAGE_CACHE_SIZE - 1) ;
-      cur_index = 0 ;
-      head = page->buffers ;
-      bh = head ;
-      do {
-	next = bh->b_this_page ;
-
-        /* we want to unmap the buffers that contain the tail, and
-        ** all the buffers after it (since the tail must be at the
-        ** end of the file).  We don't want to unmap file data 
-        ** before the tail, since it might be dirty and waiting to 
-        ** reach disk
-        */
-        cur_index += bh->b_size ;
-        if (cur_index > tail_index) {
-          reiserfs_unmap_buffer(bh) ;
-        }
-	bh = next ;
-      } while (bh != head) ;
-    }
-  } 
+
+  /* starting with brute force method, get all the buffers in 
+  ** the page.  Since blocksize == 4k == pagesize, this is not
+  ** a performance hit on intel.
+  */
+  while (cur_pos <= p_s_inode->i_size) {
+    index = cur_pos >> PAGE_CACHE_SHIFT ;
+    page = grab_cache_page(p_s_inode->i_mapping, index) ;
+    if (page) {
+      if (page->buffers) {
+	head = page->buffers ;
+	bh = head ;
+        do {
+	  next = bh->b_this_page ;
+	  reiserfs_unmap_buffer(bh) ;
+	  bh = next ;
+	} while (bh != head) ;
+      }
+      UnlockPage(page) ;
+      page_cache_release(page) ;
+    } 
+    cur_pos += PAGE_CACHE_SIZE ;
+  }
 }
 
 /* this first locks inode (neither reads nor sync are permitted),
@@ -191,7 +188,6 @@ unmap_buffers(struct page *page, loff_t 
    inode */
 int indirect2direct (struct reiserfs_transaction_handle *th, 
 		     struct inode * p_s_inode,
-		     struct page *page, 
 		     struct path * p_s_path, /* path to the indirect item. */
 		     const struct cpu_key * p_s_item_key, /* Key to look for unformatted node pointer to be cut. */
 		     loff_t n_new_file_size, /* New file size. */
@@ -203,6 +199,7 @@ int indirect2direct (struct reiserfs_tra
     char * tail;
     int tail_len, round_tail_len;
     loff_t pos, pos1; /* position of first byte of the tail */
+    struct page * page;
     struct cpu_key key;
 
     p_s_sb->u.reiserfs_sb.s_indirect2direct ++;
@@ -221,11 +218,32 @@ int indirect2direct (struct reiserfs_tra
     pos = le_ih_k_offset (&s_ih) - 1 + (ih_item_len(&s_ih) / UNFM_P_SIZE - 1) * p_s_sb->s_blocksize;
     pos1 = pos;
 
+
     // we are protected by i_sem. The tail can not disapper, not
     // append can be done either
+    page = grab_cache_page (p_s_inode->i_mapping, pos >> PAGE_CACHE_SHIFT);
+    if (page == 0) {
+	pathrelse (p_s_path);
+	return n_block_size - round_tail_len;
+    }
+
+    if (!Page_Uptodate(page)) {
+	block_read_full_page (page, reiserfs_get_block);
+	wait_on_page (page);
+	if (!Page_Uptodate(page)) {
+	    UnlockPage (page);
+	    page_cache_release (page);
+	    pathrelse (p_s_path);
+	    return n_block_size - round_tail_len;
+	}
+    }
+
     // we are in truncate or packing tail in file_release
+    if (is_tail_convert_locked (p_s_inode))
+	BUG ();
+    wait_on_tail (p_s_inode);
+    lock_tail (p_s_inode, CONVERT_TAIL_LOCK);
 
-    tail = (char *)kmap(page) ; /* this can schedule */
 
     if (path_changed (&s_ih, p_s_path)) {
 	/* re-search indirect item */
@@ -246,12 +264,7 @@ int indirect2direct (struct reiserfs_tra
     /* Set direct item header to insert. */
     make_le_item_head (&s_ih, 0, get_inode_item_key_version (p_s_inode), pos1 + 1,
 		       TYPE_DIRECT, round_tail_len, 0xffff/*ih_free_space*/);
-
-    /* we want a pointer to the first byte of the tail in the page.
-    ** the page was locked and this part of the page was up to date when
-    ** indirect2direct was called, so we know the bytes are still valid
-    */
-    tail = tail + (pos & (PAGE_CACHE_SIZE - 1)) ;
+    tail = (char *)page_address (page) + (pos & (PAGE_CACHE_SIZE - 1));
 
     PATH_LAST_POSITION(p_s_path)++;
 
@@ -267,15 +280,19 @@ int indirect2direct (struct reiserfs_tra
 	   used, it would be ideal to write zeros to corresponding
 	   unformatted node. For now i_size is considered as guard for
 	   going out of file size */
-	kunmap(page) ;
+	UnlockPage (page);
+	page_cache_release (page);
+	unlock_tail (p_s_inode);
 	return n_block_size - round_tail_len;
     }
-    kunmap(page) ;
+    UnlockPage (page);
+    page_cache_release (page);
 
+    /* vmtruncate (p_s_inode, pos1); */
     /* this will invalidate all the buffers in the page after
     ** pos1
     */
-    unmap_buffers(page, pos1) ;
+    unmap_buffers(p_s_inode, pos1) ;
 
     // note: we have now the same as in above direct2indirect
     // conversion: there are two keys which have matching first three
Only in new_kernel_src/fs/reiserfs: utils
diff -urp linux/fs/reiserfs/version.c new_kernel_src/fs/reiserfs/version.c
--- linux/fs/reiserfs/version.c	2001-01-15 20:42:32.000000000 +0000
+++ new_kernel_src/fs/reiserfs/version.c	2000-12-10 12:46:08.000000000 +0000
@@ -1,7 +1,7 @@
 /*
- * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README
+ * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
  */
 
 char *reiserfs_get_version_string(void) {
-  return "ReiserFS version 3.6.25" ;
+  return "ReiserFS version 3.6.11" ;
 }
Only in new_kernel_src/include: asm
Only in new_kernel_src/include/asm-arm: arch-a5k
diff -urp linux/include/asm-i386/irq.h new_kernel_src/include/asm-i386/irq.h
--- linux/include/asm-i386/irq.h	2009-06-10 21:00:37.000000000 +0100
+++ new_kernel_src/include/asm-i386/irq.h	2002-03-25 05:30:29.000000000 +0000
@@ -26,7 +26,8 @@
 #ifdef CONFIG_X86_IO_APIC
 #define NR_IRQS 224
 #else
-#define NR_IRQS 16
+//#define NR_IRQS 16
+#define NR_IRQS 32 /* For Amithlon, we need at least 32.... */
 #endif
 
 static __inline__ int irq_cannonicalize(int irq)
diff -urp linux/include/asm-i386/processor.h new_kernel_src/include/asm-i386/processor.h
--- linux/include/asm-i386/processor.h	2009-06-10 21:00:37.000000000 +0100
+++ new_kernel_src/include/asm-i386/processor.h	2002-03-25 03:37:32.000000000 +0000
@@ -271,7 +271,7 @@ extern unsigned int mca_pentium_flag;
 /* This decides where the kernel will search for a free chunk of vm
  * space during mmap's.
  */
-#define TASK_UNMAPPED_BASE	(TASK_SIZE / 3)
+#define TASK_UNMAPPED_BASE	(TASK_SIZE / 12 * 11)
 
 /*
  * Size of io_bitmap in longwords: 32 is ports 0-0x3ff.
Only in new_kernel_src/include/linux: biglogo.h
Only in new_kernel_src/include/linux: biglogo2.h
diff -urp linux/include/linux/bootmem.h new_kernel_src/include/linux/bootmem.h
--- linux/include/linux/bootmem.h	2001-11-22 19:47:23.000000000 +0000
+++ new_kernel_src/include/linux/bootmem.h	2002-03-25 03:37:52.000000000 +0000
@@ -32,6 +32,7 @@ typedef struct bootmem_data {
 extern unsigned long __init bootmem_bootmap_pages (unsigned long);
 extern unsigned long __init init_bootmem (unsigned long addr, unsigned long memend);
 extern void __init reserve_bootmem (unsigned long addr, unsigned long size);
+extern int  __init bootmem_is_reserved (unsigned long addr);
 extern void __init free_bootmem (unsigned long addr, unsigned long size);
 extern void * __init __alloc_bootmem (unsigned long size, unsigned long align, unsigned long goal);
 #define alloc_bootmem(x) \
Only in new_kernel_src/include/linux: compat
Only in new_kernel_src/include/linux: df
diff -urp linux/include/linux/fs.h new_kernel_src/include/linux/fs.h
--- linux/include/linux/fs.h	2009-06-10 21:00:37.000000000 +0100
+++ new_kernel_src/include/linux/fs.h	2002-03-25 03:37:32.000000000 +0000
@@ -510,6 +510,35 @@ struct inode {
 	} u;
 };
 
+/* Inode state bits.. */
+#define I_DIRTY_SYNC		1 /* Not dirty enough for O_DATASYNC */
+#define I_DIRTY_DATASYNC	2 /* Data-related inode changes pending */
+#define I_DIRTY_PAGES		4 /* Data-related inode changes pending */
+#define I_LOCK			8
+#define I_FREEING		16
+#define I_CLEAR			32
+
+#define I_DIRTY (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_PAGES)
+
+extern void __mark_inode_dirty(struct inode *, int);
+static inline void mark_inode_dirty(struct inode *inode)
+{
+	if ((inode->i_state & I_DIRTY) != I_DIRTY)
+		__mark_inode_dirty(inode, I_DIRTY);
+}
+
+static inline void mark_inode_dirty_sync(struct inode *inode)
+{
+	if (!(inode->i_state & I_DIRTY_SYNC))
+		__mark_inode_dirty(inode, I_DIRTY_SYNC);
+}
+
+static inline void mark_inode_dirty_pages(struct inode *inode)
+{
+	if (inode && !(inode->i_state & I_DIRTY_PAGES))
+		__mark_inode_dirty(inode, I_DIRTY_PAGES);
+}
+
 struct fown_struct {
 	int pid;		/* pid or -pgrp where SIGIO should be sent */
 	uid_t uid, euid;	/* uid/euid of process setting the owner */
@@ -885,8 +914,6 @@ struct super_operations {
 	void (*delete_inode) (struct inode *);
 	void (*put_super) (struct super_block *);
 	void (*write_super) (struct super_block *);
-	void (*write_super_lockfs) (struct super_block *);
-	void (*unlockfs) (struct super_block *);
 	int (*statfs) (struct super_block *, struct statfs *);
 	int (*remount_fs) (struct super_block *, int *, char *);
 	void (*clear_inode) (struct inode *);
@@ -919,32 +946,6 @@ struct super_operations {
 	int (*show_options)(struct seq_file *, struct vfsmount *);
 };
 
-/* Inode state bits.. */
-#define I_DIRTY_SYNC		1 /* Not dirty enough for O_DATASYNC */
-#define I_DIRTY_DATASYNC	2 /* Data-related inode changes pending */
-#define I_DIRTY_PAGES		4 /* Data-related inode changes pending */
-#define I_LOCK			8
-#define I_FREEING		16
-#define I_CLEAR			32
-
-#define I_DIRTY (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_PAGES)
-
-extern void __mark_inode_dirty(struct inode *, int);
-static inline void mark_inode_dirty(struct inode *inode)
-{
-	__mark_inode_dirty(inode, I_DIRTY);
-}
-
-static inline void mark_inode_dirty_sync(struct inode *inode)
-{
-	__mark_inode_dirty(inode, I_DIRTY_SYNC);
-}
-
-static inline void mark_inode_dirty_pages(struct inode *inode)
-{
-	__mark_inode_dirty(inode, I_DIRTY_PAGES);
-}
-
 struct dquot_operations {
 	void (*initialize) (struct inode *, short);
 	void (*drop) (struct inode *);
@@ -1115,9 +1116,6 @@ extern void refile_buffer(struct buffer_
 extern void create_empty_buffers(struct page *, kdev_t, unsigned long);
 extern void end_buffer_io_sync(struct buffer_head *bh, int uptodate);
 
-/* reiserfs_writepage needs this */
-extern void set_buffer_async_io(struct buffer_head *bh) ;
-
 #define BUF_CLEAN	0
 #define BUF_LOCKED	1	/* Buffers scheduled for write */
 #define BUF_DIRTY	2	/* Dirty buffers, not yet scheduled for write */
diff -urp linux/include/linux/keyboard.h new_kernel_src/include/linux/keyboard.h
--- linux/include/linux/keyboard.h	2001-11-22 19:47:07.000000000 +0000
+++ new_kernel_src/include/linux/keyboard.h	2002-03-25 03:37:46.000000000 +0000
@@ -328,6 +328,19 @@ extern unsigned char keyboard_type;
 #define K_INCRCONSOLE	K(KT_SPEC,17)
 #define K_SPAWNCONSOLE	K(KT_SPEC,18)
 #define K_BARENUMLOCK	K(KT_SPEC,19)
+#define K_DECRVOL       K(KT_SPEC,20)
+#define K_INCRVOL       K(KT_SPEC,21)
+#define K_DECRLINE      K(KT_SPEC,22)
+#define K_INCRLINE      K(KT_SPEC,23)
+#define K_DECRCD        K(KT_SPEC,24)
+#define K_INCRCD        K(KT_SPEC,25)
+#define K_DECRPCM       K(KT_SPEC,26)
+#define K_INCRPCM       K(KT_SPEC,27)
+#define K_MUTEVOL       K(KT_SPEC,28)
+#define K_MUTELINE      K(KT_SPEC,29)
+#define K_MUTECD        K(KT_SPEC,30)
+#define K_MUTEPCM       K(KT_SPEC,31)
+
 
 #define K_ALLOCATED	K(KT_SPEC,126) /* dynamically allocated keymap */
 #define K_NOSUCHMAP	K(KT_SPEC,127) /* returned by KDGKBENT */
diff -urp linux/include/linux/linux_logo.h new_kernel_src/include/linux/linux_logo.h
--- linux/include/linux/linux_logo.h	2001-06-12 03:15:27.000000000 +0100
+++ new_kernel_src/include/linux/linux_logo.h	2001-10-17 02:00:38.000000000 +0100
@@ -18,1403 +18,1436 @@
  * but should contain %s to display the version
  */
 
-#ifndef __HAVE_ARCH_LINUX_LOGO
-#define LINUX_LOGO_COLORS	187
-#endif
-
-#ifdef INCLUDE_LINUX_LOGO_DATA
-
-#ifndef __HAVE_ARCH_LINUX_LOGO
+#if 0
+#if LINUX_LOGO_COLORS == 214
 
-unsigned char linux_logo_red[] __initdata = {
-    0x00, 0x06, 0x0a, 0x0e, 0x16, 0x1a, 0x1e, 0x22,
-    0x12, 0x00, 0x2a, 0x36, 0x42, 0x4e, 0x4a, 0x56,
-    0x26, 0x46, 0x2e, 0x32, 0x52, 0x3a, 0x02, 0x65,
-    0x5e, 0x3e, 0x74, 0x8a, 0xa2, 0x9a, 0x86, 0xc6,
-    0xc3, 0x65, 0xbb, 0xd2, 0xda, 0xd6, 0xe2, 0xf6,
-    0xfd, 0xae, 0x7b, 0xdd, 0xea, 0x6a, 0xaa, 0xe7,
-    0xbe, 0x5a, 0xee, 0x9e, 0x95, 0x80, 0x76, 0x79,
-    0x62, 0x36, 0x9a, 0xe2, 0xec, 0xe1, 0xb8, 0xd7,
-    0xaf, 0x25, 0xbc, 0xc0, 0xef, 0xea, 0xe8, 0xe8,
-    0xf5, 0xf1, 0xda, 0xd3, 0x79, 0xdb, 0xf4, 0xf6,
-    0xf6, 0xf6, 0xe2, 0x3d, 0xb4, 0xce, 0xe6, 0xee,
-    0xf6, 0x68, 0xd8, 0xec, 0xf5, 0xc6, 0xc8, 0x9c,
-    0x89, 0xd2, 0xee, 0xcb, 0xb9, 0xd2, 0x66, 0x5e,
-    0x8b, 0xbe, 0xa8, 0xd5, 0xca, 0xb6, 0xae, 0x9c,
-    0xc5, 0xbe, 0xbe, 0xca, 0x90, 0xb2, 0x9a, 0xa8,
-    0xb6, 0xf2, 0xce, 0xfa, 0xb2, 0x6e, 0xa6, 0x12,
-    0x4a, 0x8e, 0xf2, 0xf6, 0xf6, 0xee, 0xb5, 0xe4,
-    0xf1, 0x26, 0x9a, 0xea, 0xf6, 0xe0, 0xd2, 0x16,
-    0x9a, 0x2e, 0x70, 0xd6, 0x46, 0x7c, 0xb4, 0x62,
-    0xd6, 0xa3, 0x74, 0xa7, 0xa2, 0xca, 0xe0, 0xae,
-    0xbe, 0xce, 0xa3, 0x8e, 0x6d, 0x8e, 0x32, 0xaf,
-    0x50, 0x9e, 0x5b, 0x8a, 0x98, 0x82, 0x7a, 0x82,
-    0x56, 0x7c, 0x8a, 0x56, 0x5e, 0x86, 0x6a, 0x52,
-    0x59, 0x64, 0x5e,
+unsigned char linux_logo_red[]  = {
+  0x02, 0x9E, 0xE9, 0xC4, 0x50, 0xC9, 0xC4, 0xE9,
+  0x65, 0xE3, 0xC2, 0x25, 0xA4, 0xEC, 0x90, 0xA6,
+  0xC4, 0x6A, 0xD1, 0xF3, 0x12, 0xED, 0xA0, 0xC2,
+  0xB8, 0xD5, 0xDB, 0xD2, 0x3E, 0x16, 0xEB, 0x54,
+  0xA9, 0xCD, 0xF5, 0x0A, 0xBA, 0xB3, 0xDC, 0x74,
+  0xCE, 0xF6, 0xD3, 0xC5, 0xEA, 0xB8, 0xED, 0x5E,
+  0xE5, 0x26, 0xF4, 0xA9, 0x82, 0x94, 0xE6, 0x38,
+  0xF2, 0x0F, 0x7F, 0x49, 0xE5, 0xF4, 0xD3, 0xC3,
+  0xC2, 0x1E, 0xD5, 0xC6, 0xA4, 0xFA, 0x0A, 0xBA,
+  0xD4, 0xEB, 0xEA, 0xEC, 0xA8, 0xBC, 0xB4, 0xDC,
+  0x84, 0xE4, 0xCE, 0xEC, 0x92, 0xCD, 0xDC, 0x8B,
+  0xCC, 0x1E, 0xF6, 0xB2, 0x60, 0x2A, 0x96, 0x52,
+  0x0F, 0xBD, 0xFA, 0xCC, 0xB8, 0x7A, 0x4C, 0xD2,
+  0x06, 0xEF, 0x44, 0x64, 0xF4, 0xBA, 0xCE, 0xE6,
+  0x8A, 0x6F, 0x3C, 0x70, 0x7C, 0x9C, 0xBA, 0xDF,
+  0x2C, 0x4D, 0x3B, 0xCA, 0xDE, 0xCE, 0xEE, 0x46,
+  0x6A, 0xAC, 0x96, 0xE5, 0x96, 0x7A, 0xBA, 0xB6,
+  0xE2, 0x7E, 0xAA, 0xC5, 0x96, 0x9E, 0xC2, 0xAA,
+  0xDA, 0x35, 0xB6, 0x82, 0x88, 0xBE, 0xC2, 0x9E,
+  0xB4, 0xD5, 0xDA, 0x9C, 0xA0, 0xD0, 0xA8, 0xC7,
+  0x72, 0xF2, 0xDB, 0x76, 0xDC, 0xBE, 0xAA, 0xF4,
+  0x87, 0x2F, 0x53, 0x8E, 0x36, 0xCE, 0xE6, 0xCA,
+  0xCB, 0xE4, 0xD6, 0xAA, 0x42, 0x5D, 0xB4, 0x59,
+  0x1C, 0xC8, 0x96, 0x6C, 0xDA, 0xCE, 0xE6, 0xCB,
+  0x96, 0x16, 0xFA, 0xBE, 0xAE, 0xFE, 0x6E, 0xD6,
+  0xCE, 0xB6, 0xE5, 0xED, 0xDB, 0xDC, 0xF4, 0x72,
+  0x1F, 0xAE, 0xE6, 0xC2, 0xCA, 0xC4
 };
 
-unsigned char linux_logo_green[] __initdata = {
-    0x00, 0x06, 0x0a, 0x0e, 0x16, 0x1a, 0x1e, 0x22,
-    0x12, 0x00, 0x2a, 0x36, 0x42, 0x4e, 0x4a, 0x56,
-    0x26, 0x46, 0x2e, 0x32, 0x52, 0x3a, 0x02, 0x65,
-    0x5e, 0x3e, 0x74, 0x8a, 0xa2, 0x9a, 0x86, 0xc6,
-    0xc3, 0x62, 0xbb, 0xd2, 0xda, 0xd6, 0xe2, 0xf6,
-    0xfd, 0xae, 0x7b, 0xdd, 0xea, 0x6a, 0xaa, 0xe7,
-    0xbe, 0x5a, 0xee, 0x9e, 0x95, 0x80, 0x62, 0x5c,
-    0x4e, 0x26, 0x72, 0xaa, 0xba, 0xaf, 0x90, 0xae,
-    0x92, 0x1a, 0xa4, 0x85, 0xb6, 0xbe, 0xc3, 0xc8,
-    0xcf, 0xd0, 0xc2, 0xce, 0x57, 0xa2, 0xd6, 0xda,
-    0xda, 0xd7, 0xb8, 0x2a, 0x7b, 0x91, 0xae, 0xca,
-    0xda, 0x45, 0x9e, 0xb2, 0xd7, 0x9b, 0x90, 0x76,
-    0x5c, 0xa2, 0xbe, 0xa6, 0x85, 0x96, 0x4e, 0x46,
-    0x66, 0x92, 0x7a, 0x9a, 0x96, 0x9d, 0x9a, 0x6b,
-    0x8a, 0x8e, 0xb2, 0xca, 0x90, 0xa6, 0x79, 0x7c,
-    0xb6, 0xf2, 0xce, 0xfa, 0xb2, 0x6e, 0xa6, 0x0e,
-    0x36, 0x86, 0xba, 0xbe, 0xe6, 0xcc, 0x8e, 0xb8,
-    0xc4, 0x1e, 0x8e, 0xae, 0xba, 0xb2, 0xa6, 0x12,
-    0x7a, 0x20, 0x64, 0xaa, 0x2f, 0x70, 0x85, 0x46,
-    0xa6, 0x6e, 0x51, 0x72, 0x92, 0xa2, 0xa6, 0x87,
-    0x96, 0xa2, 0x85, 0x7a, 0x6a, 0x6e, 0x22, 0x76,
-    0x36, 0x76, 0x3c, 0x6e, 0x63, 0x53, 0x66, 0x62,
-    0x42, 0x50, 0x56, 0x42, 0x56, 0x56, 0x56, 0x3e,
-    0x51, 0x52, 0x56,
+unsigned char linux_logo_green[]  = {
+  0x02, 0x88, 0xC4, 0x85, 0x44, 0xA2, 0xA8, 0xE5,
+  0x65, 0xA6, 0xC2, 0x24, 0xA4, 0xB4, 0x62, 0x86,
+  0x94, 0x44, 0xD2, 0xB6, 0x12, 0xD4, 0x73, 0x96,
+  0x92, 0x95, 0xB2, 0xC2, 0x36, 0x0E, 0xBC, 0x54,
+  0x75, 0xA5, 0xF5, 0x0A, 0xB2, 0x83, 0xC2, 0x74,
+  0x9B, 0xBD, 0xA2, 0xCA, 0xDA, 0x8C, 0xCB, 0x42,
+  0xAC, 0x12, 0xDA, 0x7B, 0x54, 0x94, 0xD2, 0x24,
+  0xBE, 0x06, 0x65, 0x33, 0xBB, 0xBC, 0xAB, 0x8C,
+  0x92, 0x1E, 0x9B, 0xB6, 0x6E, 0xFB, 0x04, 0xA2,
+  0xC8, 0xBD, 0xAD, 0xEC, 0x92, 0xBC, 0x7B, 0x9D,
+  0x84, 0xC4, 0xC4, 0xB4, 0x6C, 0x93, 0xA3, 0x5E,
+  0x8D, 0x13, 0xD6, 0x82, 0x4C, 0x2A, 0x7A, 0x5A,
+  0x0D, 0x82, 0xBB, 0xCC, 0x8B, 0x6A, 0x3C, 0xBE,
+  0x06, 0xC4, 0x44, 0x45, 0xDB, 0x96, 0xB6, 0xDE,
+  0x8A, 0x4D, 0x3C, 0x5A, 0x7C, 0x9C, 0xAA, 0xCB,
+  0x1C, 0x4D, 0x2E, 0xB2, 0xBE, 0xAA, 0xDE, 0x3E,
+  0x6A, 0xAC, 0x82, 0xE5, 0x72, 0x62, 0x92, 0x9E,
+  0xCA, 0x4A, 0x8E, 0xBE, 0x86, 0x6B, 0xAA, 0x9A,
+  0xBE, 0x34, 0xAB, 0x76, 0x6E, 0x9A, 0x9E, 0x62,
+  0x76, 0xCE, 0xD3, 0x92, 0x7C, 0xB8, 0x7E, 0xC6,
+  0x5E, 0xE2, 0xC3, 0x54, 0xAA, 0x9E, 0x8A, 0xCA,
+  0x63, 0x2D, 0x3B, 0x8E, 0x1A, 0x9E, 0xC2, 0xA6,
+  0xCB, 0xDC, 0xD6, 0x8E, 0x26, 0x5C, 0xB4, 0x45,
+  0x1C, 0xB8, 0x6E, 0x4C, 0xBC, 0xAE, 0xD6, 0x92,
+  0x63, 0x16, 0xF6, 0x8C, 0x7A, 0xFE, 0x6E, 0xBA,
+  0xC6, 0x86, 0xAA, 0xAE, 0xDB, 0xA4, 0xD4, 0x56,
+  0x0E, 0x6E, 0xB6, 0xB2, 0xBE, 0xBE
 };
 
-unsigned char linux_logo_blue[] __initdata = {
-    0x00, 0x06, 0x0a, 0x0e, 0x16, 0x1a, 0x1e, 0x22,
-    0x12, 0x01, 0x2a, 0x36, 0x42, 0x4e, 0x4a, 0x56,
-    0x26, 0x46, 0x2e, 0x32, 0x52, 0x3a, 0x06, 0x65,
-    0x5e, 0x3e, 0x74, 0x8a, 0xa2, 0x9a, 0x86, 0xc6,
-    0xc3, 0x59, 0xbb, 0xd2, 0xda, 0xd6, 0xe2, 0xf6,
-    0xfd, 0xae, 0x7b, 0xdd, 0xea, 0x6a, 0xaa, 0xe7,
-    0xbe, 0x5a, 0xee, 0x9e, 0x95, 0x80, 0x2e, 0x08,
-    0x0a, 0x06, 0x0a, 0x0b, 0x0b, 0x0f, 0x0c, 0x0f,
-    0x3d, 0x09, 0x73, 0x09, 0x0d, 0x0a, 0x10, 0x1e,
-    0x2d, 0x13, 0x86, 0xba, 0x19, 0x0a, 0x36, 0x3c,
-    0x26, 0x14, 0x0d, 0x06, 0x07, 0x0a, 0x0b, 0x0f,
-    0x4a, 0x06, 0x0a, 0x0c, 0x2b, 0x0a, 0x0b, 0x0a,
-    0x06, 0x0a, 0x0a, 0x11, 0x0b, 0x0a, 0x0a, 0x1e,
-    0x0f, 0x0d, 0x0a, 0x0b, 0x22, 0x6a, 0x72, 0x0b,
-    0x0b, 0x22, 0x90, 0xca, 0x90, 0x92, 0x3c, 0x2c,
-    0xb6, 0xf2, 0xce, 0xfa, 0xb2, 0x6e, 0xa6, 0x06,
-    0x0e, 0x6a, 0x0e, 0x0e, 0xbe, 0x5b, 0x2c, 0x3e,
-    0x0e, 0x0a, 0x5a, 0x0d, 0x0e, 0x3e, 0x0a, 0x06,
-    0x2e, 0x06, 0x4e, 0x36, 0x06, 0x58, 0x24, 0x06,
-    0x3a, 0x08, 0x08, 0x07, 0x5e, 0x45, 0x0a, 0x32,
-    0x2e, 0x2a, 0x43, 0x48, 0x5f, 0x2e, 0x06, 0x06,
-    0x07, 0x24, 0x06, 0x32, 0x06, 0x06, 0x46, 0x2e,
-    0x22, 0x06, 0x06, 0x1e, 0x4c, 0x06, 0x3a, 0x22,
-    0x42, 0x34, 0x42,
+unsigned char linux_logo_blue[]  = {
+  0x04, 0x28, 0x10, 0x0B, 0x14, 0x14, 0x74, 0xC7,
+  0x64, 0x0E, 0xC3, 0x24, 0xA4, 0x0C, 0x10, 0x20,
+  0x0D, 0x04, 0xD1, 0x0D, 0x13, 0x22, 0x0A, 0x40,
+  0x14, 0x0C, 0x11, 0x94, 0x0C, 0x08, 0x0B, 0x56,
+  0x09, 0x47, 0xF4, 0x0B, 0x9C, 0x07, 0x54, 0x74,
+  0x0F, 0x0C, 0x0F, 0xC7, 0x6C, 0x14, 0x14, 0x11,
+  0x0B, 0x04, 0x12, 0x0C, 0x05, 0x94, 0x94, 0x0A,
+  0x34, 0x09, 0x14, 0x08, 0x2F, 0x15, 0x19, 0x11,
+  0x28, 0x0C, 0x0B, 0x94, 0x08, 0xFA, 0x08, 0x7C,
+  0xBC, 0x15, 0x0A, 0xEC, 0x64, 0xBB, 0x0A, 0x0C,
+  0x84, 0x2C, 0xA0, 0x15, 0x10, 0x0D, 0x0B, 0x0E,
+  0x0A, 0x07, 0x10, 0x3C, 0x24, 0x2C, 0x28, 0x5C,
+  0x0A, 0x0D, 0x0A, 0xC1, 0x22, 0x4C, 0x10, 0x94,
+  0x04, 0x0F, 0x45, 0x08, 0x31, 0x54, 0x3C, 0xBC,
+  0x8C, 0x09, 0x3C, 0x18, 0x7C, 0x9C, 0x7C, 0x91,
+  0x0C, 0x4D, 0x17, 0x74, 0x0C, 0x48, 0x9C, 0x3C,
+  0x6A, 0xAC, 0x5C, 0xE3, 0x29, 0x3C, 0x2C, 0x7C,
+  0x6C, 0x04, 0x14, 0xA9, 0x74, 0x07, 0x2C, 0x74,
+  0x4C, 0x34, 0x97, 0x5C, 0x38, 0x0C, 0x5C, 0x04,
+  0x0C, 0xBA, 0xBC, 0x78, 0x18, 0x88, 0x24, 0xC2,
+  0x3C, 0xB4, 0x87, 0x0C, 0x14, 0x4C, 0x3C, 0x10,
+  0x17, 0x2C, 0x0A, 0x8C, 0x04, 0x1C, 0x44, 0x2C,
+  0xCD, 0xD8, 0xD4, 0x34, 0x0C, 0x5B, 0xB4, 0x1E,
+  0x1D, 0xAC, 0x24, 0x18, 0x20, 0x5C, 0xB4, 0x1C,
+  0x09, 0x14, 0xFC, 0x0C, 0x10, 0xFC, 0x6C, 0x7C,
+  0xB4, 0x1C, 0x15, 0x17, 0xDB, 0x18, 0x21, 0x24,
+  0x04, 0x04, 0x44, 0x8C, 0x8C, 0xB7
 };
 
-unsigned char linux_logo[] __initdata = {
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x21, 0x21, 0x22, 0x22,
-    0x22, 0x21, 0x21, 0x21, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
-    0x26, 0x26, 0x25, 0x28, 0x23, 0x22, 0x21, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x29, 0x29, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x21, 0x23, 0x25, 0x2a, 0x2b, 0x2c, 0x2d, 0x2d,
-    0x2d, 0x2e, 0x2c, 0x2b, 0x2a, 0x25, 0x28, 0x22,
-    0x21, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x29, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22,
-    0x24, 0x2a, 0x2c, 0x2f, 0x2c, 0x30, 0x30, 0x24,
-    0x25, 0x27, 0x2b, 0x2c, 0x2f, 0x31, 0x32, 0x25,
-    0x23, 0x21, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x29, 0x29, 0x29, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22, 0x25,
-    0x33, 0x34, 0x35, 0x21, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x36, 0x36, 0x36, 0x21, 0x2b, 0x2f, 0x2c,
-    0x30, 0x28, 0x21, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x21, 0x24, 0x33,
-    0x2d, 0x27, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x21, 0x31,
-    0x2d, 0x32, 0x24, 0x21, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x29, 0x29, 0x29, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x21, 0x28, 0x2a, 0x34,
-    0x25, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x36, 0x36, 0x23, 0x32, 0x27, 0x21, 0x36,
-    0x2a, 0x2d, 0x2a, 0x28, 0x21, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x29, 0x20, 0x29, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x22, 0x26, 0x2c, 0x35,
-    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x36, 0x36, 0x25, 0x2f, 0x37, 0x32, 0x22,
-    0x36, 0x35, 0x31, 0x27, 0x22, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x29, 0x29, 0x29, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x23, 0x2a, 0x2f, 0x22,
-    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x36, 0x36, 0x26, 0x38, 0x38, 0x35, 0x25,
-    0x36, 0x21, 0x2d, 0x2b, 0x24, 0x21, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x21, 0x24, 0x39, 0x39, 0x36,
-    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x36, 0x36, 0x25, 0x2b, 0x30, 0x28, 0x22,
-    0x36, 0x36, 0x27, 0x34, 0x30, 0x23, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x29, 0x29, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x21, 0x26, 0x2d, 0x26, 0x36,
-    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x36, 0x36, 0x22, 0x22, 0x36, 0x36, 0x36,
-    0x36, 0x36, 0x36, 0x2d, 0x33, 0x28, 0x21, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x29, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x22, 0x30, 0x2f, 0x23, 0x36,
-    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x36, 0x36, 0x2b, 0x2c, 0x25, 0x21, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x29, 0x29, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x23, 0x2a, 0x34, 0x36, 0x36,
-    0x36, 0x21, 0x22, 0x36, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x36, 0x36, 0x21, 0x23, 0x22, 0x36, 0x36,
-    0x36, 0x36, 0x36, 0x28, 0x34, 0x27, 0x22, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x29, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x23, 0x32, 0x2f, 0x36, 0x36,
-    0x21, 0x21, 0x24, 0x27, 0x21, 0x36, 0x36, 0x36,
-    0x36, 0x36, 0x28, 0x27, 0x22, 0x33, 0x24, 0x36,
-    0x36, 0x36, 0x36, 0x22, 0x2f, 0x2a, 0x23, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x29, 0x29, 0x29, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x23, 0x32, 0x2f, 0x36, 0x36,
-    0x30, 0x3a, 0x38, 0x24, 0x24, 0x36, 0x36, 0x36,
-    0x23, 0x2f, 0x3b, 0x3c, 0x3d, 0x30, 0x25, 0x21,
-    0x36, 0x36, 0x36, 0x36, 0x2f, 0x32, 0x23, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x23, 0x32, 0x2f, 0x36, 0x23,
-    0x3e, 0x3f, 0x40, 0x3a, 0x22, 0x36, 0x36, 0x21,
-    0x41, 0x42, 0x43, 0x44, 0x45, 0x3e, 0x23, 0x21,
-    0x36, 0x36, 0x36, 0x36, 0x2f, 0x33, 0x28, 0x21,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x29, 0x20, 0x29, 0x29, 0x29, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x23, 0x32, 0x2f, 0x36, 0x2b,
-    0x44, 0x40, 0x46, 0x47, 0x35, 0x36, 0x36, 0x26,
-    0x43, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x2e, 0x36,
-    0x36, 0x36, 0x36, 0x36, 0x31, 0x35, 0x24, 0x21,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x23, 0x32, 0x34, 0x36, 0x4d,
-    0x4e, 0x25, 0x2f, 0x46, 0x4a, 0x22, 0x23, 0x32,
-    0x4f, 0x50, 0x21, 0x31, 0x51, 0x52, 0x53, 0x36,
-    0x36, 0x36, 0x36, 0x36, 0x31, 0x35, 0x24, 0x21,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x29, 0x20, 0x29, 0x29, 0x29, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x23, 0x2a, 0x2f, 0x21, 0x3a,
-    0x4d, 0x21, 0x31, 0x54, 0x55, 0x28, 0x30, 0x2b,
-    0x4b, 0x4d, 0x36, 0x23, 0x32, 0x50, 0x3f, 0x36,
-    0x36, 0x36, 0x36, 0x36, 0x2e, 0x39, 0x24, 0x21,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x29, 0x20, 0x29, 0x20, 0x29, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x23, 0x2a, 0x38, 0x23, 0x37,
-    0x55, 0x36, 0x28, 0x3a, 0x56, 0x57, 0x57, 0x58,
-    0x3c, 0x4d, 0x36, 0x36, 0x36, 0x40, 0x40, 0x21,
-    0x36, 0x36, 0x36, 0x36, 0x2e, 0x39, 0x24, 0x21,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x29, 0x29, 0x29, 0x20, 0x29, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x22, 0x30, 0x51, 0x23, 0x35,
-    0x43, 0x25, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e,
-    0x5f, 0x60, 0x61, 0x36, 0x31, 0x47, 0x3b, 0x36,
-    0x36, 0x36, 0x36, 0x36, 0x31, 0x2c, 0x25, 0x21,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x22, 0x30, 0x2f, 0x23, 0x22,
-    0x40, 0x62, 0x63, 0x5d, 0x64, 0x65, 0x66, 0x67,
-    0x68, 0x69, 0x66, 0x5e, 0x6a, 0x6b, 0x2a, 0x36,
-    0x36, 0x36, 0x36, 0x36, 0x33, 0x2e, 0x26, 0x21,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x22, 0x27, 0x2f, 0x23, 0x36,
-    0x6c, 0x63, 0x6d, 0x64, 0x5c, 0x66, 0x69, 0x6e,
-    0x6f, 0x70, 0x71, 0x69, 0x69, 0x72, 0x6c, 0x36,
-    0x36, 0x36, 0x36, 0x36, 0x33, 0x34, 0x27, 0x22,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x22, 0x27, 0x34, 0x26, 0x73,
-    0x74, 0x75, 0x76, 0x64, 0x65, 0x77, 0x69, 0x78,
-    0x70, 0x71, 0x71, 0x71, 0x72, 0x5f, 0x5e, 0x21,
-    0x36, 0x36, 0x36, 0x36, 0x25, 0x38, 0x2a, 0x23,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x22, 0x26, 0x2d, 0x33, 0x79,
-    0x63, 0x7a, 0x7b, 0x5c, 0x66, 0x69, 0x6e, 0x7c,
-    0x71, 0x71, 0x69, 0x7d, 0x7e, 0x7a, 0x7f, 0x36,
-    0x36, 0x36, 0x36, 0x36, 0x21, 0x51, 0x2b, 0x28,
-    0x21, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x22, 0x26, 0x2d, 0x32, 0x24,
-    0x80, 0x81, 0x64, 0x82, 0x77, 0x69, 0x71, 0x71,
-    0x69, 0x83, 0x84, 0x85, 0x7a, 0x85, 0x86, 0x36,
-    0x21, 0x2b, 0x23, 0x36, 0x36, 0x39, 0x2e, 0x26,
-    0x22, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x22, 0x27, 0x2d, 0x33, 0x21,
-    0x87, 0x88, 0x89, 0x72, 0x67, 0x66, 0x5f, 0x89,
-    0x8a, 0x63, 0x85, 0x8b, 0x8c, 0x8d, 0x41, 0x36,
-    0x36, 0x2d, 0x3a, 0x35, 0x36, 0x24, 0x51, 0x32,
-    0x28, 0x21, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x22, 0x30, 0x2f, 0x33, 0x21,
-    0x55, 0x8e, 0x8f, 0x8a, 0x7d, 0x5e, 0x90, 0x7e,
-    0x75, 0x75, 0x90, 0x62, 0x40, 0x3f, 0x49, 0x23,
-    0x36, 0x24, 0x3a, 0x3a, 0x24, 0x36, 0x2e, 0x31,
-    0x26, 0x22, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x21, 0x28, 0x33, 0x37, 0x25, 0x22,
-    0x3b, 0x50, 0x8e, 0x8f, 0x90, 0x7e, 0x90, 0x63,
-    0x74, 0x91, 0x92, 0x42, 0x93, 0x4b, 0x45, 0x2c,
-    0x36, 0x36, 0x33, 0x39, 0x21, 0x36, 0x22, 0x51,
-    0x33, 0x28, 0x21, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x22, 0x27, 0x2e, 0x2e, 0x36, 0x21,
-    0x94, 0x3f, 0x50, 0x95, 0x96, 0x8f, 0x8f, 0x97,
-    0x8e, 0x42, 0x50, 0x43, 0x47, 0x48, 0x48, 0x98,
-    0x21, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x39,
-    0x2e, 0x27, 0x23, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x22, 0x24, 0x2b, 0x38, 0x28, 0x36, 0x32,
-    0x4c, 0x4b, 0x50, 0x50, 0x50, 0x42, 0x42, 0x50,
-    0x50, 0x40, 0x45, 0x99, 0x48, 0x48, 0x48, 0x48,
-    0x34, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x23,
-    0x2f, 0x2b, 0x24, 0x21, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x21, 0x28, 0x32, 0x51, 0x32, 0x28, 0x21, 0x98,
-    0x48, 0x47, 0x9a, 0x50, 0x50, 0x50, 0x50, 0x50,
-    0x9a, 0x4f, 0x9b, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x93, 0x23, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
-    0x2a, 0x2f, 0x2a, 0x28, 0x21, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x21,
-    0x23, 0x30, 0x2e, 0x2c, 0x36, 0x21, 0x51, 0x9b,
-    0x48, 0x48, 0x52, 0x3f, 0x50, 0x50, 0x40, 0x4b,
-    0x47, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x34, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x2d, 0x31, 0x27, 0x23, 0x21, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x23,
-    0x27, 0x2c, 0x2d, 0x21, 0x36, 0x28, 0x44, 0x48,
-    0x48, 0x48, 0x48, 0x47, 0x46, 0x4f, 0x47, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x9c, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x28, 0x51, 0x39, 0x26, 0x22, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22, 0x25,
-    0x35, 0x51, 0x28, 0x36, 0x36, 0x9d, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x9b, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x4f, 0x28, 0x36, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x36, 0x28, 0x38, 0x2b, 0x25, 0x22, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x21, 0x24, 0x33,
-    0x51, 0x25, 0x36, 0x36, 0x23, 0x40, 0x9b, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x9b, 0x99, 0x2b, 0x36, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x36, 0x36, 0x30, 0x2f, 0x33, 0x24, 0x21,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x21, 0x23, 0x30, 0x34,
-    0x27, 0x36, 0x36, 0x36, 0x2a, 0x40, 0x47, 0x48,
-    0x48, 0x48, 0x48, 0x9b, 0x99, 0x99, 0x9b, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x9b, 0x47, 0x52,
-    0x46, 0x4f, 0x37, 0x21, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x36, 0x36, 0x36, 0x30, 0x34, 0x2a, 0x23,
-    0x21, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x22, 0x25, 0x39, 0x2c,
-    0x36, 0x36, 0x36, 0x21, 0x31, 0x4e, 0x9a, 0x4c,
-    0x47, 0x9b, 0x9b, 0x52, 0x46, 0x4f, 0x52, 0x9b,
-    0x9b, 0x9b, 0x47, 0x4f, 0x45, 0x9a, 0x93, 0x93,
-    0x3f, 0x93, 0x98, 0x28, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x36, 0x36, 0x36, 0x36, 0x39, 0x2c, 0x26,
-    0x22, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x23, 0x2a, 0x34, 0x28,
-    0x36, 0x36, 0x36, 0x22, 0x38, 0x98, 0x44, 0x99,
-    0x9b, 0x48, 0x48, 0x9b, 0x4c, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x47, 0x52, 0x46, 0x43, 0x93,
-    0x40, 0x40, 0x43, 0x53, 0x21, 0x23, 0x33, 0x23,
-    0x36, 0x36, 0x36, 0x36, 0x36, 0x21, 0x2f, 0x32,
-    0x28, 0x21, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x21, 0x24, 0x2b, 0x31, 0x36,
-    0x36, 0x22, 0x36, 0x24, 0x9e, 0x4f, 0x9b, 0x48,
-    0x48, 0x48, 0x48, 0x9b, 0x99, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x47,
-    0x4f, 0x9a, 0x3f, 0x46, 0x38, 0x36, 0x21, 0x30,
-    0x26, 0x36, 0x36, 0x36, 0x36, 0x36, 0x39, 0x2c,
-    0x25, 0x22, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x22, 0x26, 0x2e, 0x33, 0x36,
-    0x25, 0x25, 0x36, 0x4d, 0x52, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x47, 0x44, 0x93, 0x43, 0x23, 0x36, 0x36,
-    0x26, 0x24, 0x36, 0x36, 0x36, 0x36, 0x28, 0x2f,
-    0x2a, 0x23, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x23, 0x2a, 0x51, 0x24, 0x36,
-    0x2a, 0x36, 0x28, 0x44, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x9b, 0x4b, 0x44, 0x37, 0x36, 0x23,
-    0x28, 0x30, 0x22, 0x36, 0x36, 0x36, 0x36, 0x2d,
-    0x35, 0x24, 0x21, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x21, 0x28, 0x2b, 0x34, 0x36, 0x25,
-    0x24, 0x36, 0x4a, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x9b, 0x52, 0x3f, 0x21, 0x30,
-    0x35, 0x25, 0x30, 0x36, 0x36, 0x36, 0x36, 0x32,
-    0x2d, 0x26, 0x22, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x22, 0x26, 0x2e, 0x35, 0x36, 0x2a,
-    0x36, 0x24, 0x4f, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x9b, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x47, 0x32, 0x30,
-    0x2a, 0x23, 0x30, 0x23, 0x36, 0x36, 0x36, 0x21,
-    0x2f, 0x32, 0x23, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x21, 0x23, 0x2a, 0x51, 0x28, 0x28, 0x25,
-    0x36, 0x3a, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x9b, 0x52, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x38, 0x21,
-    0x36, 0x36, 0x22, 0x27, 0x36, 0x36, 0x36, 0x36,
-    0x2e, 0x35, 0x24, 0x21, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x22, 0x25, 0x2c, 0x34, 0x36, 0x30, 0x21,
-    0x23, 0x43, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x47, 0x99, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x94, 0x36,
-    0x36, 0x36, 0x36, 0x32, 0x36, 0x36, 0x36, 0x36,
-    0x2a, 0x2e, 0x26, 0x22, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x21, 0x23, 0x2a, 0x51, 0x25, 0x21, 0x2a, 0x36,
-    0x2e, 0x9b, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x99, 0x99, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x98, 0x36,
-    0x36, 0x36, 0x36, 0x32, 0x36, 0x36, 0x36, 0x36,
-    0x22, 0x2f, 0x30, 0x22, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x22, 0x25, 0x2c, 0x34, 0x36, 0x24, 0x28, 0x36,
-    0x54, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x4c, 0x99, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x9a, 0x36,
-    0x36, 0x36, 0x36, 0x30, 0x36, 0x36, 0x36, 0x36,
-    0x21, 0x2f, 0x32, 0x23, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x21,
-    0x28, 0x32, 0x2f, 0x28, 0x36, 0x27, 0x22, 0x21,
-    0x43, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x4c, 0x99, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x4b, 0x21,
-    0x36, 0x36, 0x21, 0x26, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x34, 0x2b, 0x28, 0x21, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22,
-    0x25, 0x2c, 0x39, 0x36, 0x36, 0x30, 0x22, 0x25,
-    0x52, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x4f, 0x52, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x4f, 0x21,
-    0x36, 0x36, 0x22, 0x26, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x2c, 0x35, 0x24, 0x21, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22,
-    0x30, 0x2d, 0x21, 0x36, 0x36, 0x32, 0x23, 0x2a,
-    0x47, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x4f, 0x99, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x4c, 0x22,
-    0x36, 0x36, 0x24, 0x23, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x2c, 0x39, 0x24, 0x21, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x21, 0x28,
-    0x33, 0x2e, 0x36, 0x36, 0x23, 0x31, 0x27, 0x39,
-    0x9b, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x4f, 0x47, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x4c, 0x23,
-    0x36, 0x36, 0x26, 0x36, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x2c, 0x39, 0x24, 0x21, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x21, 0x28,
-    0x2b, 0x39, 0x36, 0x36, 0x36, 0x26, 0x32, 0x31,
-    0x9b, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x4f, 0x47, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x46, 0x22,
-    0x36, 0x21, 0x26, 0x36, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x2c, 0x35, 0x24, 0x21, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x21, 0x24,
-    0x35, 0x39, 0x36, 0x36, 0x36, 0x36, 0x26, 0x2d,
-    0x9b, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x4f, 0x47, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x9a, 0x36,
-    0x24, 0x27, 0x9f, 0x24, 0x25, 0x28, 0x21, 0x36,
-    0x36, 0x34, 0x2b, 0x28, 0x21, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x21, 0x25,
-    0x39, 0x4d, 0xa0, 0x84, 0x81, 0x57, 0x21, 0x39,
-    0x52, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x4f, 0x47, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x53, 0x28,
-    0x23, 0x36, 0x36, 0x36, 0x21, 0x28, 0x2c, 0x30,
-    0x21, 0x38, 0x33, 0x28, 0x21, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x21, 0x22, 0x22, 0x28, 0x30,
-    0x2d, 0xa1, 0x7a, 0xa2, 0xa3, 0xa3, 0x7f, 0x22,
-    0x51, 0x52, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x4f, 0x9b, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0xa4, 0xa5, 0xa5, 0xa6, 0x61,
-    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x30, 0x32,
-    0x25, 0x4d, 0x2b, 0x28, 0x21, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x21, 0x23, 0x24, 0x26, 0x30, 0x33, 0x31,
-    0x4d, 0x91, 0x5b, 0xa2, 0xa3, 0xa3, 0xa3, 0x5a,
-    0x21, 0x2e, 0x46, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x4f, 0x9b, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0xa7, 0xa8, 0x69, 0x66, 0xa9,
-    0x36, 0x36, 0x36, 0x36, 0x36, 0x21, 0x26, 0x25,
-    0x83, 0xaa, 0x2c, 0x25, 0x21, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x21, 0x28, 0x30, 0x35, 0x2d, 0x2f, 0x37, 0x4a,
-    0x60, 0x85, 0xab, 0xac, 0xa3, 0xa3, 0xa3, 0x82,
-    0x86, 0x36, 0x32, 0x3f, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x4c, 0x99, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0xad, 0xa2, 0xa8, 0xae, 0xaf,
-    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x21, 0x57,
-    0x77, 0x66, 0x34, 0x27, 0x22, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x23, 0x30, 0x31, 0xb0, 0x91, 0x7e, 0x90, 0x90,
-    0x8b, 0x5b, 0xa2, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
-    0x5d, 0xb1, 0x36, 0x24, 0x53, 0x9b, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x9b, 0x99, 0xad, 0x64, 0x5c, 0x8b, 0xb1,
-    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x73, 0x5d,
-    0x82, 0x5c, 0xb2, 0x2a, 0x23, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x21,
-    0x24, 0x2b, 0xb0, 0x8b, 0x5b, 0x76, 0x5b, 0x5b,
-    0x7b, 0xa2, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
-    0xa8, 0x5e, 0x22, 0x36, 0x21, 0x3a, 0x99, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x4f, 0x3f, 0xb3, 0x7b, 0x7b, 0x85, 0x80,
-    0x9f, 0x36, 0x36, 0x36, 0x21, 0xb4, 0x7e, 0x7b,
-    0x64, 0x64, 0xb5, 0x35, 0x24, 0x21, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22,
-    0x26, 0x31, 0xb6, 0x5b, 0x64, 0xa2, 0xa2, 0xac,
-    0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
-    0xa3, 0x66, 0xb7, 0x36, 0x36, 0x36, 0x2c, 0x4b,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x9a, 0x3f, 0xb8, 0x76, 0x76, 0x7a, 0x63,
-    0xb9, 0xba, 0x86, 0xba, 0xbb, 0x90, 0x5b, 0x64,
-    0xa2, 0xa2, 0xbc, 0x2d, 0x27, 0x23, 0x21, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x21,
-    0x26, 0x2d, 0x91, 0x5b, 0x64, 0xa3, 0xa3, 0xa3,
-    0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
-    0xa3, 0xa8, 0x83, 0xaf, 0x36, 0x36, 0x36, 0x30,
-    0x44, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x9b, 0x9a, 0x3f, 0xbd, 0x5b, 0x7b, 0xbe, 0x85,
-    0x7e, 0x90, 0x63, 0x90, 0x85, 0x5b, 0xa2, 0xa3,
-    0xa3, 0xac, 0x5d, 0xb5, 0x39, 0x26, 0x23, 0x21,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22,
-    0x26, 0x2d, 0xbf, 0xbe, 0x64, 0xa3, 0xa3, 0xa3,
-    0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
-    0xa3, 0xa3, 0xa8, 0x88, 0x36, 0x36, 0x36, 0x36,
-    0x2d, 0x9b, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x9b, 0x45, 0x3f, 0xc0, 0x6d, 0x7b, 0xab, 0xbe,
-    0x7a, 0x8b, 0x8b, 0x7a, 0x5b, 0x64, 0xa3, 0xa3,
-    0xa3, 0xa3, 0xa2, 0xc1, 0x37, 0x35, 0x26, 0x23,
-    0x21, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22,
-    0x26, 0x2e, 0xbf, 0x7a, 0x7b, 0xa3, 0xa3, 0xa3,
-    0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
-    0xa3, 0xa3, 0xa8, 0x72, 0x73, 0x36, 0x36, 0x36,
-    0x24, 0x52, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x46, 0x42, 0xb6, 0x7a, 0x7b, 0x64, 0x7b,
-    0x76, 0x5b, 0x5b, 0x76, 0x7b, 0xa2, 0xa3, 0xa3,
-    0xa3, 0xa3, 0xac, 0x64, 0xc1, 0x4d, 0x2c, 0x27,
-    0x23, 0x21, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x21,
-    0x25, 0x31, 0xc2, 0x8b, 0x7b, 0xa3, 0xa3, 0xa3,
-    0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
-    0xa3, 0xa3, 0xa3, 0xa8, 0x89, 0x9f, 0x36, 0x36,
-    0x32, 0x47, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x4b, 0x2f, 0x8f, 0x7a, 0x7b, 0xa2, 0xac,
-    0xa2, 0x64, 0x64, 0xa2, 0xa2, 0xac, 0xa3, 0xa3,
-    0xa3, 0xa3, 0xa3, 0xa3, 0xa2, 0x5d, 0xc3, 0x2c,
-    0x26, 0x22, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x21,
-    0x25, 0x31, 0xc2, 0x85, 0x7b, 0xa3, 0xa3, 0xa3,
-    0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
-    0xa3, 0xa3, 0xa3, 0xa3, 0x66, 0x57, 0x27, 0x4d,
-    0x4b, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x99, 0x34, 0x9f, 0xb9, 0x7a, 0x7b, 0xa2, 0xa3,
-    0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
-    0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa2, 0xc2,
-    0x32, 0x28, 0x21, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22,
-    0x26, 0x2d, 0xc2, 0x85, 0x7b, 0xac, 0xa3, 0xa3,
-    0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
-    0xa3, 0xa3, 0xa3, 0xa3, 0xa8, 0x5f, 0x92, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x44,
-    0x35, 0x36, 0xaf, 0xbb, 0x7a, 0x7b, 0xac, 0xa3,
-    0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
-    0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xac, 0xa2, 0xc0,
-    0x2b, 0x24, 0x21, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x23,
-    0x30, 0x2f, 0xb6, 0x8b, 0x7b, 0xac, 0xa3, 0xa3,
-    0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
-    0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0x66, 0x89, 0x45,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x48, 0x9b, 0x4e, 0x25,
-    0x36, 0x36, 0x61, 0xb9, 0x6d, 0x64, 0xac, 0xa3,
-    0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
-    0xa3, 0xa3, 0xa3, 0xa3, 0xac, 0x7b, 0xbe, 0xc3,
-    0x32, 0x28, 0x21, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x21, 0x28,
-    0x33, 0xc4, 0x63, 0xbe, 0xa2, 0xa3, 0xa3, 0xa3,
-    0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
-    0xa3, 0xa3, 0xa3, 0xa3, 0xa2, 0x72, 0x81, 0xc5,
-    0x46, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
-    0x48, 0x48, 0x48, 0x48, 0x3f, 0x2c, 0x36, 0x36,
-    0x36, 0x36, 0xc6, 0x8f, 0x6d, 0x64, 0xac, 0xa3,
-    0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
-    0xa3, 0xa3, 0xa3, 0xa2, 0xab, 0x8b, 0xb0, 0x2c,
-    0x26, 0x22, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x21, 0x24,
-    0x35, 0x96, 0x75, 0xab, 0xa2, 0xac, 0xa3, 0xa3,
-    0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
-    0xa3, 0xa3, 0xa3, 0xa3, 0xac, 0x7b, 0x81, 0xb9,
-    0x73, 0x3b, 0x44, 0x9b, 0x48, 0x48, 0x48, 0x9b,
-    0x99, 0x43, 0x94, 0x2c, 0x21, 0x36, 0x36, 0x36,
-    0x36, 0x36, 0x73, 0xb9, 0x7a, 0x7b, 0xa3, 0xa3,
-    0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
-    0xa3, 0x64, 0x76, 0x7a, 0x91, 0xb5, 0x31, 0x30,
-    0x28, 0x21, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x21, 0x24,
-    0x39, 0x97, 0x75, 0xbe, 0x7b, 0x64, 0xa2, 0xa2,
-    0xac, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
-    0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0x7b, 0x7a, 0xc7,
-    0xc8, 0x36, 0x21, 0x26, 0x2b, 0x39, 0x33, 0x30,
-    0x23, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x21, 0xc8, 0xbb, 0x8b, 0x7b, 0xa3, 0xa3,
-    0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa2, 0x64, 0x64,
-    0x76, 0x85, 0xbf, 0xb5, 0x34, 0x2b, 0x27, 0x28,
-    0x21, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x21, 0x28,
-    0x33, 0xc9, 0x63, 0x7e, 0x7a, 0x6d, 0xbe, 0x5b,
-    0x76, 0x7b, 0x64, 0x64, 0xa2, 0xac, 0xa3, 0xa3,
-    0xa3, 0xa3, 0xa3, 0xa3, 0xac, 0x76, 0x85, 0xb9,
-    0x79, 0x22, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x21, 0xca, 0xbb, 0x75, 0x76, 0xa2, 0xa3,
-    0xa3, 0xa3, 0xac, 0xa2, 0x64, 0x76, 0xbe, 0x8b,
-    0xb6, 0xb5, 0x2f, 0x35, 0x30, 0x24, 0x22, 0x21,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x23,
-    0x27, 0x31, 0xcb, 0xc9, 0xbb, 0x74, 0x63, 0x90,
-    0x7e, 0x75, 0x8b, 0x6d, 0xbe, 0x76, 0x64, 0xa2,
-    0xac, 0xac, 0xac, 0xac, 0x64, 0x7a, 0x84, 0xcc,
-    0x79, 0x9f, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
-    0x36, 0x21, 0xc8, 0xcc, 0x63, 0x6d, 0x7b, 0x64,
-    0xac, 0xa2, 0x64, 0x7b, 0xbe, 0x75, 0x63, 0x96,
-    0x38, 0x39, 0x2a, 0x24, 0x23, 0x21, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x21,
-    0x28, 0x27, 0x35, 0x2d, 0x41, 0xb5, 0xc5, 0x8f,
-    0xb9, 0xbb, 0xc7, 0x74, 0x84, 0x90, 0x85, 0x6d,
-    0x5b, 0x7b, 0x7b, 0xab, 0x6d, 0x90, 0xb9, 0xcd,
-    0xca, 0x22, 0x36, 0x36, 0x28, 0x30, 0x30, 0x30,
-    0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x25, 0x36,
-    0x36, 0x21, 0xb4, 0x80, 0xc7, 0x7e, 0x6d, 0x76,
-    0xab, 0x76, 0x6d, 0x85, 0x63, 0xb9, 0xb5, 0x34,
-    0x33, 0x26, 0x23, 0x21, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x21, 0x23, 0x24, 0x27, 0x2a, 0x35, 0x2e, 0x2f,
-    0x41, 0xce, 0xcf, 0x6c, 0x80, 0xcc, 0xb9, 0x74,
-    0x84, 0x90, 0x75, 0x7e, 0x74, 0x8f, 0xcd, 0x79,
-    0xc6, 0x2b, 0x9d, 0x41, 0x2f, 0x34, 0x2d, 0x2d,
-    0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x34, 0x2f, 0x38,
-    0x4d, 0x37, 0xd0, 0xd1, 0x8f, 0x74, 0x63, 0x7e,
-    0x75, 0x7e, 0x63, 0xc7, 0x88, 0xc4, 0x31, 0x2a,
-    0x24, 0x22, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x21, 0x22, 0x23, 0x24, 0x26, 0x30,
-    0x33, 0x39, 0x2e, 0x51, 0x41, 0xb2, 0x6c, 0xd1,
-    0x80, 0xcc, 0xcc, 0xcc, 0xd2, 0xd1, 0xb7, 0xd3,
-    0x41, 0x34, 0x35, 0x32, 0x30, 0x27, 0x27, 0x27,
-    0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x30, 0x2a,
-    0x2b, 0x34, 0xd4, 0xca, 0xd5, 0x8f, 0xbb, 0xc7,
-    0xc7, 0xbb, 0xcc, 0x6c, 0x41, 0x39, 0x27, 0x28,
-    0x21, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x21, 0x21, 0x22,
-    0x28, 0x24, 0x26, 0x2a, 0x33, 0x2c, 0x2f, 0x41,
-    0xd6, 0xb7, 0x79, 0x79, 0x79, 0xca, 0xd7, 0x51,
-    0x39, 0x30, 0x24, 0x23, 0x22, 0x22, 0x22, 0x22,
-    0x22, 0x22, 0x21, 0x22, 0x22, 0x22, 0x22, 0x23,
-    0x24, 0x2a, 0x31, 0xd8, 0xc8, 0x79, 0xd1, 0x80,
-    0xd5, 0xba, 0xd9, 0x2f, 0x35, 0x26, 0x23, 0x21,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x21, 0x22, 0x23, 0x28, 0x25, 0x30, 0x2b,
-    0x31, 0x2f, 0xd4, 0xd8, 0xd8, 0x2f, 0x2e, 0x33,
-    0x26, 0x23, 0x21, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x21, 0x28, 0x27, 0x35, 0x34, 0xd8, 0xd8, 0xd8,
-    0xda, 0xd4, 0x2e, 0x33, 0x25, 0x23, 0x21, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x21, 0x21, 0x23, 0x28,
-    0x26, 0x30, 0x32, 0x2b, 0x33, 0x2a, 0x26, 0x28,
-    0x22, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x21, 0x23, 0x25, 0x30, 0x33, 0x35, 0x35,
-    0x2b, 0x2a, 0x26, 0x28, 0x22, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x21,
-    0x21, 0x22, 0x23, 0x28, 0x28, 0x23, 0x22, 0x21,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x21, 0x23, 0x28, 0x24, 0x24,
-    0x28, 0x23, 0x22, 0x21, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+unsigned char linux_logo[]  = {
+  0xBF, 0x95, 0x90, 0xCB, 0x95, 0xA1, 0x2C, 0x2C,
+  0x95, 0x55, 0xCB, 0x90, 0xCB, 0x95, 0x2C, 0x95,
+  0xCB, 0x47, 0x94, 0x95, 0xA1, 0xD6, 0xD6, 0x2C,
+  0x90, 0x47, 0x70, 0x2C, 0x6D, 0x2A, 0x6D, 0xD6,
+  0xA1, 0x2C, 0x55, 0x95, 0x2C, 0x2C, 0x55, 0x55,
+  0x95, 0xA1, 0xA1, 0xA1, 0x6D, 0xBF, 0x2A, 0x2A,
+  0xBF, 0x83, 0xBF, 0x95, 0x90, 0xCB, 0x95, 0xA1,
+  0x2C, 0x2C, 0x95, 0x55, 0xCB, 0x90, 0xCB, 0x95,
+  0x2C, 0x95, 0xCB, 0x47, 0x94, 0x95, 0xA1, 0xD6,
+  0xD6, 0x2C, 0x90, 0x47, 0x70, 0x2C, 0x6D, 0x2A,
+  0x95, 0x47, 0x47, 0x90, 0x2C, 0x2C, 0x2C, 0x95,
+  0x55, 0x55, 0xCB, 0x90, 0xCB, 0x55, 0x55, 0xCB,
+  0x47, 0xE6, 0x70, 0x95, 0xD6, 0xD6, 0xA1, 0x2C,
+  0x55, 0x55, 0x95, 0xD6, 0x6D, 0xD6, 0xA1, 0x2C,
+  0x2C, 0x95, 0x55, 0x95, 0x95, 0x95, 0x2C, 0x2C,
+  0xA1, 0xA1, 0x2C, 0x2C, 0xA1, 0xD6, 0xD6, 0xD6,
+  0xD6, 0xD6, 0x95, 0x47, 0x47, 0x90, 0x2C, 0x2C,
+  0x2C, 0x95, 0x55, 0x55, 0xCB, 0x90, 0xCB, 0x55,
+  0x55, 0xCB, 0x47, 0xE6, 0x70, 0x95, 0xD6, 0xD6,
+  0xA1, 0x2C, 0x55, 0x55, 0x95, 0xD6, 0x6D, 0xD6,
+  0x90, 0x47, 0x47, 0x70, 0x2C, 0xA1, 0x2C, 0x95,
+  0x55, 0x55, 0x90, 0xCB, 0x55, 0x55, 0x55, 0x70,
+  0x94, 0x70, 0x95, 0xA1, 0xD6, 0xD6, 0xA1, 0x2C,
+  0x95, 0x95, 0x2C, 0xA1, 0xD6, 0xA1, 0x2C, 0x2C,
+  0x95, 0x55, 0xCB, 0x95, 0xD6, 0xA1, 0x2C, 0x95,
+  0xA1, 0xD6, 0xD6, 0xA1, 0xA1, 0xD6, 0xA1, 0xA1,
+  0xA1, 0x2C, 0x90, 0x47, 0x47, 0x70, 0x2C, 0xA1,
+  0x2C, 0x95, 0x55, 0x55, 0x90, 0xCB, 0x55, 0x55,
+  0x55, 0x70, 0x94, 0x70, 0x95, 0xA1, 0xD6, 0xD6,
+  0xA1, 0x2C, 0x95, 0x95, 0x2C, 0xD6, 0xD6, 0xA1,
+  0x94, 0xA0, 0x47, 0x55, 0x2C, 0xD6, 0xA1, 0x95,
+  0x55, 0x55, 0xCB, 0xCB, 0x55, 0x55, 0xCB, 0xCB,
+  0x55, 0x95, 0x2C, 0xA1, 0xD6, 0xD6, 0xA1, 0x2C,
+  0x95, 0x95, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x95,
+  0x55, 0x55, 0x2C, 0x3F, 0x80, 0x20, 0x88, 0x88,
+  0x88, 0x20, 0x88, 0xB1, 0x2C, 0xA1, 0x2C, 0x2C,
+  0x95, 0xCB, 0x94, 0xA0, 0x47, 0x55, 0x2C, 0xD6,
+  0xA1, 0x95, 0x55, 0x55, 0xCB, 0xCB, 0x55, 0x55,
+  0xCB, 0xCB, 0x55, 0x95, 0x2C, 0xA1, 0xD6, 0xD6,
+  0xA1, 0x2C, 0x95, 0x95, 0x2C, 0x2C, 0x2C, 0x2C,
+  0x94, 0x94, 0x70, 0x2C, 0xA1, 0xD6, 0xA1, 0x2C,
+  0x55, 0x55, 0xCB, 0x55, 0x55, 0x55, 0x55, 0x55,
+  0x95, 0x2C, 0xD6, 0xD6, 0xD6, 0xA1, 0x2C, 0x95,
+  0x55, 0x55, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95,
+  0x2C, 0x94, 0x80, 0x20, 0x20, 0x20, 0x20, 0x20,
+  0x20, 0x20, 0x20, 0x20, 0x88, 0x92, 0xA1, 0x95,
+  0x55, 0x90, 0x94, 0x94, 0x70, 0x2C, 0xA1, 0xD6,
+  0xA1, 0x2C, 0x55, 0x55, 0xCB, 0x55, 0x55, 0x55,
+  0x55, 0x55, 0x95, 0x2C, 0xD6, 0xD6, 0xD6, 0xA1,
+  0x2C, 0x95, 0x55, 0x55, 0x55, 0x95, 0x95, 0x95,
+  0x70, 0x70, 0x55, 0x2C, 0xD6, 0xD6, 0xA1, 0x95,
+  0x55, 0x90, 0xCB, 0xCB, 0x55, 0x55, 0x2C, 0x2C,
+  0xA1, 0xD6, 0xA1, 0xA1, 0x2C, 0x2C, 0x95, 0x55,
+  0x55, 0x55, 0x95, 0x95, 0x2C, 0x95, 0x95, 0xD6,
+  0xB1, 0x88, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+  0x20, 0x20, 0x20, 0x80, 0x34, 0x88, 0x43, 0x47,
+  0x95, 0xCB, 0x70, 0x70, 0x55, 0x2C, 0xD6, 0xD6,
+  0xA1, 0x95, 0x55, 0x90, 0xCB, 0xCB, 0x55, 0x55,
+  0x2C, 0x2C, 0xA1, 0xD6, 0xA1, 0xA1, 0xA1, 0x2C,
+  0x55, 0x55, 0x55, 0x55, 0x2C, 0x95, 0x2C, 0x2C,
+  0x55, 0x55, 0x95, 0x2C, 0xA1, 0xA1, 0x2C, 0x55,
+  0x90, 0x70, 0x90, 0x55, 0x95, 0x95, 0xA1, 0xA1,
+  0xA1, 0xA1, 0xA1, 0xA1, 0x2C, 0x95, 0x95, 0x95,
+  0x95, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0xD5,
+  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+  0x20, 0x20, 0x88, 0x7D, 0x3F, 0xB1, 0x80, 0x20,
+  0x99, 0x2C, 0x55, 0x55, 0x95, 0x2C, 0xA1, 0xA1,
+  0x2C, 0x55, 0x90, 0x70, 0x90, 0x55, 0x95, 0x95,
+  0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0x2C, 0x2C, 0x2C,
+  0x95, 0x55, 0x95, 0x95, 0x2C, 0x2C, 0x2C, 0x2C,
+  0x95, 0x90, 0x55, 0x2C, 0xA1, 0xA1, 0x95, 0xCB,
+  0x70, 0x94, 0x90, 0x55, 0x95, 0xA1, 0xA1, 0xA1,
+  0x2C, 0x2C, 0x2C, 0x2C, 0x95, 0x95, 0x95, 0x95,
+  0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0xA1, 0x88,
+  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+  0x20, 0x20, 0x20, 0xB1, 0x47, 0xD5, 0x7D, 0x43,
+  0x20, 0x70, 0x95, 0x90, 0x55, 0x2C, 0xA1, 0xA1,
+  0x95, 0xCB, 0x70, 0x94, 0x90, 0x55, 0x95, 0xA1,
+  0xA1, 0xA1, 0x2C, 0x95, 0x2C, 0x2C, 0x95, 0x95,
+  0x95, 0x95, 0x95, 0x2C, 0x95, 0x95, 0x95, 0x95,
+  0x95, 0x90, 0x55, 0x2C, 0xD6, 0xD6, 0x2C, 0x90,
+  0x94, 0x70, 0x55, 0x95, 0x2C, 0xD6, 0xD6, 0xA1,
+  0x95, 0x95, 0x95, 0x2C, 0x2C, 0x95, 0x55, 0x55,
+  0xCB, 0xCB, 0xCB, 0x55, 0xCB, 0x55, 0x47, 0x20,
+  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+  0x20, 0x20, 0x88, 0xB1, 0x3F, 0x92, 0x2B, 0x80,
+  0x20, 0x80, 0xD6, 0x70, 0x55, 0x2C, 0xD6, 0xD6,
+  0x2C, 0x90, 0x94, 0x70, 0x55, 0x95, 0x2C, 0xD6,
+  0xD6, 0xA1, 0x2C, 0x95, 0x95, 0x2C, 0x2C, 0x95,
+  0x95, 0x55, 0x90, 0xCB, 0xCB, 0xCB, 0xCB, 0x55,
+  0xD6, 0x55, 0x95, 0xA1, 0xD6, 0xA1, 0x55, 0x70,
+  0x94, 0x55, 0x95, 0xA1, 0xA1, 0xA1, 0xA1, 0x95,
+  0x55, 0x55, 0x55, 0x95, 0x55, 0x55, 0xCB, 0x90,
+  0x70, 0x90, 0xCB, 0x55, 0x55, 0xA1, 0xD8, 0x20,
+  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+  0x20, 0x20, 0x88, 0xD8, 0xE1, 0x88, 0x20, 0x20,
+  0x88, 0x88, 0xE6, 0x55, 0x2C, 0xA1, 0xD6, 0xA1,
+  0x55, 0x70, 0x94, 0x55, 0x95, 0xA1, 0xA1, 0xA1,
+  0xA1, 0x95, 0x55, 0x55, 0x95, 0x95, 0x55, 0x55,
+  0x90, 0x90, 0x90, 0x90, 0xCB, 0x55, 0x55, 0x55,
+  0xD6, 0x2C, 0xA1, 0xD6, 0xD6, 0xA1, 0xCB, 0x70,
+  0x70, 0x95, 0x2C, 0xA1, 0xA1, 0x2C, 0x2C, 0x55,
+  0xCB, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
+  0x55, 0x95, 0x2C, 0x95, 0x2C, 0xD6, 0x20, 0x20,
+  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+  0x20, 0x20, 0x80, 0xD6, 0xA1, 0xD6, 0xD6, 0xA1,
+  0xCB, 0x70, 0x70, 0x95, 0x2C, 0xA1, 0xA1, 0x2C,
+  0x2C, 0x55, 0xCB, 0xCB, 0x55, 0x55, 0x55, 0x55,
+  0x55, 0x55, 0x55, 0x95, 0x2C, 0x2C, 0x2C, 0x2C,
+  0xD6, 0xA1, 0xA1, 0xA1, 0xA1, 0x55, 0x70, 0x94,
+  0xCB, 0x95, 0xA1, 0xA1, 0x2C, 0x95, 0xCB, 0x55,
+  0x90, 0xCB, 0x55, 0x55, 0x55, 0x55, 0x95, 0xA1,
+  0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0x95, 0x20, 0x20,
+  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+  0x88, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+  0x20, 0x20, 0x88, 0x95, 0xA1, 0xA1, 0xA1, 0x55,
+  0x70, 0x94, 0xCB, 0x95, 0xA1, 0xA1, 0x2C, 0x95,
+  0xCB, 0xCB, 0x90, 0xCB, 0x55, 0x55, 0x55, 0x55,
+  0x95, 0x2C, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1,
+  0x2C, 0x2C, 0x2C, 0x95, 0x95, 0xCB, 0x70, 0x70,
+  0x95, 0x2C, 0x2C, 0x95, 0xCB, 0x70, 0x90, 0xCB,
+  0xCB, 0x55, 0x55, 0xCB, 0x55, 0x55, 0x2C, 0xD6,
+  0xD6, 0xD6, 0xD6, 0xA1, 0x2C, 0x70, 0x20, 0x20,
+  0x88, 0x43, 0xD8, 0x43, 0x20, 0x20, 0x20, 0x20,
+  0x20, 0x88, 0x88, 0x43, 0x2B, 0xD8, 0x20, 0x20,
+  0x20, 0x20, 0x20, 0x3F, 0x2C, 0x95, 0x95, 0xCB,
+  0x70, 0x70, 0x95, 0x2C, 0x2C, 0x95, 0xCB, 0x90,
+  0x90, 0xCB, 0x55, 0xCB, 0x55, 0xCB, 0x55, 0x95,
+  0x2C, 0xD6, 0xD6, 0xD6, 0xD6, 0xA1, 0x2C, 0x2C,
+  0xA1, 0x95, 0x95, 0x55, 0xCB, 0x70, 0x90, 0x55,
+  0x2C, 0x2C, 0x2C, 0x55, 0x70, 0x70, 0x55, 0x95,
+  0x95, 0xCB, 0x90, 0x90, 0x90, 0x95, 0x2C, 0xA1,
+  0xD6, 0xD6, 0x2C, 0x2C, 0x95, 0x70, 0x20, 0x20,
+  0x80, 0x2B, 0x34, 0x2B, 0x88, 0x20, 0x20, 0x20,
+  0x88, 0xB1, 0x28, 0x28, 0x2B, 0x7D, 0x80, 0x20,
+  0x20, 0x20, 0x20, 0x92, 0x95, 0x55, 0xCB, 0x70,
+  0x90, 0x55, 0x2C, 0x2C, 0x2C, 0x55, 0x70, 0x70,
+  0x55, 0x95, 0x55, 0x55, 0x90, 0x90, 0x90, 0x55,
+  0x2C, 0xA1, 0xD6, 0xA1, 0x2C, 0x2C, 0x95, 0x95,
+  0xA1, 0x95, 0x55, 0xCB, 0x90, 0x70, 0xCB, 0x95,
+  0xA1, 0x95, 0x95, 0xCB, 0x90, 0xCB, 0x95, 0x2C,
+  0x95, 0x70, 0x70, 0x90, 0x55, 0x2C, 0xA1, 0xA1,
+  0x2C, 0x2C, 0x55, 0xCB, 0x55, 0x90, 0x20, 0x34,
+  0x90, 0x6D, 0x70, 0xD8, 0x43, 0x20, 0x20, 0x88,
+  0x3F, 0x55, 0xA1, 0x2A, 0xD6, 0x7D, 0x43, 0x20,
+  0x20, 0x20, 0x88, 0x7D, 0x55, 0xCB, 0x90, 0x70,
+  0xCB, 0x95, 0xA1, 0x95, 0x95, 0xCB, 0x70, 0xCB,
+  0x95, 0xA1, 0x95, 0x70, 0x70, 0xCB, 0x55, 0x2C,
+  0xA1, 0xA1, 0xA1, 0x95, 0x55, 0x55, 0x55, 0x95,
+  0x2C, 0x55, 0x90, 0x70, 0x94, 0x90, 0x95, 0x2C,
+  0x2C, 0x95, 0xCB, 0x90, 0x55, 0x95, 0xA1, 0xA1,
+  0x95, 0x90, 0x90, 0x95, 0xA1, 0xD6, 0xD6, 0x6D,
+  0xA1, 0x95, 0x55, 0xCB, 0x55, 0xCB, 0x20, 0x99,
+  0xBF, 0xA3, 0xA3, 0x90, 0x20, 0x20, 0x20, 0x92,
+  0x83, 0x6B, 0x6B, 0x6B, 0xA3, 0x70, 0x88, 0x20,
+  0x20, 0x20, 0x20, 0x2B, 0x90, 0x70, 0x94, 0x90,
+  0x95, 0x2C, 0x2C, 0x95, 0xCB, 0x90, 0x55, 0x95,
+  0xA1, 0x2C, 0x55, 0x90, 0x90, 0x95, 0xA1, 0xD6,
+  0xD6, 0x6D, 0xA1, 0x95, 0x55, 0xCB, 0x55, 0x55,
+  0x2C, 0x55, 0x70, 0x70, 0x94, 0x90, 0x95, 0x2C,
+  0x2C, 0x55, 0xCB, 0xCB, 0x95, 0x2C, 0x2C, 0x2C,
+  0x55, 0x55, 0x95, 0xA1, 0x6D, 0xBF, 0x6D, 0xD6,
+  0x95, 0x55, 0x90, 0xCB, 0x55, 0x95, 0x88, 0x95,
+  0x2C, 0x3F, 0x6D, 0x6B, 0x34, 0x20, 0x20, 0x47,
+  0x65, 0xD6, 0xE1, 0x3F, 0x2A, 0x6B, 0x2B, 0x20,
+  0x20, 0x20, 0x20, 0x43, 0x70, 0x70, 0x94, 0x90,
+  0x95, 0x2C, 0x2C, 0x55, 0x55, 0x55, 0x95, 0x2C,
+  0xA1, 0x2C, 0x55, 0xCB, 0x95, 0xA1, 0x6D, 0xBF,
+  0x6D, 0xD6, 0x2C, 0x55, 0x90, 0xCB, 0x95, 0x95,
+  0x95, 0x55, 0x70, 0x94, 0x70, 0x55, 0x2C, 0xA1,
+  0x2C, 0x55, 0xCB, 0x55, 0x2C, 0x95, 0x2C, 0x95,
+  0x95, 0x95, 0xA1, 0x6D, 0xBF, 0x2A, 0xD6, 0x95,
+  0x70, 0x94, 0x94, 0x70, 0x55, 0x55, 0x20, 0xBF,
+  0xC9, 0xB1, 0x99, 0x42, 0xB1, 0x61, 0x7D, 0x94,
+  0x65, 0xB1, 0x88, 0x99, 0xD5, 0xE5, 0x7F, 0x20,
+  0x20, 0x20, 0x20, 0x43, 0x70, 0x94, 0x70, 0x55,
+  0x2C, 0xA1, 0x2C, 0x55, 0x90, 0x55, 0x2C, 0x95,
+  0x2C, 0x95, 0x95, 0x2C, 0xA1, 0x6D, 0xBF, 0xBF,
+  0xD6, 0x55, 0x70, 0x94, 0x94, 0x70, 0xCB, 0x55,
+  0x55, 0xCB, 0x70, 0x94, 0x70, 0x95, 0xA1, 0xA1,
+  0x95, 0x55, 0x55, 0x95, 0x2C, 0x95, 0x95, 0x95,
+  0x95, 0xA1, 0x6D, 0x2A, 0x2A, 0xD6, 0x55, 0x94,
+  0xE6, 0xE6, 0x47, 0x70, 0x55, 0x95, 0x20, 0x2A,
+  0xD8, 0x43, 0xC9, 0x83, 0x98, 0x79, 0x34, 0x9F,
+  0x6B, 0x43, 0x20, 0x88, 0x2B, 0x65, 0xA0, 0x20,
+  0x20, 0x20, 0x20, 0xE1, 0x70, 0x94, 0x70, 0x95,
+  0xA1, 0xA1, 0x95, 0x55, 0x55, 0x95, 0x2C, 0x95,
+  0x95, 0x95, 0x95, 0xA1, 0x6D, 0xBF, 0x2A, 0xD6,
+  0x55, 0x94, 0xE6, 0xE6, 0x47, 0x70, 0x55, 0x55,
+  0x94, 0x70, 0x94, 0x47, 0x70, 0x95, 0x2C, 0x2C,
+  0x95, 0xCB, 0x95, 0x2C, 0x2C, 0xA1, 0x2C, 0x2C,
+  0xA1, 0xD6, 0x6D, 0x6D, 0xA1, 0xCB, 0x47, 0x28,
+  0xE6, 0x47, 0x70, 0x55, 0x95, 0xA1, 0x20, 0x2C,
+  0x7F, 0x88, 0xF0, 0xC6, 0x25, 0x5E, 0xCF, 0x2F,
+  0xE7, 0x9A, 0x20, 0x88, 0x99, 0x65, 0x3F, 0x20,
+  0x20, 0x20, 0x20, 0x34, 0x94, 0x47, 0x70, 0x95,
+  0xA1, 0x2C, 0x55, 0xCB, 0x95, 0x2C, 0x2C, 0xA1,
+  0x2C, 0x2C, 0xA1, 0xD6, 0x6D, 0x6D, 0xA1, 0xCB,
+  0x94, 0x28, 0xA0, 0x47, 0x70, 0x55, 0x95, 0x95,
+  0x47, 0x70, 0x90, 0x94, 0x70, 0x95, 0xA1, 0x2C,
+  0x55, 0x55, 0x2C, 0xA1, 0xA1, 0xA1, 0xA1, 0x2C,
+  0xA1, 0x6D, 0x2A, 0xD6, 0x55, 0x47, 0x28, 0x28,
+  0x47, 0x70, 0x55, 0x95, 0x2C, 0xA1, 0x20, 0x28,
+  0xEC, 0x86, 0xBE, 0x48, 0x3E, 0x3E, 0x3A, 0x25,
+  0x4E, 0xAE, 0x93, 0xD7, 0xEC, 0xD1, 0x34, 0x20,
+  0x20, 0x20, 0x20, 0x43, 0x55, 0x94, 0x70, 0x95,
+  0xA1, 0xA1, 0x55, 0xCB, 0x2C, 0xA1, 0xA1, 0xA1,
+  0xA1, 0x2C, 0xA1, 0x6D, 0x6D, 0xD6, 0x55, 0x47,
+  0x28, 0x28, 0x47, 0x70, 0x55, 0x95, 0x2C, 0x2C,
+  0x95, 0x95, 0x55, 0x90, 0xCB, 0x2C, 0xA1, 0xA1,
+  0x55, 0x55, 0x2C, 0xD6, 0xD6, 0xA1, 0xA1, 0x2C,
+  0xD6, 0x6D, 0x6D, 0xA1, 0x70, 0x28, 0xD5, 0xE6,
+  0x70, 0x55, 0x95, 0x2C, 0xA1, 0xD6, 0x20, 0xE1,
+  0x26, 0x84, 0x76, 0x73, 0x9C, 0x22, 0x4E, 0x35,
+  0x8C, 0x7A, 0x4E, 0xDC, 0x8E, 0x7E, 0x3D, 0x88,
+  0x20, 0x20, 0x20, 0x88, 0x2C, 0x90, 0x90, 0x95,
+  0xA1, 0x2C, 0x55, 0x55, 0x2C, 0xD6, 0xD6, 0xD6,
+  0x2C, 0x2C, 0xD6, 0x2A, 0x6D, 0x2C, 0x70, 0x28,
+  0xD5, 0xE6, 0x70, 0x55, 0x95, 0xA1, 0x2C, 0xA1,
+  0xBF, 0xA1, 0x95, 0xCB, 0xCB, 0x2C, 0xA1, 0xA1,
+  0x95, 0x95, 0xA1, 0xD6, 0xD6, 0xA1, 0x2C, 0x95,
+  0xD6, 0x6D, 0xD6, 0x95, 0x94, 0x28, 0xE6, 0x70,
+  0x55, 0x95, 0xA1, 0xA1, 0xA1, 0xD6, 0x20, 0x57,
+  0xE4, 0xDF, 0x50, 0x3E, 0x22, 0x4E, 0x35, 0x8C,
+  0x8C, 0x52, 0x52, 0x7A, 0x4E, 0x58, 0xD7, 0x20,
+  0x20, 0x20, 0x20, 0x88, 0x2C, 0xCB, 0x55, 0x2C,
+  0xA1, 0xA1, 0x95, 0x95, 0xA1, 0xD6, 0xD6, 0xA1,
+  0x2C, 0x95, 0xA1, 0x6D, 0x6D, 0x95, 0x47, 0xA0,
+  0xE6, 0x70, 0x55, 0x95, 0x2C, 0xA1, 0xA1, 0xA1,
+  0xD2, 0x95, 0x55, 0x90, 0x55, 0x2C, 0xD6, 0xA1,
+  0x95, 0x95, 0xA1, 0xD6, 0xD6, 0x2C, 0x95, 0x2C,
+  0xA1, 0x6D, 0xA1, 0x55, 0x94, 0x47, 0x94, 0xCB,
+  0x55, 0x95, 0x2C, 0xA1, 0xD6, 0xD6, 0x59, 0xC8,
+  0xE3, 0x76, 0x2D, 0x3E, 0x22, 0x4E, 0x8C, 0x35,
+  0x52, 0x52, 0xEE, 0x3A, 0x4D, 0xED, 0x24, 0x20,
+  0x20, 0x20, 0x20, 0x20, 0x28, 0xCB, 0x55, 0x2C,
+  0xD6, 0xA1, 0x95, 0x95, 0xA1, 0xD6, 0xA1, 0x2C,
+  0x95, 0x2C, 0xD6, 0x6D, 0xA1, 0x55, 0x94, 0xE6,
+  0x70, 0xCB, 0x55, 0x95, 0xA1, 0xD6, 0xD6, 0xA1,
+  0xD0, 0x94, 0x94, 0x90, 0x55, 0x2C, 0xA1, 0xA1,
+  0x55, 0x95, 0xA1, 0xA1, 0xA1, 0x2C, 0x95, 0x2C,
+  0xA1, 0xD6, 0x2C, 0x70, 0x94, 0x94, 0x94, 0x94,
+  0x70, 0x55, 0xA1, 0xD6, 0xA1, 0xD6, 0x88, 0x77,
+  0x38, 0xC4, 0x3E, 0x69, 0x4E, 0x35, 0x8C, 0xEE,
+  0x35, 0x89, 0x30, 0x30, 0x4A, 0x48, 0x3C, 0x20,
+  0x20, 0x88, 0x20, 0x20, 0xD8, 0x2C, 0x55, 0x2C,
+  0xD6, 0xA1, 0x95, 0x95, 0x2C, 0xD6, 0xA1, 0x2C,
+  0x95, 0x2C, 0xA1, 0xD6, 0x2C, 0x90, 0x94, 0x47,
+  0x94, 0x94, 0x70, 0x55, 0x2C, 0xD6, 0xA1, 0x95,
+  0x95, 0x28, 0x47, 0x90, 0x95, 0x2C, 0xA1, 0x2C,
+  0x95, 0x55, 0x95, 0xA1, 0xD6, 0xA1, 0x2C, 0x2C,
+  0xA1, 0xA1, 0x55, 0x70, 0x94, 0x47, 0x94, 0x94,
+  0x70, 0x2C, 0xD6, 0xD6, 0x2C, 0xA1, 0x43, 0x98,
+  0x54, 0x48, 0x3E, 0x22, 0x35, 0xEE, 0xEE, 0x9C,
+  0x4D, 0x45, 0x75, 0x4A, 0xDF, 0x7B, 0x3D, 0x20,
+  0xD8, 0x28, 0x2B, 0x88, 0x20, 0x95, 0x95, 0x2C,
+  0xA1, 0x2C, 0x55, 0x55, 0x2C, 0xA1, 0xD6, 0xA1,
+  0x2C, 0x95, 0xA1, 0x2C, 0x55, 0x70, 0x94, 0x94,
+  0x94, 0x94, 0x70, 0x95, 0xD6, 0xD6, 0x2C, 0x95,
+  0x70, 0x28, 0x47, 0x55, 0x95, 0x2C, 0x2C, 0x2C,
+  0x95, 0x95, 0x95, 0xA1, 0xA1, 0xA1, 0x95, 0x55,
+  0x95, 0x95, 0x55, 0x70, 0x70, 0x70, 0x94, 0x70,
+  0x55, 0xD6, 0x6D, 0xD6, 0x95, 0x2C, 0x20, 0x43,
+  0xBB, 0xC8, 0x36, 0x30, 0x30, 0x38, 0x45, 0x6E,
+  0xE3, 0x75, 0x78, 0x37, 0xBD, 0xD9, 0x3F, 0x20,
+  0x88, 0xD5, 0x70, 0xB1, 0x88, 0xA0, 0x95, 0x2C,
+  0x2C, 0xA1, 0x95, 0x55, 0x95, 0xA1, 0xA1, 0xA1,
+  0x2C, 0x55, 0x95, 0x2C, 0x55, 0x70, 0x70, 0x70,
+  0x94, 0x70, 0x55, 0xD6, 0x6D, 0x6D, 0x95, 0x55,
+  0x94, 0x47, 0x70, 0x95, 0x2C, 0x2C, 0x2C, 0xA1,
+  0x2C, 0x95, 0x2C, 0xA1, 0xD6, 0xA1, 0x2C, 0x55,
+  0x55, 0x95, 0x95, 0x55, 0x55, 0x55, 0x55, 0x95,
+  0xA1, 0x6D, 0x4B, 0xD6, 0x55, 0xD6, 0x20, 0xD8,
+  0xD6, 0x67, 0xDA, 0x4D, 0xED, 0x62, 0x78, 0x78,
+  0x23, 0x84, 0x67, 0xF5, 0x4B, 0xBF, 0x90, 0x88,
+  0x88, 0x2B, 0x47, 0x99, 0x20, 0x43, 0xD6, 0x2C,
+  0x2C, 0xA1, 0x2C, 0x95, 0x2C, 0xA1, 0xD6, 0xA1,
+  0x95, 0x95, 0x55, 0x95, 0x55, 0x55, 0x55, 0x55,
+  0x55, 0x95, 0xD6, 0x6D, 0xBF, 0xD6, 0x55, 0xCB,
+  0x55, 0x55, 0x55, 0x2C, 0x2C, 0x2C, 0x2C, 0xA1,
+  0x2C, 0x2C, 0x2C, 0xA1, 0xA1, 0x2C, 0x2C, 0x95,
+  0x55, 0x95, 0x95, 0x2C, 0x2C, 0x2C, 0x2C, 0xA1,
+  0x6D, 0x2A, 0x2A, 0xA1, 0x55, 0x55, 0x20, 0xD8,
+  0x6D, 0xAB, 0x96, 0x7E, 0x64, 0x53, 0x36, 0x36,
+  0xC6, 0x63, 0x6D, 0xD0, 0x6B, 0xE5, 0xA3, 0x7D,
+  0x20, 0x88, 0x80, 0x88, 0x20, 0x20, 0xC9, 0xA1,
+  0x2C, 0xA1, 0xA1, 0x2C, 0x2C, 0xA1, 0xA1, 0xA1,
+  0x95, 0x95, 0x55, 0x95, 0x95, 0x2C, 0x2C, 0x2C,
+  0x2C, 0xA1, 0x6D, 0xBF, 0x6D, 0xA1, 0x55, 0x55,
+  0x95, 0x95, 0x95, 0x95, 0x2C, 0x2C, 0x2C, 0xA1,
+  0xA1, 0x95, 0x95, 0x2C, 0x2C, 0x2C, 0x2C, 0x95,
+  0x55, 0x55, 0x2C, 0x2C, 0xA1, 0xA1, 0xD6, 0xD6,
+  0x6D, 0x6D, 0xA1, 0x55, 0x2C, 0xD8, 0x20, 0xB1,
+  0xA3, 0x4B, 0x6D, 0xD9, 0xA7, 0x6C, 0xAF, 0xB2,
+  0x6D, 0x2A, 0x83, 0x42, 0xE5, 0xE5, 0x65, 0x2C,
+  0x20, 0x20, 0x88, 0x20, 0x20, 0x20, 0x88, 0x95,
+  0x2C, 0xA1, 0x2C, 0x95, 0x95, 0x2C, 0x2C, 0x2C,
+  0x2C, 0x95, 0x55, 0x55, 0x2C, 0x2C, 0xA1, 0xA1,
+  0xD6, 0xD6, 0x6D, 0x6D, 0xA1, 0x55, 0xCB, 0x55,
+  0x95, 0x55, 0x95, 0x95, 0x2C, 0x2C, 0x95, 0x2C,
+  0x2C, 0x95, 0x95, 0x95, 0x95, 0x95, 0x2C, 0x95,
+  0x55, 0x95, 0x2C, 0x2C, 0xA1, 0xA1, 0xD6, 0xA1,
+  0xA1, 0x2C, 0x55, 0x55, 0x28, 0x88, 0x43, 0x2A,
+  0xE5, 0xA3, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D,
+  0xBF, 0xA3, 0x42, 0xE5, 0xE5, 0xE5, 0xE5, 0x65,
+  0xB1, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xD8,
+  0xD6, 0x2C, 0x2C, 0x95, 0x95, 0x95, 0x95, 0x2C,
+  0x95, 0x95, 0x55, 0x95, 0x2C, 0x2C, 0xA1, 0xA1,
+  0xA1, 0xA1, 0xA1, 0x2C, 0x95, 0x90, 0x90, 0x55,
+  0x90, 0xCB, 0x55, 0x95, 0x95, 0x95, 0x95, 0x95,
+  0x2C, 0x2C, 0x95, 0x55, 0x95, 0x95, 0x95, 0x55,
+  0x55, 0xCB, 0x55, 0x2C, 0x95, 0x95, 0x95, 0x95,
+  0x55, 0x90, 0x90, 0x90, 0xE1, 0x43, 0x28, 0xE5,
+  0xE5, 0x65, 0xD0, 0x6D, 0x6D, 0x6D, 0x2A, 0xD2,
+  0x42, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xD6, 0x20, 0x20, 0x20, 0x20, 0x20, 0x88, 0x88,
+  0xD5, 0x2C, 0x2C, 0x2C, 0x95, 0x55, 0x95, 0x95,
+  0x95, 0x55, 0x55, 0xCB, 0x55, 0x95, 0x2C, 0x95,
+  0x95, 0x95, 0x55, 0x90, 0x70, 0x70, 0x70, 0x90,
+  0x70, 0x70, 0xCB, 0x55, 0x55, 0x95, 0x95, 0x95,
+  0x2C, 0x95, 0x95, 0x55, 0x55, 0x55, 0x55, 0xCB,
+  0x70, 0x70, 0x70, 0xCB, 0x90, 0x90, 0x70, 0x94,
+  0x94, 0x94, 0x2C, 0x80, 0x20, 0xE1, 0xA3, 0xE5,
+  0xE5, 0xE5, 0x42, 0xEC, 0xD0, 0x83, 0xA3, 0x65,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0x65, 0x7D, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+  0x88, 0x2C, 0x95, 0x95, 0x95, 0x55, 0x55, 0x55,
+  0x55, 0xCB, 0x70, 0x70, 0x90, 0x90, 0x90, 0x90,
+  0x70, 0x94, 0x94, 0x94, 0x70, 0x70, 0x70, 0x70,
+  0x70, 0x55, 0x55, 0x55, 0x95, 0x95, 0x95, 0x95,
+  0x2C, 0x2C, 0x95, 0x55, 0x55, 0x55, 0x55, 0x55,
+  0x90, 0x70, 0x90, 0x55, 0x55, 0xCB, 0x70, 0x94,
+  0x94, 0x95, 0xD8, 0x20, 0x88, 0x70, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0x65, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0x47, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+  0x20, 0xE1, 0x6D, 0x2C, 0x95, 0x55, 0x55, 0x55,
+  0x55, 0x55, 0x90, 0x70, 0x70, 0x55, 0x55, 0xCB,
+  0x70, 0x94, 0x94, 0x94, 0x70, 0x90, 0x70, 0x94,
+  0x55, 0x2C, 0x2C, 0x2C, 0x95, 0x2C, 0x95, 0x95,
+  0x2C, 0x2C, 0x2C, 0x55, 0x55, 0x55, 0x55, 0x55,
+  0xCB, 0xCB, 0x95, 0x2C, 0x2C, 0x95, 0x55, 0x90,
+  0x55, 0x99, 0x20, 0x20, 0xE1, 0xA3, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xD6, 0x88, 0x20, 0x20, 0x20, 0x20, 0x20,
+  0x20, 0x20, 0x2B, 0x6D, 0x95, 0x95, 0x55, 0x55,
+  0x55, 0x55, 0xCB, 0x55, 0x95, 0x2C, 0x2C, 0x95,
+  0x55, 0x90, 0xCB, 0xCB, 0xCB, 0xCB, 0x90, 0x70,
+  0x2C, 0xD6, 0xD6, 0x2C, 0x2C, 0x95, 0x95, 0x95,
+  0x95, 0x95, 0x95, 0x2C, 0x95, 0x95, 0x95, 0x95,
+  0x95, 0x95, 0x2C, 0xA1, 0x2C, 0x95, 0x55, 0x95,
+  0xE6, 0x88, 0x20, 0x20, 0x3F, 0xA3, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0x42, 0xA3, 0x88, 0x20, 0x20, 0x20, 0x20, 0x20,
+  0x20, 0x20, 0x88, 0x2B, 0xD6, 0x95, 0x95, 0x95,
+  0x95, 0x95, 0x95, 0x95, 0x2C, 0xA1, 0x2C, 0x95,
+  0x55, 0x55, 0x95, 0x95, 0x95, 0x55, 0x55, 0x55,
+  0xA1, 0xD6, 0xD6, 0xA1, 0x2C, 0x2C, 0x95, 0x2C,
+  0x2C, 0x2C, 0x95, 0x2C, 0x95, 0x95, 0x55, 0x95,
+  0x95, 0x2C, 0x2C, 0x2C, 0x95, 0xCB, 0xCB, 0x94,
+  0x20, 0x20, 0x20, 0x20, 0xE6, 0x83, 0x65, 0xE5,
+  0xE5, 0xE5, 0xE5, 0x42, 0x6B, 0x6B, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0x42, 0x6B, 0x6B, 0xA3, 0xD2,
+  0xD2, 0x6B, 0xC9, 0x20, 0x20, 0x88, 0x20, 0x20,
+  0x20, 0x20, 0x20, 0x88, 0x8A, 0xA1, 0x95, 0x95,
+  0x95, 0x55, 0x95, 0x2C, 0xA1, 0x2C, 0x95, 0xCB,
+  0xCB, 0x55, 0x95, 0x95, 0x95, 0x55, 0x55, 0x95,
+  0x6D, 0x6D, 0x6D, 0xD6, 0xA1, 0x2C, 0x2C, 0x95,
+  0x2C, 0x95, 0x2C, 0x95, 0x95, 0x95, 0x95, 0x95,
+  0x95, 0x95, 0x95, 0x55, 0x70, 0x70, 0x2C, 0x80,
+  0x88, 0x20, 0x20, 0x80, 0x94, 0xD6, 0x32, 0x6B,
+  0xE5, 0xE5, 0xE5, 0x42, 0x6B, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xA3, 0xD2, 0xD0, 0xBF, 0x2A,
+  0x2A, 0xD0, 0x6D, 0x34, 0x20, 0xE1, 0x88, 0x20,
+  0x20, 0x20, 0x20, 0x20, 0x88, 0xA1, 0x95, 0x95,
+  0x95, 0x95, 0x95, 0x95, 0x95, 0x55, 0x70, 0x70,
+  0x70, 0x90, 0xCB, 0xCB, 0xCB, 0x95, 0x95, 0x2C,
+  0xD0, 0x6D, 0xD6, 0xD6, 0xA1, 0xA1, 0xA1, 0x2C,
+  0x2C, 0x2C, 0x2C, 0x95, 0x55, 0x55, 0x55, 0x95,
+  0x95, 0x2C, 0x95, 0x55, 0xCB, 0xCB, 0x95, 0x88,
+  0x20, 0x20, 0x88, 0xD8, 0x2C, 0xD1, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0x65, 0x65, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0x42, 0x6B, 0xEC,
+  0xBF, 0x2A, 0xEC, 0x95, 0x20, 0x34, 0x2B, 0xE1,
+  0x20, 0x20, 0x20, 0x20, 0x20, 0x99, 0x95, 0x55,
+  0x55, 0x55, 0x95, 0x95, 0x95, 0x55, 0xCB, 0xCB,
+  0x55, 0x55, 0xCB, 0xCB, 0xCB, 0x55, 0x95, 0x95,
+  0x32, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0x2C, 0x2C,
+  0xA1, 0x95, 0x95, 0x95, 0x55, 0xCB, 0xCB, 0x55,
+  0x95, 0x95, 0x95, 0x95, 0x95, 0x55, 0x99, 0x20,
+  0xE1, 0xE1, 0x43, 0x47, 0x6B, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0x42, 0xEC, 0xBF, 0xA3, 0x8A, 0x20, 0x88, 0xD8,
+  0x2B, 0x20, 0x20, 0x20, 0x88, 0x88, 0x2C, 0xCB,
+  0xCB, 0x95, 0x95, 0x2C, 0x95, 0x95, 0x55, 0x95,
+  0x55, 0x55, 0x55, 0x55, 0x55, 0x95, 0x55, 0x95,
+  0x6D, 0x55, 0x55, 0x55, 0x95, 0x95, 0x2C, 0x95,
+  0x2C, 0x95, 0x95, 0x55, 0x55, 0x55, 0x55, 0x95,
+  0x95, 0x95, 0x95, 0x95, 0x95, 0xA1, 0x34, 0x20,
+  0xC9, 0x20, 0xE1, 0xA3, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xA3, 0x83, 0x6D, 0x20, 0x88, 0x88,
+  0x2B, 0x34, 0x20, 0x20, 0x20, 0x88, 0xD5, 0x55,
+  0x55, 0x55, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95,
+  0x95, 0x95, 0x95, 0x95, 0x55, 0x55, 0x95, 0x95,
+  0x2C, 0x55, 0xCB, 0x55, 0xCB, 0x55, 0x55, 0x95,
+  0x95, 0x95, 0x95, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+  0x2C, 0x95, 0x95, 0x55, 0x95, 0x2C, 0x20, 0xD8,
+  0xE1, 0x20, 0x70, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0x65, 0xA3, 0x92, 0x43, 0x7D,
+  0xD8, 0xC9, 0x88, 0x20, 0x20, 0x20, 0x43, 0xD6,
+  0x2C, 0x2C, 0x95, 0x95, 0x95, 0x55, 0x95, 0x2C,
+  0x95, 0x95, 0x95, 0x95, 0x95, 0x2C, 0x95, 0x2C,
+  0xA1, 0x55, 0x55, 0x55, 0x55, 0x95, 0x95, 0x55,
+  0x55, 0x55, 0x95, 0x95, 0x2C, 0x2C, 0xA1, 0x2C,
+  0xA1, 0x2C, 0x2C, 0x95, 0x2C, 0x99, 0x88, 0xB1,
+  0x20, 0xD8, 0x42, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xCB, 0x34, 0x8A,
+  0xC9, 0x34, 0x2B, 0x20, 0x20, 0x20, 0x20, 0x90,
+  0xA1, 0xA1, 0xA1, 0x2C, 0x2C, 0x95, 0x95, 0x2C,
+  0x2C, 0x95, 0x95, 0x95, 0x95, 0x2C, 0x2C, 0x2C,
+  0xD6, 0x2C, 0x55, 0x55, 0x95, 0x2C, 0x2C, 0x2C,
+  0x55, 0xCB, 0x55, 0x2C, 0x2C, 0xA1, 0x2C, 0xA1,
+  0xA1, 0xA1, 0x2C, 0x2C, 0x6D, 0x43, 0xD8, 0x80,
+  0x88, 0xCB, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0x32, 0x80, 0xE1,
+  0x80, 0x20, 0xB1, 0x20, 0x20, 0x20, 0x20, 0xC9,
+  0xD6, 0xA1, 0xA1, 0xA1, 0x2C, 0xA1, 0x2C, 0x2C,
+  0x2C, 0x55, 0x55, 0x55, 0x95, 0x95, 0x95, 0x55,
+  0xD6, 0x95, 0x95, 0x95, 0x2C, 0xA1, 0x2C, 0x2C,
+  0x95, 0x95, 0x95, 0x95, 0x95, 0x2C, 0x95, 0x2C,
+  0x2C, 0x2C, 0x2C, 0x95, 0xCB, 0x20, 0xC9, 0x20,
+  0xE1, 0xA3, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0x42, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xD8, 0x20,
+  0x20, 0x20, 0x2B, 0x43, 0x20, 0x20, 0x20, 0x88,
+  0xD6, 0x2C, 0x2C, 0x2C, 0x95, 0x95, 0x95, 0x55,
+  0x95, 0x55, 0x55, 0xCB, 0x55, 0xCB, 0xCB, 0x55,
+  0x2C, 0x55, 0x55, 0x95, 0x2C, 0x2C, 0xA1, 0x95,
+  0x55, 0x95, 0x55, 0x95, 0x95, 0x95, 0x95, 0x95,
+  0x55, 0xCB, 0x70, 0xCB, 0xC9, 0x80, 0x2B, 0x20,
+  0xA0, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0x42, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0x92, 0x20,
+  0x20, 0x20, 0xE1, 0xD8, 0x20, 0x20, 0x20, 0x20,
+  0x95, 0x95, 0x55, 0xCB, 0x90, 0x90, 0x70, 0x90,
+  0x90, 0x90, 0xCB, 0xCB, 0xCB, 0xCB, 0x55, 0x95,
+  0x95, 0x55, 0x55, 0x95, 0x95, 0x2C, 0x2C, 0x2C,
+  0x95, 0x95, 0x55, 0x55, 0x55, 0x95, 0x95, 0x55,
+  0x90, 0x47, 0xA0, 0x55, 0x20, 0x2B, 0x43, 0x88,
+  0x6D, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0x6B, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0x28, 0x20,
+  0x20, 0x20, 0xE1, 0xE1, 0x20, 0x20, 0x20, 0x20,
+  0x28, 0x55, 0x90, 0x47, 0xA0, 0x47, 0x94, 0x70,
+  0x55, 0x95, 0x95, 0x55, 0xCB, 0x55, 0x55, 0x2C,
+  0x2C, 0x2C, 0x95, 0x95, 0x95, 0x2C, 0x2C, 0x2C,
+  0x95, 0x2C, 0x95, 0x95, 0x95, 0x95, 0x95, 0x55,
+  0x94, 0xE6, 0x70, 0x2B, 0x88, 0x2B, 0x88, 0xE1,
+  0x65, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0x6B, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0x47, 0x20,
+  0x20, 0x20, 0xE1, 0x34, 0x20, 0x20, 0x20, 0x20,
+  0xB1, 0x95, 0x94, 0xE6, 0xA0, 0x47, 0x70, 0x55,
+  0x2C, 0xA1, 0x2C, 0x55, 0x90, 0xCB, 0x2C, 0xD6,
+  0x6D, 0xA1, 0x2C, 0x95, 0x95, 0xA1, 0x2C, 0xA1,
+  0x2C, 0x2C, 0x95, 0x95, 0x95, 0x95, 0x95, 0x55,
+  0x70, 0xE6, 0x70, 0x20, 0x20, 0x7D, 0x20, 0x8A,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0x65, 0xA3, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0x94, 0x20,
+  0x20, 0x20, 0xD8, 0x88, 0x20, 0x20, 0x20, 0x20,
+  0xD8, 0x2C, 0x94, 0x47, 0x47, 0x90, 0x95, 0x95,
+  0xA1, 0x6D, 0xA1, 0x90, 0x94, 0x55, 0x2C, 0xD6,
+  0xD0, 0xA1, 0x95, 0x95, 0x2C, 0x2C, 0xA1, 0x2C,
+  0x95, 0x95, 0x55, 0x55, 0x55, 0x95, 0x2C, 0x2C,
+  0xCB, 0x95, 0xD8, 0x20, 0x20, 0xB1, 0x88, 0x28,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE2, 0xA3, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xCB, 0x20,
+  0x20, 0x20, 0x2B, 0x20, 0x20, 0x20, 0x20, 0x20,
+  0x88, 0xD6, 0x55, 0x47, 0x94, 0x55, 0x2C, 0xA1,
+  0xA1, 0xD6, 0x95, 0x94, 0x94, 0x55, 0xD6, 0x6D,
+  0xBF, 0x95, 0x90, 0xCB, 0x2C, 0x2C, 0x2C, 0x2C,
+  0x55, 0x95, 0xCB, 0x90, 0x90, 0x95, 0x2C, 0x95,
+  0x90, 0x70, 0x20, 0x20, 0x34, 0x8A, 0x20, 0x94,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0x65, 0x6B, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xCB, 0x20,
+  0x20, 0x88, 0x2B, 0x20, 0x20, 0x20, 0x20, 0x20,
+  0x88, 0xD6, 0xCB, 0x47, 0x94, 0x55, 0xA1, 0xD6,
+  0xD6, 0x2C, 0xCB, 0x47, 0x70, 0xA1, 0x6D, 0x2A,
+  0x95, 0x47, 0x47, 0x70, 0x95, 0xA1, 0x2C, 0x95,
+  0x55, 0x55, 0x90, 0x90, 0x55, 0x55, 0x55, 0x90,
+  0x47, 0xD5, 0x20, 0x20, 0x80, 0xD5, 0x43, 0xCB,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0x42, 0x6B, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xCB, 0x20,
+  0x20, 0x80, 0x34, 0x20, 0x20, 0x20, 0x88, 0x20,
+  0x20, 0x2C, 0x47, 0xE6, 0x70, 0x2C, 0xD6, 0xD6,
+  0xA1, 0x2C, 0x55, 0xCB, 0x95, 0xA1, 0x6D, 0xD6,
+  0x90, 0x47, 0x47, 0x90, 0x2C, 0xA1, 0x2C, 0x95,
+  0x55, 0x55, 0x90, 0x90, 0x55, 0x55, 0x55, 0x70,
+  0x94, 0x8A, 0x20, 0x88, 0x88, 0xE1, 0xD8, 0x95,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE2, 0x42, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0x47, 0x20,
+  0x43, 0x7D, 0x43, 0x80, 0x88, 0x20, 0x20, 0x20,
+  0x88, 0xCB, 0x94, 0x70, 0x55, 0xA1, 0xD6, 0xD6,
+  0xA1, 0x2C, 0x2C, 0x95, 0xA1, 0xA1, 0xD6, 0xA1,
+  0x94, 0xE6, 0x47, 0x55, 0x2C, 0xD6, 0xA1, 0x95,
+  0x55, 0x55, 0xCB, 0xCB, 0x55, 0x55, 0xCB, 0xCB,
+  0x55, 0xA0, 0x43, 0x86, 0x86, 0x43, 0xD8, 0xCB,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0x65, 0x6B, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0x3F, 0x80,
+  0xD8, 0x80, 0x88, 0x34, 0xD8, 0x2B, 0xD8, 0x20,
+  0x99, 0x90, 0x55, 0x95, 0x2C, 0xA1, 0xD6, 0xD6,
+  0xA1, 0x95, 0x95, 0x95, 0x2C, 0x2C, 0x2C, 0x2C,
+  0x94, 0x94, 0x70, 0x2C, 0xA1, 0xD6, 0xA1, 0x2C,
+  0x55, 0x55, 0xCB, 0x55, 0x55, 0x55, 0x55, 0x55,
+  0x95, 0x44, 0xBC, 0x3E, 0x5D, 0xD3, 0x79, 0x92,
+  0xA3, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0x65, 0x42, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0x65, 0x9A, 0x34,
+  0x20, 0x20, 0x20, 0x20, 0x20, 0x43, 0x99, 0xE1,
+  0x70, 0x55, 0x95, 0xA1, 0xD6, 0xD6, 0xD6, 0xA1,
+  0x2C, 0x95, 0x55, 0x55, 0x95, 0x95, 0x95, 0x95,
+  0x70, 0x70, 0x55, 0x2C, 0xD6, 0xD6, 0xA1, 0x95,
+  0x55, 0x90, 0xCB, 0xCB, 0x55, 0x55, 0x2C, 0x2C,
+  0x32, 0x9D, 0xEB, 0x5D, 0x69, 0x49, 0x84, 0xF0,
+  0xB1, 0xEC, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0x42, 0x6B, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xC1, 0x4E, 0x21, 0x20,
+  0x20, 0x20, 0x20, 0x20, 0x20, 0x34, 0xC9, 0xD8,
+  0xBB, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0x2C, 0x2C,
+  0x95, 0x55, 0x55, 0x55, 0x95, 0x95, 0x2C, 0x2C,
+  0x55, 0xCB, 0x95, 0x2C, 0xA1, 0xA1, 0x2C, 0x55,
+  0x90, 0x70, 0x90, 0x55, 0x95, 0x95, 0x6D, 0xD0,
+  0xC2, 0x48, 0x6A, 0x49, 0x69, 0x82, 0x5D, 0x2F,
+  0x59, 0x7D, 0xBF, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0x65, 0x6B, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xEA, 0xC7, 0x7E, 0x66,
+  0x20, 0x20, 0x20, 0x20, 0x20, 0x34, 0x43, 0x5A,
+  0x46, 0x27, 0xA1, 0xA1, 0xA1, 0xA1, 0x2C, 0x95,
+  0x95, 0x55, 0x95, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+  0x95, 0x90, 0x55, 0x2C, 0xA1, 0xA1, 0x95, 0x55,
+  0x94, 0x94, 0x2C, 0x2A, 0x72, 0x3B, 0x56, 0xDD,
+  0xDF, 0x29, 0x5D, 0x49, 0x89, 0x5D, 0x3E, 0x69,
+  0x93, 0x66, 0x34, 0xA1, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0x65, 0x42, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xEA, 0x3E, 0x5A, 0x66,
+  0x20, 0x20, 0x20, 0x20, 0x20, 0x66, 0x5B, 0x73,
+  0x89, 0x4C, 0xBF, 0x2C, 0x95, 0x2C, 0x2C, 0x95,
+  0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95,
+  0x2C, 0x70, 0x55, 0x2C, 0xD6, 0xD6, 0x2C, 0xCB,
+  0x70, 0x55, 0xE7, 0x60, 0x4A, 0x48, 0xCD, 0x4A,
+  0x29, 0x73, 0x5D, 0x82, 0x49, 0x49, 0x49, 0x49,
+  0x3A, 0x57, 0x88, 0x88, 0x70, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0x42, 0x73, 0x50, 0xBE, 0x79,
+  0x20, 0x20, 0x20, 0x20, 0x66, 0xCC, 0x37, 0x9C,
+  0x3E, 0xCE, 0xBF, 0x95, 0x95, 0x95, 0x2C, 0x95,
+  0x95, 0x55, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0x55,
+  0xA1, 0x55, 0x95, 0xA1, 0xD6, 0xA1, 0x55, 0x94,
+  0x94, 0xE8, 0x60, 0xC4, 0x3E, 0x2D, 0x2D, 0x2D,
+  0x33, 0x5D, 0x82, 0x49, 0x49, 0x49, 0x49, 0x49,
+  0x89, 0xAA, 0x59, 0x20, 0x20, 0x28, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xEC, 0x4A, 0x2D, 0x50, 0x78, 0x2E,
+  0x57, 0x51, 0xF0, 0x57, 0x31, 0x4D, 0x50, 0x2D,
+  0x5D, 0xF2, 0xA1, 0x2C, 0x95, 0x95, 0x55, 0x55,
+  0x90, 0x90, 0x70, 0x90, 0xCB, 0x55, 0x55, 0x55,
+  0x6D, 0x2C, 0xA1, 0xD6, 0xD6, 0xA1, 0x55, 0x94,
+  0x70, 0xB9, 0x75, 0x50, 0x3E, 0x49, 0x49, 0x49,
+  0x5D, 0x82, 0x49, 0x49, 0x82, 0x49, 0x49, 0x49,
+  0x89, 0x69, 0x4F, 0x20, 0x20, 0x20, 0x8A, 0x42,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0x83, 0x4A, 0x3A, 0x50, 0x62, 0x23,
+  0x81, 0xB8, 0xB8, 0xE9, 0x5F, 0x29, 0x33, 0x5D,
+  0x5D, 0x73, 0xE8, 0xCB, 0x55, 0x55, 0x55, 0x55,
+  0x55, 0x55, 0x95, 0x95, 0x2C, 0x2C, 0x2C, 0x2C,
+  0xD6, 0xA1, 0xA1, 0xA1, 0xA1, 0x55, 0x70, 0x70,
+  0xCB, 0x68, 0x75, 0x50, 0x82, 0x49, 0x49, 0x49,
+  0x5D, 0x49, 0x49, 0x5D, 0x49, 0x49, 0x5D, 0x82,
+  0x69, 0x5D, 0x25, 0xF0, 0x20, 0x20, 0x20, 0xE1,
+  0x2A, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0x4B, 0xF4, 0xDF, 0x50, 0x73, 0x76, 0x48,
+  0x75, 0xDF, 0x75, 0x62, 0xC4, 0x33, 0x82, 0x49,
+  0x5D, 0x5D, 0xA8, 0xF5, 0x55, 0x55, 0x55, 0x55,
+  0x2C, 0x2C, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1,
+  0x2C, 0x2C, 0x2C, 0x95, 0x95, 0xCB, 0x70, 0x70,
+  0x95, 0x83, 0x5F, 0xEA, 0x2D, 0x49, 0x49, 0x49,
+  0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49,
+  0x5D, 0x49, 0x22, 0x5A, 0x79, 0x20, 0x20, 0x20,
+  0x80, 0xD2, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0x65, 0xD0, 0x63, 0x5F, 0x29, 0x2D, 0x2D, 0xEA,
+  0x29, 0x29, 0x76, 0x50, 0x2D, 0x82, 0x49, 0x49,
+  0x3E, 0x49, 0x5C, 0xB0, 0xBA, 0x95, 0x55, 0x55,
+  0x2C, 0xA1, 0xD6, 0xD6, 0xD6, 0xA1, 0x2C, 0x2C,
+  0xA1, 0x95, 0x95, 0x55, 0xCB, 0x70, 0x70, 0x55,
+  0x2C, 0x83, 0x60, 0x76, 0x5D, 0x49, 0x49, 0x49,
+  0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49,
+  0x49, 0x5D, 0x89, 0xDC, 0x8B, 0x20, 0x20, 0x20,
+  0x20, 0x95, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE2, 0x32, 0x85, 0xE3, 0x29, 0x2D, 0x33, 0x2D,
+  0x2D, 0x2D, 0x6A, 0x2D, 0x33, 0x5D, 0x49, 0x82,
+  0x49, 0x49, 0x82, 0x73, 0x5C, 0x9E, 0x2C, 0x55,
+  0x2C, 0xA1, 0xD6, 0xA1, 0x2C, 0x2C, 0x95, 0x95,
+  0x2C, 0x95, 0x55, 0xCB, 0x90, 0x90, 0xCB, 0x95,
+  0x2C, 0x6D, 0x41, 0x6F, 0x3E, 0x49, 0x49, 0x49,
+  0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49,
+  0x49, 0x82, 0x3E, 0x4E, 0x38, 0xCA, 0x20, 0x20,
+  0x20, 0x55, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0x65,
+  0x42, 0xA0, 0xD4, 0xE3, 0x29, 0x2D, 0x82, 0x5D,
+  0x5D, 0x82, 0x82, 0x49, 0x49, 0x49, 0x49, 0x49,
+  0x49, 0x3E, 0x49, 0x49, 0x49, 0x5C, 0x56, 0xD6,
+  0xA1, 0xA1, 0xA1, 0x95, 0x55, 0x55, 0x55, 0x95,
+  0xA1, 0x55, 0x90, 0x70, 0x94, 0x70, 0x95, 0x2C,
+  0x2C, 0xD6, 0xDD, 0x6F, 0x33, 0x49, 0x49, 0x49,
+  0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49,
+  0x5D, 0x5D, 0x82, 0x69, 0x22, 0x62, 0x80, 0x34,
+  0x94, 0x6B, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0x65, 0xE5, 0x65, 0x6B,
+  0xD5, 0x88, 0x5B, 0xE3, 0x29, 0x5D, 0x5D, 0x5D,
+  0x5D, 0x5D, 0x5D, 0x5D, 0x49, 0x49, 0x49, 0x82,
+  0x49, 0x49, 0x89, 0x49, 0x82, 0x49, 0x71, 0xBA,
+  0x6D, 0x6D, 0xA1, 0x95, 0x55, 0xCB, 0x55, 0x55,
+  0x2C, 0x55, 0x70, 0x70, 0x70, 0x90, 0x95, 0xA1,
+  0x2C, 0xA1, 0x41, 0x76, 0x5D, 0x5D, 0x49, 0x49,
+  0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49,
+  0x49, 0x5D, 0x82, 0x5D, 0x89, 0x5E, 0x96, 0x65,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0xE5, 0xE5, 0xE5, 0xE5, 0x65, 0x65, 0xEC, 0xB1,
+  0x20, 0x20, 0xCA, 0x23, 0x29, 0x33, 0x49, 0x5D,
+  0x49, 0x82, 0x49, 0x49, 0x49, 0x49, 0x49, 0x82,
+  0x49, 0x82, 0x5D, 0x5D, 0x5D, 0x2D, 0x5C, 0x8F,
+  0x6D, 0xD6, 0x2C, 0x55, 0x90, 0xCB, 0x95, 0x95,
+  0x95, 0x55, 0x70, 0x94, 0x70, 0x55, 0x2C, 0xA1,
+  0x95, 0xE8, 0x5F, 0x76, 0x33, 0x5D, 0x49, 0x49,
+  0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49,
+  0x49, 0x49, 0x49, 0x49, 0x3E, 0x9C, 0x2F, 0x68,
+  0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
+  0x65, 0xE5, 0x65, 0xE5, 0x6B, 0x90, 0x80, 0x20,
+  0x20, 0x20, 0x4F, 0x81, 0x50, 0x3E, 0x49, 0x49,
+  0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49,
+  0x69, 0x69, 0x49, 0x5D, 0x2D, 0xC4, 0x46, 0xA3,
+  0xD6, 0x55, 0x70, 0x94, 0x94, 0x70, 0xCB, 0x55,
+  0x55, 0xCB, 0x70, 0x47, 0x70, 0x95, 0xA1, 0xA1,
+  0x95, 0xBD, 0x75, 0x2D, 0x33, 0x49, 0x49, 0x49,
+  0x49, 0x49, 0x5D, 0x49, 0x49, 0x49, 0x49, 0x49,
+  0x49, 0x49, 0x49, 0x49, 0x5D, 0x2D, 0xB5, 0xDB,
+  0xD6, 0x65, 0xE5, 0x65, 0xE5, 0xE5, 0x65, 0xE5,
+  0x65, 0x65, 0x6B, 0x95, 0x2B, 0x88, 0x20, 0x20,
+  0x20, 0x20, 0x8B, 0x81, 0x29, 0x33, 0x49, 0x49,
+  0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49,
+  0x49, 0x3E, 0x3E, 0x5E, 0x41, 0x97, 0x27, 0xD6,
+  0x55, 0x94, 0xE6, 0xE6, 0x47, 0x70, 0x55, 0x55,
+  0x94, 0x70, 0x94, 0x94, 0x70, 0x55, 0xA1, 0x2C,
+  0x6D, 0xC5, 0x39, 0x6A, 0x5D, 0x5D, 0x49, 0x49,
+  0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49,
+  0x49, 0x49, 0x49, 0x49, 0x3E, 0xEA, 0x30, 0x77,
+  0xE1, 0xC9, 0x94, 0x2C, 0xD6, 0xD6, 0xA1, 0x55,
+  0x47, 0x9F, 0x43, 0x20, 0x20, 0x20, 0x20, 0x20,
+  0x20, 0x80, 0x91, 0x81, 0x6A, 0x2D, 0x49, 0x49,
+  0x49, 0x5D, 0x5D, 0x49, 0x49, 0x5D, 0x5D, 0x82,
+  0xEB, 0x4A, 0x41, 0xC2, 0x8F, 0xF5, 0xA1, 0x55,
+  0x94, 0x28, 0xA0, 0x47, 0x70, 0x55, 0x95, 0x95,
+  0x47, 0x70, 0x70, 0x94, 0x90, 0x95, 0xA1, 0x2C,
+  0xE8, 0xA6, 0x39, 0x76, 0x50, 0x50, 0x2D, 0x2D,
+  0x3E, 0x3E, 0x5D, 0x3E, 0x5D, 0x5D, 0x49, 0x82,
+  0x49, 0x49, 0x49, 0x82, 0x82, 0x50, 0x75, 0xE0,
+  0x57, 0x20, 0x88, 0x88, 0x20, 0x20, 0x88, 0x20,
+  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+  0x20, 0x79, 0x91, 0x81, 0x76, 0x33, 0x49, 0x49,
+  0x5D, 0x82, 0x49, 0x49, 0x3E, 0x6A, 0xEA, 0x29,
+  0xDF, 0x97, 0xBF, 0x6D, 0x6D, 0xD6, 0x55, 0x47,
+  0x28, 0x28, 0x47, 0x70, 0x55, 0x95, 0x2C, 0x2C,
+  0x95, 0x95, 0x55, 0x90, 0x90, 0x95, 0xA1, 0xA1,
+  0xD6, 0x26, 0x45, 0x81, 0x5F, 0x30, 0x48, 0x6F,
+  0x6F, 0x29, 0x29, 0x6A, 0x2D, 0x2D, 0x5D, 0x49,
+  0x49, 0x49, 0x49, 0x49, 0x2D, 0x76, 0x6E, 0x77,
+  0x5B, 0x66, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+  0x20, 0x79, 0xA9, 0xB8, 0x39, 0x50, 0x5D, 0x5D,
+  0x5D, 0x5D, 0x3E, 0x2D, 0x29, 0x76, 0xCD, 0x37,
+  0xB9, 0xA1, 0xA1, 0x6D, 0x6D, 0x2C, 0x94, 0x28,
+  0xD5, 0xE6, 0x70, 0x55, 0x95, 0xA1, 0x2C, 0xA1,
+  0xBF, 0xA1, 0x95, 0xCB, 0x55, 0x95, 0xA1, 0x2C,
+  0x95, 0x83, 0xDE, 0x87, 0xB6, 0xBE, 0x40, 0x6E,
+  0x81, 0x81, 0x78, 0x78, 0x39, 0x6F, 0xEA, 0x2D,
+  0x2D, 0x33, 0x33, 0x33, 0x76, 0x30, 0x64, 0x54,
+  0x5B, 0x66, 0x20, 0x20, 0x66, 0x20, 0x88, 0x20,
+  0x20, 0x20, 0x88, 0x20, 0x20, 0x20, 0x20, 0x20,
+  0x88, 0x34, 0x8B, 0xF1, 0x23, 0x6F, 0x50, 0x2D,
+  0x2D, 0x6A, 0x29, 0x6F, 0x78, 0x84, 0x9B, 0xD2,
+  0x2C, 0x2C, 0xD6, 0x6D, 0x6D, 0x2C, 0x47, 0xA0,
+  0xE6, 0x70, 0x55, 0x95, 0x2C, 0xA1, 0xA1, 0xA1,
+  0xD2, 0x95, 0x55, 0xCB, 0x55, 0x2C, 0xD6, 0xA1,
+  0x95, 0x95, 0xA1, 0xD6, 0x6D, 0x6D, 0xBA, 0xF3,
+  0x8D, 0x36, 0x74, 0x36, 0xF1, 0xB8, 0x23, 0x78,
+  0x62, 0x4A, 0x29, 0x62, 0x23, 0xF1, 0x54, 0x31,
+  0x57, 0x2B, 0x90, 0x95, 0x2C, 0x2C, 0x2C, 0x2C,
+  0xA1, 0xA1, 0xA1, 0xA1, 0x2C, 0x2C, 0x2C, 0xCB,
+  0xE6, 0x7D, 0xCA, 0xB7, 0xB8, 0x75, 0x6F, 0x6F,
+  0x76, 0x6F, 0x78, 0x81, 0x53, 0xBD, 0x6D, 0x2C,
+  0x95, 0x95, 0xA1, 0x6D, 0xA1, 0x55, 0x94, 0xE6,
+  0x70, 0xCB, 0x55, 0x95, 0xA1, 0xD6, 0xD6, 0xA1,
+  0xD0, 0x94, 0x94, 0x90, 0x95, 0x2C, 0xD6, 0xA1,
+  0x95, 0x55, 0x2C, 0xA1, 0xD6, 0xA1, 0x95, 0x2C,
+  0xD6, 0x68, 0xAB, 0x6C, 0xA4, 0x77, 0x77, 0xAD,
+  0x40, 0x53, 0x6E, 0x40, 0xB7, 0x54, 0x31, 0xD7,
+  0xAC, 0xD6, 0x55, 0x55, 0x95, 0x95, 0x95, 0x55,
+  0x95, 0x2C, 0x2C, 0xA1, 0x95, 0x95, 0x2C, 0xA1,
+  0x6D, 0xD2, 0x7C, 0x54, 0xAD, 0x40, 0x6E, 0x81,
+  0x81, 0x6E, 0x36, 0xDA, 0xE8, 0xD6, 0xD6, 0x2C,
+  0x2C, 0x2C, 0xA1, 0xD6, 0x95, 0x90, 0x94, 0x47,
+  0x94, 0x94, 0x70, 0x55, 0x2C, 0xD6, 0xA1, 0x95,
+  0x95, 0x28, 0x47, 0x90, 0x95, 0x2C, 0xA1, 0x2C,
+  0x55, 0x95, 0x2C, 0xA1, 0xA1, 0x2C, 0x2C, 0x2C,
+  0x2C, 0xA1, 0x55, 0x70, 0x95, 0x2C, 0xB2, 0xB4,
+  0xC3, 0xC3, 0x54, 0x54, 0xA9, 0x31, 0xCA, 0x2A,
+  0x95, 0x90, 0x55, 0x95, 0x2C, 0xA1, 0x2C, 0x95,
+  0x95, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0xD6,
+  0x6D, 0x2A, 0xB2, 0x4F, 0x31, 0x2E, 0xE0, 0xAD,
+  0xB7, 0xC8, 0xB4, 0xF5, 0x2C, 0xA1, 0xA1, 0xA1,
+  0x95, 0x2C, 0xA1, 0x2C, 0x95, 0x70, 0x94, 0x94,
+  0x94, 0x94, 0x70, 0x95, 0xD6, 0xD6, 0x2C, 0x95,
+  0x94, 0x28, 0x47, 0xCB, 0x95, 0x2C, 0xA1, 0xA1,
+  0x95, 0x55, 0x2C, 0xA1, 0xD6, 0xA1, 0x95, 0x95,
+  0x95, 0x2C, 0x55, 0x70, 0x70, 0x70, 0x94, 0x2C,
+  0x63, 0xBB, 0xA5, 0xD7, 0xCA, 0xB3, 0x6D, 0x2C,
+  0x55, 0x55, 0x95, 0x2C, 0x2C, 0x2C, 0x95, 0x95,
+  0x95, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0xA1,
+  0xD6, 0x2C, 0x70, 0x95, 0xAC, 0xC0, 0xDB, 0xEF,
+  0xEF, 0xA2, 0xE8, 0x95, 0x95, 0xA1, 0xD6, 0xA1,
+  0x95, 0x55, 0x2C, 0x95, 0x55, 0x70, 0x70, 0x70,
+  0x94, 0x70, 0x55, 0xD6, 0x6D, 0x6D, 0x95, 0x55,
+  0x70, 0x47, 0x70, 0x95, 0x2C, 0x2C, 0x2C, 0xA1,
+  0x2C, 0x95, 0x2C, 0xA1, 0xD6, 0xA1, 0x95, 0x55,
+  0x55, 0x95, 0x55, 0x55, 0x55, 0x55, 0x55, 0x95,
+  0xA1, 0xF5, 0xBF, 0xBF, 0xA1, 0x95, 0x95, 0x95,
+  0x95, 0x55, 0x2C, 0x2C, 0x95, 0x55, 0x55, 0x95,
+  0x95, 0x95, 0xA1, 0xA1, 0xA1, 0xA1, 0x2C, 0xA1,
+  0x2C, 0x55, 0x70, 0x94, 0x90, 0x2C, 0x6D, 0x6D,
+  0x6D, 0xA1, 0x2C, 0x95, 0x2C, 0xA1, 0xD6, 0xA1,
+  0x2C, 0x55, 0x55, 0x95, 0x55, 0x55, 0x55, 0x55,
+  0x55, 0x95, 0xD6, 0x6D, 0xBF, 0xD6, 0x55, 0xCB,
+  0x55, 0x55, 0x55, 0x2C, 0x2C, 0x2C, 0x2C, 0xA1,
+  0xA1, 0x95, 0x2C, 0xA1, 0xA1, 0xA1, 0x2C, 0x95,
+  0x55, 0x95, 0x95, 0x2C, 0x2C, 0x2C, 0x2C, 0xA1,
+  0x6D, 0xBF, 0x6D, 0x2C, 0x55, 0x55, 0x95, 0x95,
+  0xCB, 0xCB, 0x55, 0x55, 0xCB, 0x55, 0x55, 0x95,
+  0x95, 0x2C, 0x2C, 0xA1, 0xA1, 0xA1, 0x2C, 0x2C,
+  0xA1, 0x95, 0xCB, 0xCB, 0x95, 0x95, 0x2C, 0x2C,
+  0x2C, 0xA1, 0x2C, 0x2C, 0x2C, 0xA1, 0xA1, 0x2C,
+  0x2C, 0x95, 0x55, 0x95, 0x95, 0x2C, 0x2C, 0x2C,
+  0x2C, 0xA1, 0x6D, 0xBF, 0x6D, 0xA1, 0x55, 0x55,
+  0x95, 0x95, 0x95, 0x95, 0x2C, 0x2C, 0x2C, 0x2C,
+  0x2C, 0x95, 0x95, 0x95, 0x2C, 0x2C, 0x2C, 0x95,
+  0x55, 0x95, 0x2C, 0x2C, 0xA1, 0xA1, 0xD6, 0xD6,
+  0x6D, 0x6D, 0xA1, 0x95, 0xCB, 0x55, 0x95, 0x55,
+  0x90, 0x70, 0xCB, 0xCB, 0x90, 0xCB, 0x95, 0x95,
+  0x2C, 0x2C, 0xA1, 0xD6, 0xA1, 0xA1, 0xA1, 0xA1,
+  0xA1, 0xA1, 0x2C, 0x95, 0x95, 0x2C, 0x2C, 0x2C,
+  0x2C, 0xA1, 0x2C, 0x95, 0x95, 0x95, 0x2C, 0x2C,
+  0x2C, 0x95, 0x55, 0x55, 0x2C, 0x2C, 0xA1, 0xA1,
+  0xD6, 0xD6, 0x6D, 0x6D, 0xA1, 0x55, 0xCB, 0x55
 };
+#endif
 
-#endif /* !__HAVE_ARCH_LINUX_LOGO */
+#else /* biglogo */
+#if 0
+#include <linux/biglogo.h>
+#else
+#include <linux/biglogo2.h>
+#endif
+#endif
 
-#ifndef __HAVE_ARCH_LINUX_LOGOBW
+#ifdef INCLUDE_LINUX_LOGOBW
 
-unsigned char linux_logo_bw[] __initdata = {
-    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xff, 0xf0, 0x0f, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xff, 0xcf, 0xf3, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xff, 0xbf, 0xfc, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xbf, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xfd, 0xff, 0xf3, 0xdf, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xfd, 0xff, 0xf7, 0xef, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xfd, 0xff, 0xff, 0xef, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xfb, 0xff, 0xff, 0xef, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xfb, 0xff, 0xff, 0xf7, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xfb, 0xff, 0xff, 0xf7, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xfb, 0xff, 0xff, 0xf7, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xfb, 0x9f, 0x87, 0xfb, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xfb, 0x0f, 0x03, 0xfb, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xfb, 0x67, 0x33, 0xfb, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xfb, 0xe7, 0x79, 0xfb, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xfb, 0xf7, 0x79, 0xfb, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xfb, 0xff, 0xf9, 0xf7, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xfb, 0x60, 0x3b, 0xf7, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xfb, 0x89, 0x07, 0xfb, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xfb, 0x00, 0x03, 0xfb, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xfb, 0x00, 0x0d, 0xfb, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xfb, 0x80, 0x33, 0xfd, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xfb, 0xc0, 0xc3, 0xfd, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xfb, 0xff, 0x0d, 0xdd, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xfb, 0x40, 0x31, 0xee, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xf7, 0x20, 0xc1, 0xee, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xf7, 0x1f, 0x00, 0xff, 0x7f, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xef, 0x00, 0x00, 0x7f, 0xbf, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xee, 0x00, 0x00, 0x7f, 0xbf, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xde, 0x00, 0x00, 0x7f, 0xdf, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xbc, 0x00, 0x00, 0x3f, 0xef, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0x7c, 0x00, 0x00, 0x3f, 0xf7, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0x7c, 0x00, 0x00, 0x1f, 0xf7, 0xff, 0xff,
-    0xff, 0xff, 0xfe, 0xff, 0x1c, 0x07, 0xdf, 0xfb, 0xff, 0xff,
-    0xff, 0xff, 0xfd, 0xfc, 0x08, 0x0f, 0xef, 0xfd, 0xff, 0xff,
-    0xff, 0xff, 0xfd, 0xf8, 0x00, 0x01, 0xef, 0xfd, 0xff, 0xff,
-    0xff, 0xff, 0xfb, 0xf0, 0x00, 0x00, 0x7f, 0xfe, 0xff, 0xff,
-    0xff, 0xff, 0xfb, 0xe0, 0x00, 0x00, 0x1f, 0xfe, 0xff, 0xff,
-    0xff, 0xff, 0xf7, 0xe0, 0x00, 0x00, 0x07, 0xbf, 0x7f, 0xff,
-    0xff, 0xff, 0xf7, 0xc0, 0x00, 0x00, 0x03, 0xbf, 0x7f, 0xff,
-    0xff, 0xff, 0xef, 0xc0, 0x00, 0x00, 0x03, 0xdf, 0xbf, 0xff,
-    0xff, 0xff, 0xef, 0x80, 0x00, 0x00, 0x03, 0xdf, 0xbf, 0xff,
-    0xff, 0xff, 0xdf, 0x80, 0x00, 0x00, 0x03, 0xdf, 0xbf, 0xff,
-    0xff, 0xff, 0xdf, 0x80, 0x00, 0x00, 0x01, 0xef, 0xdf, 0xff,
-    0xff, 0xff, 0xdf, 0x80, 0x00, 0x00, 0x01, 0xef, 0xdf, 0xff,
-    0xff, 0xff, 0xbf, 0x00, 0x20, 0x00, 0x01, 0xef, 0xdf, 0xff,
-    0xff, 0xff, 0xbf, 0x00, 0x20, 0x00, 0x01, 0xef, 0xdf, 0xff,
-    0xff, 0xff, 0xbf, 0x00, 0x20, 0x00, 0x01, 0xef, 0xdf, 0xff,
-    0xff, 0xff, 0xbf, 0x00, 0x20, 0x00, 0x01, 0xef, 0xdf, 0xff,
-    0xff, 0xff, 0xbf, 0x00, 0x20, 0x00, 0x03, 0x03, 0xdf, 0xff,
-    0xff, 0xff, 0xbf, 0x00, 0x20, 0x00, 0x02, 0xfd, 0xdf, 0xff,
-    0xff, 0xff, 0xa3, 0x80, 0x00, 0x00, 0x1f, 0xff, 0xdf, 0xff,
-    0xff, 0xff, 0xc1, 0xc0, 0x00, 0x00, 0x11, 0xff, 0x3f, 0xff,
-    0xff, 0xff, 0x80, 0xe0, 0x00, 0x00, 0x21, 0xfe, 0x3f, 0xff,
-    0xff, 0xff, 0x00, 0x70, 0x00, 0x00, 0x21, 0xfc, 0x3f, 0xff,
-    0xff, 0xfe, 0x00, 0x3c, 0x00, 0x00, 0x20, 0xf8, 0x3f, 0xff,
-    0xff, 0xf0, 0x00, 0x3e, 0x00, 0x00, 0x20, 0x00, 0x3f, 0xff,
-    0xff, 0xc0, 0x00, 0x1f, 0x00, 0x00, 0x20, 0x00, 0x3f, 0xff,
-    0xff, 0xc0, 0x00, 0x1f, 0x80, 0x00, 0x20, 0x00, 0x1f, 0xff,
-    0xff, 0xc0, 0x00, 0x0f, 0x80, 0x00, 0x20, 0x00, 0x07, 0xff,
-    0xff, 0xc0, 0x00, 0x07, 0x80, 0x00, 0x20, 0x00, 0x03, 0xff,
-    0xff, 0xc0, 0x00, 0x07, 0x80, 0x00, 0x60, 0x00, 0x01, 0xff,
-    0xff, 0xc0, 0x00, 0x02, 0x00, 0x00, 0xe0, 0x00, 0x01, 0xff,
-    0xff, 0xc0, 0x00, 0x01, 0x00, 0x01, 0xe0, 0x00, 0x01, 0xff,
-    0xff, 0xc0, 0x00, 0x00, 0x80, 0x07, 0xe0, 0x00, 0x03, 0xff,
-    0xff, 0xc0, 0x00, 0x00, 0x80, 0x3f, 0xe0, 0x00, 0x0f, 0xff,
-    0xff, 0xc0, 0x00, 0x00, 0x7f, 0xff, 0xc0, 0x00, 0x1f, 0xff,
-    0xff, 0xc0, 0x00, 0x00, 0x7f, 0xff, 0xc0, 0x00, 0x7f, 0xff,
-    0xff, 0xe0, 0x00, 0x00, 0x7f, 0xff, 0xc0, 0x00, 0xff, 0xff,
-    0xff, 0xfc, 0x00, 0x00, 0x7f, 0xff, 0xc0, 0x03, 0xff, 0xff,
-    0xff, 0xff, 0xc0, 0x00, 0x70, 0x00, 0xc0, 0x07, 0xff, 0xff,
-    0xff, 0xff, 0xfc, 0x00, 0x8f, 0xff, 0x20, 0x0f, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xe0, 0x1f, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+unsigned char linux_logo_bw[]  = {
+  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x3F,
+  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F,
+  0xFE, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+  0xFE, 0x3F, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF,
+  0xFF, 0xFF, 0xFE, 0x7F, 0xFF, 0xC7, 0xFF, 0xFF,
+  0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFF, 0xFF, 0xC3,
+  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFF,
+  0xFB, 0xE3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+  0xFD, 0xFF, 0xFF, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF,
+  0xFF, 0xFF, 0xF9, 0xFF, 0xFF, 0xF1, 0xFF, 0xFF,
+  0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xFF, 0xFF, 0xF1,
+  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xFF,
+  0xFF, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+  0xF9, 0xFF, 0xFF, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF,
+  0xFF, 0xFF, 0xF9, 0xCF, 0xC3, 0xF8, 0xFF, 0xFF,
+  0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0x87, 0x81, 0xF9,
+  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xA7,
+  0x99, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+  0xF9, 0xF3, 0xBC, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF,
+  0xFF, 0xFF, 0xF9, 0xE3, 0xBC, 0xF9, 0xFF, 0xFF,
+  0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xB0, 0x3C, 0xF9,
+  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xB0,
+  0x19, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+  0xF9, 0xC0, 0x03, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF,
+  0xFF, 0xFF, 0xF9, 0x80, 0x01, 0xF8, 0xFF, 0xFF,
+  0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0x80, 0x01, 0xF8,
+  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0x80,
+  0x01, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+  0xF9, 0xC0, 0x21, 0xD8, 0xFF, 0xFF, 0xFF, 0xFF,
+  0xFF, 0xFF, 0xF9, 0xB1, 0x80, 0xEC, 0xC0, 0x1F,
+  0xFF, 0xFF, 0xFF, 0xFF, 0xF1, 0x90, 0x00, 0xE4,
+  0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xF1, 0x8C,
+  0xC0, 0x7C, 0x04, 0x81, 0xFF, 0xFF, 0xFF, 0xFF,
+  0xE3, 0x80, 0x00, 0x7C, 0x40, 0x11, 0xFF, 0xFF,
+  0xFF, 0xFF, 0xE3, 0x80, 0x00, 0x7F, 0xD2, 0x29,
+  0xFF, 0xFF, 0xFF, 0xFF, 0x87, 0x00, 0x00, 0x3F,
+  0x80, 0x19, 0xFF, 0xFF, 0xFF, 0xFF, 0x0E, 0x00,
+  0x00, 0x3F, 0x80, 0x19, 0xFF, 0xFF, 0xFF, 0xFF,
+  0x1E, 0x00, 0x00, 0x1F, 0x80, 0x19, 0xFF, 0xFF,
+  0xFF, 0xFE, 0x1C, 0x00, 0x00, 0x1E, 0x80, 0x19,
+  0xFF, 0xFF, 0xFF, 0xFE, 0x3C, 0x00, 0x00, 0x1E,
+  0x80, 0x11, 0xFF, 0xFF, 0xFF, 0xFC, 0x7C, 0x00,
+  0x00, 0x0F, 0x80, 0x11, 0xFF, 0xFF, 0xFF, 0xFC,
+  0xF8, 0x00, 0x00, 0x0E, 0x80, 0x11, 0xFF, 0xFF,
+  0xFF, 0xFC, 0xF8, 0x00, 0x00, 0x06, 0x00, 0x11,
+  0xFF, 0xFF, 0xFF, 0xF8, 0xF8, 0x00, 0x00, 0x06,
+  0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xF9, 0xF0, 0x00,
+  0x00, 0x02, 0x00, 0x09, 0xFF, 0xFF, 0xFF, 0xF1,
+  0xF0, 0x00, 0x00, 0x02, 0x80, 0x10, 0xFF, 0xFF,
+  0xFF, 0xF1, 0xE0, 0x00, 0x00, 0x00, 0x97, 0x10,
+  0xFF, 0xFF, 0xFF, 0xE3, 0xE0, 0x00, 0x00, 0x00,
+  0xDF, 0xF0, 0xFF, 0xFF, 0xFF, 0xE3, 0xC0, 0x00,
+  0x00, 0x00, 0xFF, 0xF8, 0xFF, 0xFF, 0xFF, 0xC7,
+  0xC0, 0x00, 0x00, 0x01, 0xFF, 0xF8, 0xFF, 0xFF,
+  0xFF, 0xC7, 0x80, 0x00, 0x00, 0x01, 0xFF, 0xF8,
+  0xFF, 0xFF, 0xFF, 0x8F, 0x80, 0x00, 0x00, 0x01,
+  0xFF, 0xF8, 0xFF, 0xFF, 0xFF, 0x8F, 0x80, 0x00,
+  0x00, 0x01, 0xFF, 0xF8, 0xFF, 0xFF, 0xFF, 0x9F,
+  0x80, 0x00, 0x00, 0x01, 0xFF, 0xF8, 0xFF, 0xFF,
+  0xFF, 0x9F, 0x80, 0x00, 0x00, 0x01, 0x80, 0x18,
+  0xFF, 0xFF, 0xFF, 0x9E, 0x80, 0x00, 0x00, 0x03,
+  0xA8, 0x11, 0xFF, 0xFF, 0xFF, 0x9F, 0x80, 0x00,
+  0x00, 0x02, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0x99,
+  0x80, 0x00, 0x00, 0x00, 0x00, 0x09, 0xFF, 0xFF,
+  0xFF, 0x00, 0x80, 0x00, 0x00, 0x01, 0xC0, 0x01,
+  0xFF, 0xFF, 0xFE, 0x20, 0x60, 0x00, 0x00, 0x00,
+  0xFF, 0xC3, 0xFF, 0xFF, 0xF8, 0x00, 0x30, 0x00,
+  0x00, 0x00, 0xFF, 0x0F, 0xFF, 0xFF, 0xC0, 0x40,
+  0x38, 0x00, 0x00, 0x00, 0xFE, 0x47, 0xFF, 0xFF,
+  0x81, 0x00, 0x1C, 0x00, 0x00, 0x00, 0xFC, 0x23,
+  0xFF, 0xFF, 0x90, 0x00, 0x1E, 0x00, 0x00, 0x00,
+  0x78, 0x11, 0xFF, 0xFF, 0x80, 0x00, 0x0F, 0x80,
+  0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0x80, 0x00,
+  0x07, 0xC0, 0x00, 0x00, 0x00, 0x08, 0xFF, 0xFF,
+  0xC0, 0x00, 0x07, 0xC0, 0x00, 0x00, 0x00, 0x04,
+  0x7F, 0xFF, 0x80, 0x00, 0x03, 0xC0, 0x00, 0x10,
+  0x00, 0x00, 0x1F, 0xFF, 0x80, 0x00, 0x01, 0x80,
+  0x00, 0x30, 0x00, 0x00, 0x0F, 0xFF, 0x80, 0x00,
+  0x00, 0x00, 0x00, 0x70, 0x00, 0x01, 0x4F, 0xFF,
+  0x80, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00,
+  0x0F, 0xFF, 0xC0, 0x00, 0x00, 0x80, 0x03, 0xF0,
+  0x00, 0x00, 0x8F, 0xFF, 0x80, 0x00, 0x00, 0x40,
+  0x0F, 0xF0, 0x00, 0x04, 0x1F, 0xFF, 0x80, 0x00,
+  0x00, 0x7F, 0xFF, 0xF0, 0x00, 0x10, 0x1F, 0xFF,
+  0xC0, 0x00, 0x00, 0x7F, 0xFF, 0xF0, 0x00, 0x40,
+  0xFF, 0xFF, 0x98, 0x00, 0x00, 0xFF, 0xFF, 0xF0,
+  0x00, 0x83, 0xFF, 0xFF, 0x81, 0xE0, 0x01, 0xFF,
+  0xFF, 0xF8, 0x02, 0x07, 0xFF, 0xFF, 0x80, 0x3F,
+  0x07, 0xE0, 0x00, 0x1C, 0x0C, 0x1F, 0xFF, 0xFF,
+  0xF8, 0x03, 0xFF, 0x80, 0x00, 0x1F, 0x78, 0x1F,
+  0xFF, 0xFF, 0xFF, 0x80, 0x7F, 0x00, 0x07, 0x0F,
+  0xF0, 0x7F, 0xFF, 0xFF, 0xFF, 0xFE, 0x0C, 0x07,
+  0xFF, 0x83, 0xC0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+  0x00, 0x1F, 0xFF, 0xC0, 0x03, 0xFF, 0xFF, 0xFF,
+  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x07, 0xFF,
+  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
 };
 
-#endif /* !__HAVE_ARCH_LINUX_LOGOBW */
+#endif
 
-#ifndef __HAVE_ARCH_LINUX_LOGO16
+#ifdef INCLUDE_LINUX_LOGO16
 
-unsigned char linux_logo16[] __initdata = {
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x88, 0x88, 0x88, 0x80, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x88, 0x80, 0x00, 0x00, 0x08, 0x88, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
-    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0x00,
-    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x80,
-    0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
-    0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
-    0x08, 0x70, 0x00, 0x00, 0x00, 0x77, 0x70, 0x00,
-    0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
-    0x87, 0x77, 0x00, 0x00, 0x07, 0xff, 0xf7, 0x00,
-    0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08,
-    0x77, 0xff, 0x00, 0x00, 0x7f, 0x77, 0xf7, 0x00,
-    0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08,
-    0x70, 0x0f, 0x80, 0x00, 0xf7, 0x08, 0x7f, 0x70,
-    0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08,
-    0x80, 0x07, 0x80, 0x00, 0xf8, 0x00, 0x8f, 0x70,
-    0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08,
-    0x70, 0x07, 0x88, 0x88, 0xf8, 0x00, 0x8f, 0x70,
-    0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
-    0xf0, 0x06, 0xe6, 0xe6, 0xe6, 0x00, 0x8f, 0x00,
-    0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
-    0x77, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x77, 0x00,
-    0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
-    0x06, 0xe6, 0xe6, 0xe6, 0xe6, 0xe6, 0xe6, 0x00,
-    0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
-    0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x60,
-    0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x80,
-    0xe6, 0xe6, 0xe6, 0xe6, 0xe6, 0xe6, 0xe6, 0x60,
-    0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x80,
-    0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x66, 0x66, 0x80,
-    0x08, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x80,
-    0x86, 0xe6, 0xe6, 0xe6, 0x66, 0x66, 0x66, 0x80,
-    0x08, 0x78, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x80,
-    0x86, 0x66, 0x66, 0x66, 0x66, 0x66, 0x77, 0x70,
-    0x00, 0x77, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
-    0x87, 0x66, 0x66, 0x66, 0x66, 0x77, 0x77, 0x78,
-    0x00, 0x88, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
-    0x87, 0x76, 0x66, 0x66, 0x77, 0x77, 0xff, 0xf7,
-    0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x08,
-    0xff, 0x77, 0x77, 0x77, 0x77, 0xff, 0xff, 0xff,
-    0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x07,
-    0xff, 0x77, 0x77, 0x77, 0x7f, 0xff, 0xff, 0xff,
-    0x70, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x8f,
-    0xff, 0xf7, 0x77, 0x77, 0xff, 0xff, 0xff, 0xff,
-    0xf0, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x08, 0x7f,
-    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xf8, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0xff,
-    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xf7, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0xff,
-    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x87, 0xff,
-    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x87, 0x77,
-    0xff, 0xf7, 0x77, 0xff, 0xff, 0xff, 0x77, 0x77,
-    0x77, 0x78, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x77, 0x7f,
-    0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0x77,
-    0x77, 0x78, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x7f, 0xff,
-    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xf7, 0x77, 0x00, 0x08, 0x80, 0x00, 0x00, 0x80,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x80, 0x80, 0x08, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0x77, 0x80, 0x00, 0x08, 0x00, 0x00, 0x08,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x08, 0x00, 0x80, 0x07, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0x78, 0x00, 0x08, 0x80, 0x00, 0x08,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x08, 0x08, 0x00, 0x8f, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xf7, 0x08, 0x80, 0x80, 0x00, 0x08,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x08, 0x08, 0x08, 0x7f, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xf7, 0x08, 0x80, 0x80, 0x00, 0x00,
-    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x80, 0x08, 0x07, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0x80, 0x00, 0x08, 0x00, 0x00,
-    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x80, 0x80, 0x0f, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0x70, 0x00, 0x08, 0x00, 0x00,
-    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x08, 0x00, 0x80, 0x8f, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0x70, 0x00, 0x08, 0x00, 0x00,
-    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x08, 0x08, 0x00, 0x7f, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0x70, 0x00, 0x08, 0x00, 0x00,
-    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x80, 0x08, 0x00, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xf0, 0x00, 0x08, 0x00, 0x00,
-    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x08, 0x00, 0x08, 0x00, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xf0, 0x00, 0x08, 0x00, 0x00,
-    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x08, 0x00, 0x08, 0x08, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xf0, 0x00, 0x08, 0x00, 0x00,
-    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x08, 0x00, 0x08, 0x08, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xf0, 0x00, 0x08, 0x00, 0x00,
-    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x08, 0x00, 0x00, 0x88, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xf0, 0x00, 0x08, 0x00, 0x00,
-    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x08, 0x00, 0x00, 0x08, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xf0, 0x88, 0x88, 0x80, 0x00,
-    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x08, 0x06, 0xe6, 0x00, 0x8f, 0xff, 0xff, 0xff,
-    0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x08, 0x80,
-    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x6e, 0x6e, 0x60, 0x08, 0xff, 0xff, 0xff,
-    0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xe6, 0xe0, 0x00, 0x00, 0x00, 0x88,
-    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x06, 0xe6, 0xe6, 0xe6, 0x00, 0x8f, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0xfe, 0x6e, 0x60, 0x00, 0x00, 0x00, 0x00,
-    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x6e, 0x6e, 0x6e, 0x6e, 0x60, 0x08, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0xf6, 0xe6, 0xe0, 0x00, 0x00, 0x00, 0x06,
-    0xe6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xe6, 0xe6,
-    0xe6, 0xe6, 0xe6, 0xe6, 0xe0, 0x00, 0x8f, 0xff,
-    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0xfe, 0x6e, 0x60, 0x00, 0x00, 0x00, 0x0e,
-    0x6e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x6e, 0x6e, 0x6e,
-    0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x00, 0x08, 0xff,
-    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0x76, 0xe6, 0xe6, 0x00, 0x00, 0x00, 0xe6,
-    0xe6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0xe6, 0xe6,
-    0xe6, 0xe6, 0xe6, 0xe6, 0xe6, 0xe0, 0x00, 0x8f,
-    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xf7, 0x7e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e,
-    0x6e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x6e, 0x6e, 0x6e,
-    0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x60, 0x00, 0x08,
-    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xf7, 0x76, 0xe6, 0xe6, 0xe6, 0xe6, 0xe6, 0xe6,
-    0xe6, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0xe6, 0xe6,
-    0xe6, 0xe6, 0xe6, 0xe6, 0xe6, 0xe6, 0x00, 0x00,
-    0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xf7, 0x7e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e,
-    0x6e, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x6e, 0x6e, 0x6e,
-    0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x60, 0x00,
-    0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xf7, 0x76, 0xe6, 0xe6, 0xe6, 0xe6, 0xe6, 0xe6,
-    0xe6, 0xe6, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0xe6, 0xe6,
-    0xe6, 0xe6, 0xe6, 0xe6, 0xe6, 0xe6, 0xe0, 0x00,
-    0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xf7, 0x8e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e,
-    0x6e, 0x6e, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x6e, 0x6e, 0x6e,
-    0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x88,
-    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0x78, 0x86, 0xe6, 0xe6, 0xe6, 0xe6, 0xe6, 0xe6,
-    0xe6, 0xe6, 0xe6, 0xe6, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0xe6, 0xe6,
-    0xe6, 0xe6, 0xe6, 0xe6, 0xe6, 0xe6, 0xe6, 0xef,
-    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7,
-    0x80, 0x06, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e,
-    0x6e, 0x6e, 0x6e, 0x6e, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x6e, 0x6e, 0x6e,
-    0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e,
-    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x78,
-    0x00, 0x06, 0xe6, 0xe6, 0xe6, 0xe6, 0xe6, 0xe6,
-    0xe6, 0xe6, 0xe6, 0xe0, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0xe6, 0xe6,
-    0xe6, 0xe6, 0xe6, 0xe6, 0xe6, 0xe6, 0xe6, 0xe6,
-    0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x78, 0x80,
-    0x00, 0x06, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e,
-    0x6e, 0x6e, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x0e, 0x6e, 0x6e, 0x6e,
-    0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x66,
-    0x67, 0xff, 0xff, 0xff, 0xff, 0x78, 0x80, 0x00,
-    0x00, 0x86, 0xe6, 0xe6, 0xe6, 0xe6, 0xe6, 0xe6,
-    0xe6, 0xe6, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x06, 0xe6, 0xe6, 0xe6,
-    0xe6, 0xe6, 0xe6, 0xe6, 0xe6, 0xe6, 0xe6, 0xe6,
-    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x86, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e,
-    0x66, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x0e, 0x6e, 0x6e, 0x6e,
-    0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x66,
-    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x86, 0xe6, 0xe6, 0xe6, 0xe6, 0xe6, 0xe6,
-    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0xe6, 0xe6,
-    0xe6, 0xe6, 0xe6, 0xe6, 0xe6, 0xe6, 0xe6, 0xe6,
-    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x86, 0x6e, 0x6e, 0x6e, 0x6e, 0x66, 0x66,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66,
-    0x66, 0x66, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x66,
-    0x60, 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80,
-    0x00, 0x06, 0x66, 0xe6, 0xe6, 0xe6, 0x66, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x66, 0x66, 0x66, 0x66, 0xe6, 0xe6, 0x66,
-    0x88, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
-    0x88, 0x86, 0x66, 0x6e, 0x6e, 0x66, 0x60, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x06, 0x66, 0x66, 0x66, 0x66,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x06, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x06, 0x66, 0x66, 0x60,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x66, 0x66, 0x66, 0x60, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+unsigned char linux_logo16_red[]  = {
+    0x00, 0x90, 0xb0, 0x9c, 0xf7, 0x35, 0x83, 0xa5,
+    0x65, 0x8f, 0x98, 0xc9, 0xdb, 0xe1, 0xe7, 0xf8
 };
 
-#endif /* !__HAVE_ARCH_LINUX_LOGO16 */
-
-#else /* !INCLUDE_LINUX_LOGO_DATA */
+unsigned char linux_logo16_green[]  = {
+    0x00, 0x90, 0xb0, 0x9c, 0xf7, 0x2e, 0x83, 0xa5,
+    0x65, 0x6e, 0x98, 0x89, 0xbf, 0xac, 0xda, 0xf8
+};
 
-/* prototypes only */
-extern unsigned char linux_logo_red[];
-extern unsigned char linux_logo_green[];
-extern unsigned char linux_logo_blue[];
-extern unsigned char linux_logo[];
-extern unsigned char linux_logo_bw[];
-extern unsigned char linux_logo16[];
+unsigned char linux_logo16_blue[]  = {
+    0x00, 0x90, 0xaf, 0x9c, 0xf7, 0x2b, 0x82, 0xa5,
+    0x65, 0x41, 0x97, 0x1e, 0x60, 0x29, 0xa5, 0xf8
+};
 
-#endif /* !INCLUDE_LINUX_LOGO_DATA */
+unsigned char linux_logo16[]  = {
+    0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
+    0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa1, 0x11, 0x11,
+    0x61, 0x16, 0x66, 0x66, 0x11, 0x11, 0x11, 0x11,
+    0x11, 0x11, 0x1a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
+    0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
+    0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
+    0xaa, 0xaa, 0xaa, 0xaa, 0x33, 0xa8, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x87, 0x77, 0x77, 0x77, 0x77,
+    0x77, 0x77, 0x73, 0x33, 0x33, 0x3a, 0xaa, 0xaa,
+    0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
+    0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
+    0xaa, 0xaa, 0xa3, 0x33, 0x33, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x77, 0x77, 0x77, 0x77,
+    0x77, 0x27, 0x77, 0x77, 0x77, 0x33, 0x3a, 0xaa,
+    0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
+    0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
+    0xaa, 0xa3, 0x33, 0x33, 0x30, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x55, 0x50, 0x08, 0x33, 0x77, 0x77,
+    0x77, 0x72, 0x72, 0x27, 0x77, 0x77, 0x33, 0x33,
+    0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
+    0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
+    0xa3, 0x33, 0x33, 0x77, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x58, 0x85, 0x00, 0x11, 0x11, 0xaa,
+    0xa3, 0x37, 0x77, 0x72, 0x22, 0x22, 0x77, 0x73,
+    0x33, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
+    0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa3,
+    0x33, 0x37, 0x77, 0x33, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x56, 0x85, 0x00, 0x06, 0x66, 0x11,
+    0x11, 0x1a, 0xa3, 0x37, 0x77, 0x72, 0x22, 0x77,
+    0x73, 0x33, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
+    0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x33,
+    0x33, 0x33, 0x33, 0x30, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x55, 0x00, 0x00, 0x06, 0x66, 0x66,
+    0x66, 0x66, 0x11, 0x1a, 0xa3, 0x77, 0x72, 0x22,
+    0x77, 0x73, 0x3a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
+    0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x33, 0x33,
+    0x33, 0x33, 0x33, 0xa0, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x11,
+    0x66, 0x66, 0x66, 0x66, 0x11, 0xa3, 0x77, 0x22,
+    0x22, 0x77, 0x33, 0x33, 0xaa, 0xaa, 0xaa, 0xaa,
+    0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x33, 0x33, 0x33,
+    0x33, 0x3a, 0xa1, 0x10, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x33,
+    0xaa, 0x11, 0x16, 0x66, 0x66, 0x61, 0x1a, 0x37,
+    0x22, 0x22, 0x77, 0x33, 0x3a, 0xaa, 0xaa, 0xaa,
+    0xaa, 0xaa, 0xaa, 0xaa, 0xa3, 0x33, 0x33, 0x33,
+    0x3a, 0xa1, 0x11, 0x10, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x02, 0x22,
+    0x22, 0x77, 0x3a, 0x11, 0x66, 0x66, 0x66, 0x1a,
+    0x37, 0x22, 0x22, 0x77, 0x33, 0x3a, 0xaa, 0xaa,
+    0xaa, 0xaa, 0xaa, 0xaa, 0x33, 0x33, 0x33, 0x3a,
+    0xa1, 0x11, 0x11, 0x10, 0x00, 0x00, 0x50, 0x00,
+    0x00, 0x05, 0x80, 0x50, 0x00, 0x00, 0x07, 0x72,
+    0x22, 0x22, 0x22, 0x73, 0xa1, 0x66, 0x66, 0x61,
+    0x1a, 0x77, 0x22, 0x27, 0x73, 0x33, 0xaa, 0xaa,
+    0xaa, 0xaa, 0xaa, 0xaa, 0x33, 0x33, 0x3a, 0xaa,
+    0x11, 0x11, 0x1a, 0xa0, 0x08, 0x71, 0x05, 0x00,
+    0x00, 0x12, 0x22, 0x50, 0x00, 0x00, 0x07, 0x77,
+    0x77, 0x72, 0x22, 0x22, 0x27, 0x31, 0x16, 0x66,
+    0x61, 0x13, 0x77, 0x22, 0x77, 0x33, 0x3a, 0xaa,
+    0xaa, 0xaa, 0xaa, 0xa3, 0x33, 0x33, 0xaa, 0xa1,
+    0x11, 0x1a, 0x33, 0x70, 0x07, 0x2e, 0x70, 0x00,
+    0x01, 0x44, 0x42, 0x60, 0x00, 0x00, 0x02, 0x22,
+    0x22, 0x22, 0x22, 0x22, 0x22, 0x27, 0x31, 0x66,
+    0x66, 0x61, 0xa3, 0x72, 0x22, 0x77, 0x33, 0xaa,
+    0xaa, 0xaa, 0xa3, 0x33, 0x33, 0xaa, 0xaa, 0x11,
+    0x1a, 0x33, 0x77, 0x30, 0x04, 0x82, 0x40, 0x00,
+    0x54, 0x48, 0x54, 0x40, 0x00, 0x00, 0x01, 0xaa,
+    0x32, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x31,
+    0x66, 0x66, 0x11, 0x37, 0x22, 0x27, 0x73, 0x3a,
+    0xaa, 0xaa, 0xa3, 0x33, 0x3a, 0xaa, 0xaa, 0xaa,
+    0xa3, 0x77, 0xaa, 0x10, 0x50, 0x08, 0x46, 0x05,
+    0x54, 0x80, 0x50, 0x42, 0x00, 0x00, 0x08, 0x66,
+    0x66, 0x1a, 0x32, 0x22, 0x22, 0x22, 0x22, 0x27,
+    0x31, 0x66, 0x66, 0x13, 0x72, 0x22, 0x77, 0x33,
+    0xaa, 0xaa, 0xaa, 0x33, 0xaa, 0xa1, 0xaa, 0xa3,
+    0x37, 0xa1, 0x1a, 0x30, 0x50, 0x06, 0x26, 0x00,
+    0x54, 0x00, 0x00, 0x44, 0x00, 0x00, 0x08, 0xe2,
+    0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0x22, 0x22,
+    0x27, 0xa6, 0x66, 0x61, 0xa7, 0x72, 0x27, 0x73,
+    0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x33,
+    0x31, 0x11, 0x37, 0x70, 0x02, 0x00, 0xab, 0xbb,
+    0xb6, 0x00, 0x00, 0xf4, 0x00, 0x00, 0xee, 0xee,
+    0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0x22,
+    0x22, 0x23, 0x16, 0x66, 0x1a, 0x37, 0x22, 0x77,
+    0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa3, 0x3a,
+    0x11, 0xa7, 0x33, 0x10, 0x04, 0x09, 0xbd, 0xdd,
+    0xbd, 0xd0, 0x04, 0x45, 0x00, 0x0e, 0xee, 0xee,
+    0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0x22,
+    0x22, 0x22, 0x71, 0x66, 0x66, 0x13, 0x72, 0x27,
+    0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x33, 0x11,
+    0xa3, 0x73, 0xa1, 0x60, 0x08, 0xbd, 0xdd, 0xdd,
+    0xdd, 0xdd, 0xdb, 0x90, 0x00, 0x02, 0xec, 0xee,
+    0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xce, 0x22,
+    0x22, 0x22, 0x27, 0xa6, 0x66, 0x61, 0x37, 0x27,
+    0x1a, 0xaa, 0xaa, 0xaa, 0xaa, 0xa3, 0xa1, 0x1a,
+    0x33, 0xa1, 0x16, 0x60, 0x0b, 0xbd, 0xdd, 0xdd,
+    0xcd, 0xdd, 0xdd, 0xd9, 0x00, 0x00, 0xec, 0xcc,
+    0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xce, 0xa2,
+    0x22, 0x22, 0x22, 0x7a, 0x66, 0x66, 0x13, 0x77,
+    0x1a, 0xaa, 0xaa, 0xaa, 0xaa, 0x3a, 0x11, 0x33,
+    0xaa, 0x11, 0x66, 0x60, 0x9b, 0xdd, 0xdd, 0xdd,
+    0xcd, 0xdd, 0xdb, 0xb9, 0x00, 0x00, 0xec, 0xcc,
+    0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xee, 0x61,
+    0x72, 0x22, 0x22, 0x22, 0xa1, 0x66, 0x61, 0x37,
+    0x1a, 0xaa, 0xaa, 0xaa, 0xa3, 0xa1, 0x13, 0x3a,
+    0x11, 0x11, 0x11, 0x10, 0x5b, 0xdd, 0xdd, 0xdc,
+    0xdd, 0xdd, 0xbd, 0xd9, 0x00, 0x00, 0xec, 0xcc,
+    0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xee, 0x86,
+    0x17, 0x22, 0x22, 0x22, 0x23, 0x16, 0x66, 0xaa,
+    0xaa, 0xa3, 0x3a, 0xaa, 0xaa, 0x1a, 0x3a, 0xa1,
+    0x11, 0x11, 0x1a, 0x70, 0x05, 0xbd, 0xdd, 0xdd,
+    0xdb, 0x5b, 0xdd, 0xb0, 0x00, 0x60, 0x2e, 0xcc,
+    0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xe6, 0x88,
+    0x66, 0x32, 0x22, 0x22, 0x22, 0x36, 0x66, 0x11,
+    0x33, 0x33, 0x3a, 0xaa, 0x11, 0xaa, 0xaa, 0xa1,
+    0x11, 0x1a, 0x3a, 0x60, 0x02, 0x99, 0xbb, 0xb9,
+    0x9b, 0xbb, 0xbc, 0x22, 0x00, 0x86, 0x5e, 0xcc,
+    0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xe1, 0x68,
+    0x86, 0x63, 0x22, 0x22, 0x22, 0x2a, 0x66, 0x66,
+    0x33, 0x33, 0xaa, 0xaa, 0x1a, 0xaa, 0xaa, 0x11,
+    0x1a, 0xa7, 0x68, 0x80, 0x02, 0x2b, 0xbd, 0xbb,
+    0xbb, 0xb9, 0x22, 0x22, 0x00, 0x06, 0x6e, 0xcc,
+    0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xc7, 0xa6,
+    0x88, 0x86, 0x32, 0x22, 0x22, 0x27, 0xa6, 0x66,
+    0x33, 0x3a, 0xaa, 0xa1, 0xaa, 0xaa, 0xa1, 0x11,
+    0xa3, 0xa6, 0x88, 0x80, 0x02, 0x22, 0x9b, 0xbb,
+    0xbb, 0x22, 0x24, 0xf4, 0x60, 0x00, 0x0c, 0xcc,
+    0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xc2, 0x21,
+    0x68, 0x88, 0x63, 0x22, 0x22, 0x22, 0x71, 0x66,
+    0x33, 0x3a, 0x11, 0x11, 0xaa, 0xaa, 0x11, 0xaa,
+    0x71, 0x88, 0x88, 0x00, 0x02, 0xe2, 0x26, 0x99,
+    0x22, 0x22, 0x4f, 0xf4, 0x40, 0x00, 0x0c, 0xcc,
+    0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x22, 0x22,
+    0x16, 0x88, 0x86, 0xa2, 0x22, 0x22, 0x27, 0x11,
+    0x33, 0xa1, 0x11, 0x11, 0xaa, 0x31, 0x1a, 0xa3,
+    0x68, 0x88, 0x81, 0x00, 0x54, 0x42, 0x22, 0x22,
+    0x22, 0x44, 0xff, 0xff, 0x48, 0x00, 0x00, 0x99,
+    0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0x99, 0x22, 0x22,
+    0x21, 0x88, 0x88, 0x6a, 0x22, 0x22, 0x22, 0x31,
+    0x3a, 0xa1, 0x11, 0x1a, 0xa3, 0x11, 0x33, 0x36,
+    0x88, 0x86, 0x30, 0x00, 0x4f, 0x44, 0x22, 0x22,
+    0x24, 0xff, 0xff, 0xff, 0x44, 0x00, 0x00, 0x99,
+    0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0x95, 0x22, 0x72,
+    0x22, 0x18, 0x88, 0x86, 0x32, 0x22, 0x22, 0x27,
+    0xaa, 0x11, 0x11, 0x1a, 0x31, 0x13, 0x33, 0x68,
+    0x88, 0x6a, 0x00, 0x02, 0x4f, 0x4f, 0x42, 0x24,
+    0x4f, 0xff, 0xff, 0xff, 0xf4, 0x50, 0x00, 0x99,
+    0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0x99, 0x22, 0x73,
+    0x72, 0x26, 0x88, 0x88, 0x63, 0x22, 0x22, 0x22,
+    0x11, 0x11, 0x11, 0xa3, 0xa1, 0x73, 0xa6, 0x88,
+    0x81, 0xa5, 0x00, 0x04, 0x4f, 0x4f, 0x44, 0x4f,
+    0xff, 0xff, 0xff, 0xff, 0xf4, 0x40, 0x00, 0x99,
+    0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0x99, 0x12, 0x27,
+    0xaa, 0x22, 0x68, 0x55, 0x86, 0x72, 0x22, 0x22,
+    0x11, 0x11, 0x1a, 0x33, 0x13, 0x3a, 0x18, 0x88,
+    0x1a, 0x10, 0x00, 0x44, 0x4f, 0x4f, 0xff, 0x4f,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x99,
+    0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0x99, 0x61, 0x22,
+    0x3a, 0xa2, 0x26, 0x85, 0x58, 0x67, 0x22, 0x22,
+    0x61, 0x61, 0x1a, 0x7a, 0x37, 0x31, 0x88, 0x81,
+    0x11, 0x00, 0x05, 0xe4, 0x44, 0xff, 0xff, 0xff,
+    0x4f, 0xf4, 0x44, 0xff, 0xff, 0xf5, 0x00, 0x99,
+    0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0x99, 0x88, 0x12,
+    0x2a, 0xaa, 0x72, 0x68, 0x55, 0x81, 0x22, 0x22,
+    0x66, 0x61, 0xa3, 0x33, 0x73, 0x16, 0x88, 0x11,
+    0x10, 0x00, 0x08, 0x74, 0x44, 0x4f, 0x44, 0x44,
+    0xf4, 0xf4, 0x44, 0x44, 0xe2, 0x44, 0x00, 0x99,
+    0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0x99, 0x88, 0x81,
+    0x22, 0xaa, 0xa7, 0x26, 0x85, 0x88, 0x12, 0x22,
+    0x66, 0x61, 0x37, 0xa7, 0x3a, 0x66, 0x66, 0x11,
+    0x80, 0x00, 0x0a, 0x72, 0x44, 0x4f, 0x44, 0x4f,
+    0xff, 0x44, 0x44, 0x22, 0x22, 0x24, 0x00, 0x99,
+    0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0x99, 0x85, 0x88,
+    0x12, 0x2a, 0xaa, 0x22, 0x68, 0x58, 0x63, 0x22,
+    0x66, 0x1a, 0x73, 0x77, 0x31, 0x66, 0x61, 0x11,
+    0x00, 0x00, 0x07, 0x44, 0xff, 0x4f, 0xf4, 0x4f,
+    0xff, 0x4f, 0x44, 0xf4, 0x42, 0x22, 0x40, 0x9b,
+    0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xb9, 0x85, 0x55,
+    0x81, 0x27, 0xaa, 0xa2, 0x78, 0x88, 0x86, 0x72,
+    0x66, 0x13, 0x77, 0x73, 0x11, 0x66, 0x61, 0x76,
+    0x00, 0x50, 0x84, 0xf4, 0xff, 0x4f, 0xf4, 0xff,
+    0xff, 0x4f, 0x44, 0xff, 0x4f, 0x42, 0x40, 0x9b,
+    0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xb9, 0x68, 0x55,
+    0x58, 0x12, 0x3a, 0xaa, 0x23, 0x88, 0x88, 0xa7,
+    0x66, 0xa7, 0x77, 0x7a, 0x16, 0x66, 0x1a, 0x15,
+    0x05, 0x00, 0x4f, 0xf4, 0xff, 0x4f, 0xf4, 0xff,
+    0xff, 0x4f, 0x44, 0xff, 0x4f, 0x44, 0x24, 0x9b,
+    0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xb9, 0x26, 0x55,
+    0x55, 0x81, 0x23, 0xaa, 0x32, 0x18, 0x88, 0x6a,
+    0x61, 0x37, 0x77, 0x31, 0x66, 0x66, 0x17, 0x60,
+    0x05, 0x08, 0x4f, 0xf4, 0xff, 0x4f, 0xf4, 0xff,
+    0xff, 0x4f, 0x44, 0xff, 0x4f, 0x4f, 0x4e, 0x99,
+    0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0x99, 0xa2, 0x65,
+    0x55, 0x58, 0xa2, 0x7a, 0xa2, 0x26, 0x88, 0x61,
+    0x61, 0x32, 0x27, 0xa1, 0x66, 0x61, 0x31, 0x60,
+    0x00, 0x04, 0x4f, 0xf4, 0xff, 0x44, 0x44, 0xff,
+    0xff, 0x4f, 0x44, 0xff, 0x4f, 0x44, 0xf4, 0x99,
+    0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0x9b, 0xaa, 0x26,
+    0x55, 0x55, 0x87, 0x27, 0x33, 0x27, 0x68, 0x61,
+    0x1a, 0x72, 0x27, 0xa6, 0x66, 0x6a, 0x71, 0x00,
+    0x80, 0x84, 0xff, 0xf4, 0xff, 0x44, 0x44, 0xff,
+    0xff, 0x4f, 0x44, 0xff, 0x4f, 0x44, 0xf4, 0x99,
+    0x9b, 0x9b, 0x99, 0xb9, 0xb9, 0x99, 0xaa, 0xa2,
+    0x85, 0x55, 0x56, 0x22, 0x27, 0x22, 0x36, 0x66,
+    0x13, 0x22, 0x23, 0x16, 0x86, 0x63, 0x73, 0x00,
+    0x00, 0x44, 0xf4, 0xf4, 0xff, 0x44, 0x44, 0xff,
+    0xff, 0x4f, 0x44, 0xff, 0x4f, 0x4f, 0x4f, 0x99,
+    0x9b, 0x99, 0x99, 0x99, 0xb9, 0x99, 0xaa, 0xaa,
+    0x28, 0x55, 0x58, 0x12, 0x22, 0x22, 0x21, 0x11,
+    0xa3, 0x27, 0x7a, 0x66, 0x86, 0x17, 0x75, 0x05,
+    0x05, 0xff, 0xf4, 0xf4, 0xff, 0x44, 0x44, 0xff,
+    0xff, 0x4f, 0x44, 0x4f, 0x4f, 0x44, 0x4f, 0x99,
+    0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x3a, 0xaa,
+    0xa2, 0x85, 0x58, 0x67, 0x72, 0x22, 0x27, 0xa1,
+    0x37, 0x27, 0x7a, 0x68, 0x86, 0xa2, 0x70, 0x00,
+    0x02, 0xff, 0xf4, 0xf4, 0xff, 0x44, 0x44, 0x4f,
+    0xff, 0x4f, 0x44, 0xf4, 0xf4, 0xf4, 0xf4, 0x99,
+    0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x23, 0xaa,
+    0xa7, 0x78, 0x88, 0x81, 0x77, 0x22, 0x27, 0x3a,
+    0x72, 0x73, 0x71, 0x68, 0x66, 0x32, 0x50, 0x00,
+    0x04, 0x4f, 0xf4, 0xf4, 0xff, 0x44, 0x44, 0x4f,
+    0xff, 0x4f, 0x44, 0xf4, 0xf4, 0xf4, 0x44, 0x95,
+    0x99, 0x99, 0x99, 0x99, 0x99, 0x55, 0x12, 0x3a,
+    0xaa, 0x21, 0x88, 0x81, 0x77, 0x27, 0x73, 0x73,
+    0x72, 0x33, 0x36, 0x86, 0x61, 0x72, 0x00, 0x00,
+    0x04, 0x44, 0xf4, 0xf4, 0xf4, 0x44, 0x44, 0x4f,
+    0xff, 0x4f, 0x44, 0xff, 0x4f, 0x4f, 0x44, 0x55,
+    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x8a, 0x27,
+    0xaa, 0x77, 0x68, 0x61, 0x23, 0x71, 0x11, 0x3a,
+    0x27, 0xa3, 0x36, 0x86, 0x61, 0x20, 0x00, 0x00,
+    0x04, 0xf4, 0xf4, 0xf4, 0xf4, 0x44, 0x44, 0x4f,
+    0xff, 0x4f, 0x44, 0xff, 0x4f, 0x4f, 0x41, 0x59,
+    0x99, 0x99, 0x99, 0x99, 0x99, 0x95, 0x58, 0x77,
+    0x27, 0x32, 0x36, 0x63, 0x23, 0x71, 0x66, 0x11,
+    0x27, 0x13, 0xa6, 0x86, 0x6a, 0x20, 0x00, 0x50,
+    0x04, 0x4f, 0x4f, 0x4f, 0x4f, 0x44, 0x44, 0x4f,
+    0xff, 0x4f, 0x44, 0xff, 0x4f, 0x4f, 0x41, 0x99,
+    0x9b, 0xbb, 0xbb, 0xbb, 0xb9, 0x99, 0x68, 0x13,
+    0x32, 0x22, 0x73, 0xa7, 0x2a, 0x31, 0x88, 0x66,
+    0x7a, 0x13, 0x18, 0x66, 0x63, 0x20, 0x00, 0x06,
+    0x0f, 0x4f, 0x4f, 0x4f, 0x4f, 0x44, 0x44, 0x4f,
+    0xff, 0x4f, 0x44, 0xff, 0x4f, 0x4f, 0x49, 0x95,
+    0xa9, 0xa9, 0x99, 0x97, 0x92, 0x99, 0x65, 0x6a,
+    0x17, 0x22, 0x23, 0x72, 0x27, 0xaa, 0x88, 0x88,
+    0xa1, 0x17, 0x68, 0x66, 0x67, 0x70, 0x00, 0x05,
+    0x0f, 0x4f, 0x4f, 0x4f, 0x4f, 0x44, 0x44, 0x4f,
+    0xff, 0x4f, 0x44, 0xff, 0xf4, 0xf4, 0x49, 0x9c,
+    0x2e, 0xee, 0xee, 0xee, 0xee, 0xa9, 0x65, 0x8a,
+    0x1a, 0xaa, 0x37, 0x72, 0x27, 0x37, 0x88, 0x88,
+    0x11, 0x17, 0x68, 0x66, 0x67, 0x10, 0x9d, 0xd0,
+    0x84, 0x44, 0xff, 0x4f, 0x4f, 0x44, 0xf4, 0x4f,
+    0xff, 0x4f, 0x44, 0xff, 0xf4, 0xf4, 0x4f, 0x69,
+    0xcc, 0xee, 0xee, 0xee, 0xec, 0x99, 0x88, 0x63,
+    0x61, 0x68, 0x61, 0x72, 0x22, 0x7a, 0x68, 0x88,
+    0x11, 0x17, 0x88, 0x66, 0x12, 0x1b, 0xdd, 0xdd,
+    0x02, 0x44, 0x4f, 0x4f, 0x4f, 0x44, 0x44, 0x4f,
+    0xff, 0x4f, 0x44, 0xff, 0xff, 0x4f, 0x4c, 0xc5,
+    0x0c, 0xc1, 0x11, 0x1c, 0xc0, 0x26, 0x66, 0x17,
+    0x66, 0x88, 0x88, 0x12, 0x22, 0x23, 0xa8, 0x88,
+    0x11, 0x13, 0x88, 0x66, 0x17, 0xbb, 0xdd, 0xdd,
+    0xd0, 0x8f, 0xff, 0xf4, 0xf4, 0x44, 0xf4, 0x4f,
+    0xff, 0x4f, 0x44, 0xf4, 0x4f, 0x44, 0xdd, 0xdd,
+    0x00, 0x00, 0x00, 0x05, 0x9d, 0x21, 0x66, 0x27,
+    0xa6, 0x65, 0x58, 0x67, 0x22, 0x27, 0x28, 0x88,
+    0x11, 0xaa, 0x86, 0x68, 0x1a, 0xbb, 0xdd, 0xdd,
+    0xdb, 0x05, 0xf4, 0xf4, 0xf4, 0xf4, 0x44, 0x4f,
+    0xff, 0x4f, 0x44, 0xf4, 0xf4, 0xf4, 0xdd, 0xdb,
+    0x00, 0x00, 0x00, 0x00, 0xdd, 0xda, 0x66, 0x22,
+    0x71, 0x15, 0x55, 0x81, 0x22, 0x22, 0x76, 0x88,
+    0x11, 0x31, 0x88, 0x88, 0xab, 0xbd, 0xdd, 0xdd,
+    0xdd, 0x00, 0x04, 0x44, 0xff, 0xff, 0x4f, 0x4f,
+    0xff, 0x4f, 0x44, 0xf4, 0xf4, 0x44, 0xdd, 0xdb,
+    0x00, 0x00, 0x00, 0x0b, 0xdd, 0xda, 0x11, 0x22,
+    0x23, 0x68, 0x55, 0x86, 0x22, 0x22, 0x7a, 0x88,
+    0x1a, 0x71, 0x88, 0x89, 0xbb, 0xdd, 0xdd, 0xdd,
+    0xdd, 0xd0, 0x00, 0x4f, 0x44, 0xff, 0x4f, 0x4f,
+    0xff, 0x4f, 0x44, 0xf4, 0xff, 0xe2, 0xdd, 0xdb,
+    0x90, 0x00, 0x05, 0xbd, 0xdd, 0xb8, 0x63, 0x22,
+    0x27, 0xa6, 0x55, 0x88, 0x77, 0x22, 0x22, 0x88,
+    0x1a, 0x28, 0xbd, 0xdb, 0xdd, 0xdd, 0xdd, 0xdd,
+    0xdd, 0xdb, 0x00, 0x07, 0x44, 0x4f, 0x4f, 0x4f,
+    0xff, 0x4f, 0x44, 0x4f, 0x4f, 0x22, 0xdd, 0xdb,
+    0xbb, 0x9b, 0xbb, 0xbd, 0xdd, 0xd5, 0x86, 0x22,
+    0x22, 0x77, 0x85, 0x88, 0x17, 0x22, 0x22, 0x88,
+    0xaa, 0x2b, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
+    0xdd, 0xdd, 0x00, 0x00, 0x54, 0x4f, 0x4f, 0x4f,
+    0xff, 0x4f, 0x44, 0xf4, 0x44, 0x22, 0xbd, 0xdd,
+    0xbb, 0xbb, 0xbb, 0xdd, 0xdd, 0xdd, 0x88, 0x72,
+    0x27, 0x22, 0x88, 0x88, 0x67, 0x72, 0x22, 0x18,
+    0x33, 0x2d, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
+    0xdd, 0xdd, 0xd0, 0x00, 0x05, 0x4f, 0x4f, 0x4f,
+    0xff, 0x4f, 0x44, 0x44, 0x4f, 0x22, 0xbd, 0xdd,
+    0xdb, 0xbb, 0xdd, 0xdd, 0xdd, 0xdd, 0x88, 0x17,
+    0x27, 0x72, 0x68, 0x88, 0x87, 0x32, 0x22, 0x36,
+    0x37, 0x2d, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
+    0xdd, 0xdd, 0xd5, 0x00, 0x00, 0x4f, 0x4f, 0x4f,
+    0xff, 0xf4, 0xf4, 0xf4, 0xf4, 0x22, 0xbb, 0xdd,
+    0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xd8, 0x67,
+    0x72, 0x77, 0x38, 0x88, 0x83, 0x37, 0x22, 0x26,
+    0x72, 0x2b, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
+    0xdd, 0xdd, 0xdd, 0x00, 0x00, 0x4f, 0x4f, 0x4f,
+    0xff, 0xf4, 0xf4, 0xf4, 0x44, 0x25, 0xbb, 0xdd,
+    0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xd3,
+    0x32, 0x73, 0x76, 0x88, 0x81, 0x33, 0x22, 0x2a,
+    0x22, 0x2b, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
+    0xdd, 0xdd, 0xdd, 0xb0, 0x54, 0x4f, 0x4f, 0x4f,
+    0xff, 0xf4, 0xf4, 0xff, 0x44, 0x00, 0xbb, 0xdd,
+    0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
+    0xa7, 0x73, 0x26, 0x88, 0x86, 0x7a, 0x72, 0x27,
+    0x22, 0x2b, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
+    0xdd, 0xdd, 0xdd, 0xdb, 0x44, 0xff, 0x4f, 0x4f,
+    0xff, 0xf4, 0xf4, 0x44, 0x40, 0x05, 0xbb, 0xdd,
+    0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
+    0x13, 0x23, 0x21, 0x68, 0x86, 0x17, 0x72, 0x22,
+    0x22, 0x2b, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
+    0xdd, 0xdd, 0xdd, 0xdb, 0x44, 0x4f, 0x4f, 0x4f,
+    0xff, 0xff, 0x44, 0x42, 0x00, 0x05, 0xbd, 0xdd,
+    0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
+    0x87, 0x27, 0x27, 0x16, 0x66, 0x67, 0x22, 0x22,
+    0x72, 0x7b, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
+    0xdd, 0xdd, 0xdd, 0xdd, 0x94, 0x44, 0x44, 0x44,
+    0x44, 0x44, 0x44, 0x00, 0x00, 0x05, 0xbb, 0xdd,
+    0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xb8,
+    0x86, 0x22, 0x22, 0x7a, 0x68, 0x81, 0x22, 0x22,
+    0x37, 0x7b, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
+    0xdd, 0xdd, 0xdd, 0xdb, 0xb5, 0x44, 0x44, 0x44,
+    0x44, 0x47, 0x00, 0x00, 0x00, 0x05, 0xbd, 0xdd,
+    0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xd8, 0x68,
+    0x58, 0x72, 0x22, 0x27, 0x18, 0x86, 0x72, 0x22,
+    0x1a, 0xbb, 0xbd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
+    0xdd, 0xdd, 0xdd, 0xdb, 0xb5, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0xbb, 0xdd,
+    0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xb9, 0x18, 0x85,
+    0x58, 0x12, 0x22, 0x36, 0x18, 0x88, 0x32, 0x22,
+    0x61, 0x3b, 0xbb, 0xbb, 0xbd, 0xdd, 0xdd, 0xdd,
+    0xdd, 0xdd, 0xdd, 0xdb, 0xb9, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0xbb, 0xdd,
+    0xdd, 0xdd, 0xdd, 0xdd, 0xb9, 0x7a, 0x68, 0x85,
+    0x88, 0x62, 0x27, 0x16, 0x18, 0x88, 0x12, 0x27,
+    0x86, 0x18, 0x9b, 0xbb, 0xbb, 0xbb, 0xbb, 0xbd,
+    0xdd, 0xdd, 0xdd, 0xbb, 0xb5, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0xbb, 0xbd,
+    0xdd, 0xdd, 0xdb, 0xbb, 0x87, 0x31, 0x68, 0x65,
+    0x88, 0x82, 0x23, 0x16, 0x18, 0x88, 0x12, 0x23,
+    0x88, 0x67, 0x27, 0xa8, 0x9b, 0xbb, 0xbb, 0xbb,
+    0xbd, 0xdd, 0xbb, 0xbb, 0x95, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x9b, 0xbb,
+    0xbb, 0xbb, 0xbb, 0x96, 0x87, 0x16, 0x68, 0x18,
+    0x88, 0x62, 0x31, 0x66, 0x18, 0x88, 0x62, 0x73,
+    0x88, 0x63, 0x27, 0x33, 0x65, 0x55, 0x99, 0x9b,
+    0xbb, 0xbb, 0xbb, 0x99, 0x55, 0x0a, 0xa1, 0x86,
+    0x81, 0x68, 0x88, 0x55, 0x58, 0x85, 0x9b, 0xbb,
+    0xbb, 0xbb, 0x95, 0x88, 0x83, 0x66, 0x66, 0x18,
+    0x66, 0x82, 0xa1, 0x66, 0x18, 0x88, 0x62, 0x33,
+    0x88, 0x81, 0x27, 0x7a, 0x18, 0x58, 0x86, 0x85,
+    0x99, 0x99, 0x99, 0x95, 0x53, 0x2a, 0xaa, 0x88,
+    0x67, 0x31, 0x68, 0x55, 0x58, 0x85, 0x59, 0xbb,
+    0xbb, 0xb9, 0x58, 0x68, 0x83, 0x66, 0x61, 0x16,
+    0x66, 0x62, 0x16, 0x66, 0x68, 0x88, 0x62, 0xaa,
+    0x88, 0x86, 0x27, 0x77, 0x78, 0x55, 0x88, 0x22,
+    0x25, 0x55, 0x95, 0x55, 0x6a, 0xa2, 0x2a, 0x88,
+    0x62, 0x27, 0x37, 0x38, 0x88, 0x87, 0x55, 0x59,
+    0x95, 0x58, 0x16, 0x88, 0x8a, 0x66, 0x63, 0x68,
+    0x86, 0x67, 0x66, 0x66, 0x68, 0x88, 0x12, 0x11,
+    0x88, 0x88, 0x72, 0x77, 0x78, 0x85, 0x58, 0x17,
+    0x23, 0x32, 0x55, 0x55, 0x81, 0x13, 0x73, 0x66,
+    0x62, 0x7a, 0xaa, 0x38, 0x88, 0x58, 0x27, 0x55,
+    0x58, 0x32, 0x38, 0x88, 0x81, 0x66, 0xa2, 0x88,
+    0x86, 0x61, 0x66, 0x61, 0x66, 0x68, 0x13, 0x11,
+    0x88, 0x88, 0x12, 0x22, 0x71, 0x85, 0x58, 0x62,
+    0x23, 0xa2, 0x68, 0x88, 0x81, 0x66, 0x88, 0x88,
+    0x63, 0x2a, 0xaa, 0x28, 0x88, 0x55, 0x86, 0x61,
+    0x66, 0x66, 0x68, 0x88, 0x66, 0x66, 0x77, 0x88,
+    0x68, 0x16, 0x66, 0x62, 0x66, 0x68, 0xa1, 0x61,
+    0x88, 0x88, 0x62, 0x22, 0x22, 0x85, 0x55, 0x83,
+    0x72, 0x37, 0xa8, 0x88, 0x61, 0x66, 0x85, 0x55,
+    0x86, 0x23, 0xaa, 0x71, 0x88, 0x85, 0x88, 0x66,
+    0x88, 0x86, 0x88, 0x88, 0x16, 0x61, 0x21, 0x88,
+    0x66, 0xa6, 0x86, 0x17, 0x66, 0x66, 0x31, 0x61,
+    0x88, 0x88, 0x87, 0x72, 0x22, 0x68, 0x55, 0x86,
+    0x77, 0x77, 0x36, 0x88, 0x13, 0x68, 0x85, 0x55,
+    0x58, 0x12, 0x73, 0x72, 0x76, 0x88, 0x88, 0x68,
+    0x88, 0x88, 0x88, 0x66, 0x36, 0x63, 0x26, 0x86,
+    0x86, 0x36, 0x86, 0x11, 0x66, 0x66, 0x76, 0x61,
+    0x88, 0x88, 0x81, 0x22, 0x22, 0x38, 0x85, 0x58,
+    0x37, 0x22, 0x21, 0x68, 0xa2, 0x31, 0x68, 0x55,
+    0x55, 0x81, 0x22, 0x22, 0xa8, 0x88, 0x88, 0x68,
+    0x86, 0x88, 0x68, 0x81, 0x36, 0x17, 0x21, 0x68,
+    0x86, 0x16, 0x66, 0x26, 0x66, 0x61, 0x36, 0x66,
+    0x68, 0x88, 0x86, 0x27, 0x22, 0x28, 0x88, 0x88,
+    0x17, 0x72, 0x2a, 0x66, 0xa2, 0x22, 0x36, 0x55,
+    0x55, 0x58, 0x37, 0x3a, 0x16, 0x66, 0x66, 0x66,
+    0x66, 0x18, 0x88, 0x67, 0x16, 0x12, 0x71, 0x68,
+    0x81, 0x68, 0x61, 0x76, 0x66, 0x6a, 0x16, 0x66,
+    0x88, 0x88, 0x86, 0x77, 0x22, 0x26, 0x88, 0x88,
+    0x13, 0x37, 0x71, 0x66, 0xa2, 0x33, 0x2a, 0x85,
+    0x55, 0x55, 0x17, 0x73, 0x16, 0x66, 0x66, 0x68,
+    0x63, 0x88, 0x88, 0xa2, 0x66, 0xa2, 0xa6, 0x88,
+    0x61, 0x68, 0x6a, 0x76, 0x66, 0x6a, 0x66, 0x6a
+};
 
+#endif
diff -urp linux/include/linux/miscdevice.h new_kernel_src/include/linux/miscdevice.h
--- linux/include/linux/miscdevice.h	2001-11-22 19:47:07.000000000 +0000
+++ new_kernel_src/include/linux/miscdevice.h	2002-03-25 05:31:07.000000000 +0000
@@ -21,6 +21,7 @@
 #define NVRAM_MINOR 144
 #define I2O_MINOR 166
 #define MICROCODE_MINOR		184
+#define MKBD_MINOR 196
 #define MWAVE_MINOR	219		/* ACP/Mwave Modem */
 #define MPT_MINOR	220
 #define MISC_DYNAMIC_MINOR 255
Only in new_kernel_src/include/linux: modules
Only in new_kernel_src/include/linux: modversions.h
diff -urp linux/include/linux/pc_keyb.h new_kernel_src/include/linux/pc_keyb.h
--- linux/include/linux/pc_keyb.h	1999-10-11 18:15:40.000000000 +0100
+++ new_kernel_src/include/linux/pc_keyb.h	2000-12-10 12:46:08.000000000 +0000
@@ -121,6 +121,8 @@ extern unsigned char aux_device_present;
 					   but then the read function would need
 					   a lock etc - ick */
 
+extern void (*scancode_handler)(unsigned char, int some_bool);
+
 struct aux_queue {
 	unsigned long head;
 	unsigned long tail;
diff -urp linux/include/linux/pci.h new_kernel_src/include/linux/pci.h
--- linux/include/linux/pci.h	2009-06-10 21:00:37.000000000 +0100
+++ new_kernel_src/include/linux/pci.h	2002-03-25 03:37:54.000000000 +0000
@@ -385,6 +385,8 @@ struct pci_dev {
 	int (*prepare)(struct pci_dev *dev);	/* ISAPnP hooks */
 	int (*activate)(struct pci_dev *dev);
 	int (*deactivate)(struct pci_dev *dev);
+  
+        int bridge_valid_bases;
 };
 
 #define pci_dev_g(n) list_entry(n, struct pci_dev, global_list)
diff -urp linux/include/linux/reiserfs_fs.h new_kernel_src/include/linux/reiserfs_fs.h
--- linux/include/linux/reiserfs_fs.h	2009-06-10 21:00:37.000000000 +0100
+++ new_kernel_src/include/linux/reiserfs_fs.h	2002-03-25 03:10:34.000000000 +0000
@@ -1,14 +1,6 @@
 /*
  * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
  */
-
-				/* this file has an amazingly stupid
-                                   name, yura please fix it to be
-                                   reiserfs.h, and merge all the rest
-                                   of our .h files that are in this
-                                   directory into it.  */
-
-
 #ifndef _LINUX_REISER_FS_H
 #define _LINUX_REISER_FS_H
 
@@ -52,10 +44,33 @@
 
 */
 
+/* NEW_GET_NEW_BUFFER will try to allocate new blocks better */
+/*#define NEW_GET_NEW_BUFFER*/
+#define OLD_GET_NEW_BUFFER
+
+/* if this is undefined, all inode changes get into stat data immediately, if it can be found in RAM */
+#define DIRTY_LATER
+
+/* enable journalling */
+#define ENABLE_JOURNAL
+
 #define USE_INODE_GENERATION_COUNTER
 
+
+#ifdef __KERNEL__
+
+#define REISERFS_CHECK
+
 #define REISERFS_PREALLOCATE
-#define PREALLOCATION_SIZE 8
+#endif
+
+/* if this is undefined, all inode changes get into stat data
+   immediately, if it can be found in RAM */
+#define DIRTY_LATER
+
+
+/*#define READ_LOCK_REISERFS*/
+
 
 /* n must be power of 2 */
 #define _ROUND_UP(x,n) (((x)+(n)-1u) & ~((n)-1u))
@@ -65,27 +80,7 @@
 // FIXME: do not change 4 by anything else: there is code which relies on that
 #define ROUND_UP(x) _ROUND_UP(x,8LL)
 
-/* debug levels.  Right now, CONFIG_REISERFS_CHECK means print all debug
-** messages.
-*/
-#define REISERFS_DEBUG_CODE 5 /* extra messages to help find/debug errors */ 
-
-/* assertions handling */
 
-/** always check a condition and panic if it's false. */
-#define RASSERT( cond, format, args... )					\
-if( !( cond ) ) 								\
-  reiserfs_panic( 0, "reiserfs[%i]: assertion " #cond " failed at "		\
-		  __FILE__ ":%i:" __FUNCTION__ ": " format "\n",		\
-		  in_interrupt() ? -1 : current -> pid, __LINE__ , ##args )
-
-#if defined( CONFIG_REISERFS_CHECK )
-#define RFALSE( cond, format, args... ) RASSERT( !( cond ), format, ##args )
-#else
-#define RFALSE( cond, format, args... ) do {;} while( 0 )
-#endif
-
-#define CONSTF __attribute__( ( const ) )
 /*
  * Disk Data Structures
  */
@@ -94,6 +89,7 @@ if( !( cond ) ) 								\
 /*                             SUPER BLOCK                                 */
 /***************************************************************************/
 
+#define CONSTF __attribute__( ( const ) )
 /*
  * Structure of super block on disk, a version of which in RAM is often accessed as s->u.reiserfs_sb.s_rs
  * the version in RAM is part of a larger structure containing fields never written to disk.
@@ -136,6 +132,13 @@ static inline int is_reiserfs_magic_stri
 #define NO_BALANCING_NEEDED  (-4)
 #define NO_MORE_UNUSED_CONTIGUOUS_BLOCKS (-5)
 
+//#define SCHEDULE_OCCURRED  	1
+//#define PATH_INCORRECT    	2
+
+//#define NO_DISK_SPACE        (-1)
+
+
+
 typedef unsigned long b_blocknr_t;
 typedef __u32 unp_t;
 
@@ -145,45 +148,30 @@ struct unfm_nodeinfo {
 };
 
 
-/* there are two formats of keys: 3.5 and 3.6
- */
-#define KEY_FORMAT_3_5 0
-#define KEY_FORMAT_3_6 1
+/* when reiserfs_file_write is called with a byte count >= MIN_PACK_ON_CLOSE,
+** it sets the inode to pack on close, and when extending the file, will only
+** use unformatted nodes.
+**
+** This is a big speed up for the journal, which is badly hurt by direct->indirect
+** conversions (they must be logged).
+*/
+#define MIN_PACK_ON_CLOSE		512
 
-/* there are two stat datas */
-#define STAT_DATA_V1 0
-#define STAT_DATA_V2 1
-
-/** this says about version of key of all items (but stat data) the
-    object consists of */
-#define get_inode_item_key_version( inode )                                    \
-    (((inode)->u.reiserfs_i.i_flags & i_item_key_version_mask) ? KEY_FORMAT_3_6 : KEY_FORMAT_3_5)
-
-#define set_inode_item_key_version( inode, version )                           \
-         ({ if((version)==KEY_FORMAT_3_6)                                      \
-                (inode)->u.reiserfs_i.i_flags |= i_item_key_version_mask;      \
-            else                                                               \
-                (inode)->u.reiserfs_i.i_flags &= ~i_item_key_version_mask; })
-
-#define get_inode_sd_version(inode)                                            \
-    (((inode)->u.reiserfs_i.i_flags & i_stat_data_version_mask) ? STAT_DATA_V2 : STAT_DATA_V1)
-
-#define set_inode_sd_version(inode, version)                                   \
-         ({ if((version)==STAT_DATA_V2)                                        \
-                (inode)->u.reiserfs_i.i_flags |= i_stat_data_version_mask;     \
-            else                                                               \
-                (inode)->u.reiserfs_i.i_flags &= ~i_stat_data_version_mask; })
-
-/* This is an aggressive tail suppression policy, I am hoping it
-   improves our benchmarks. The principle behind it is that percentage
-   space saving is what matters, not absolute space saving.  This is
-   non-intuitive, but it helps to understand it if you consider that the
-   cost to access 4 blocks is not much more than the cost to access 1
-   block, if you have to do a seek and rotate.  A tail risks a
-   non-linear disk access that is significant as a percentage of total
-   time cost for a 4 block file and saves an amount of space that is
-   less significant as a percentage of space, or so goes the hypothesis.
-   -Hans */
+// this says about version of all items (but stat data) the object
+// consists of
+#define inode_items_version(inode) ((inode)->u.reiserfs_i.i_version)
+
+
+  /* This is an aggressive tail suppression policy, I am hoping it
+     improves our benchmarks. The principle behind it is that
+     percentage space saving is what matters, not absolute space
+     saving.  This is non-intuitive, but it helps to understand it if
+     you consider that the cost to access 4 blocks is not much more
+     than the cost to access 1 block, if you have to do a seek and
+     rotate.  A tail risks a non-linear disk access that is
+     significant as a percentage of total time cost for a 4 block file
+     and saves an amount of space that is less significant as a
+     percentage of space, or so goes the hypothesis.  -Hans */
 #define STORE_TAIL_IN_UNFM(n_file_size,n_tail_size,n_block_size) \
 (\
   (!(n_tail_size)) || \
@@ -224,60 +212,14 @@ struct unfm_nodeinfo {
 struct offset_v1 {
     __u32 k_offset;
     __u32 k_uniqueness;
-} __attribute__ ((__packed__));
+};
 
 struct offset_v2 {
-#ifdef __LITTLE_ENDIAN
-	    /* little endian version */
-	    __u64 k_offset:60;
-	    __u64 k_type: 4;
-#else
-	    /* big endian version */
-	    __u64 k_type: 4;
-	    __u64 k_offset:60;
-#endif
-} __attribute__ ((__packed__));
-
-#ifndef __LITTLE_ENDIAN
-typedef union {
-    struct offset_v2 offset_v2;
-    __u64 linear;
-} __attribute__ ((__packed__)) offset_v2_esafe_overlay;
+    __u64 k_offset:60;
+    __u64 k_type: 4;
+};
 
-static inline __u16 offset_v2_k_type( const struct offset_v2 *v2 )
-{
-    offset_v2_esafe_overlay tmp = *(const offset_v2_esafe_overlay *)v2;
-    tmp.linear = le64_to_cpu( tmp.linear );
-    return (tmp.offset_v2.k_type <= TYPE_MAXTYPE)?tmp.offset_v2.k_type:TYPE_ANY;
-}
- 
-static inline void set_offset_v2_k_type( struct offset_v2 *v2, int type )
-{
-    offset_v2_esafe_overlay *tmp = (offset_v2_esafe_overlay *)v2;
-    tmp->linear = le64_to_cpu(tmp->linear);
-    tmp->offset_v2.k_type = type;
-    tmp->linear = cpu_to_le64(tmp->linear);
-}
- 
-static inline loff_t offset_v2_k_offset( const struct offset_v2 *v2 )
-{
-    offset_v2_esafe_overlay tmp = *(const offset_v2_esafe_overlay *)v2;
-    tmp.linear = le64_to_cpu( tmp.linear );
-    return tmp.offset_v2.k_offset;
-}
 
-static inline void set_offset_v2_k_offset( struct offset_v2 *v2, loff_t offset ){
-    offset_v2_esafe_overlay *tmp = (offset_v2_esafe_overlay *)v2;
-    tmp->linear = le64_to_cpu(tmp->linear);
-    tmp->offset_v2.k_offset = offset;
-    tmp->linear = cpu_to_le64(tmp->linear);
-}
-#else
-# define offset_v2_k_type(v2)           ((v2)->k_type)
-# define set_offset_v2_k_type(v2,val)   (offset_v2_k_type(v2) = (val))
-# define offset_v2_k_offset(v2)         ((v2)->k_offset)
-# define set_offset_v2_k_offset(v2,val) (offset_v2_k_offset(v2) = (val))
-#endif
 
 /* Key of an item determines its location in the S+tree, and
    is composed of 4 components */
@@ -288,8 +230,8 @@ struct key {
     union {
 	struct offset_v1 k_offset_v1;
 	struct offset_v2 k_offset_v2;
-    } __attribute__ ((__packed__)) u;
-} __attribute__ ((__packed__));
+    } u;
+};
 
 
 struct cpu_key {
@@ -314,7 +256,7 @@ struct cpu_key {
 #define KEY_NOT_FOUND 0
 
 #define KEY_SIZE (sizeof(struct key))
-#define SHORT_KEY_SIZE (sizeof (__u32) + sizeof (__u32))
+#define SHORT_KEY_SIZE (sizeof (unsigned long) + sizeof (unsigned long))
 
 /* return values for search_by_key and clones */
 #define ITEM_FOUND 1
@@ -344,58 +286,39 @@ struct cpu_key {
 
 struct item_head
 {
-	/* Everything in the tree is found by searching for it based on
-	 * its key.*/
-	struct key ih_key; 	
-	union {
-		/* The free space in the last unformatted node of an
-		   indirect item if this is an indirect item.  This
-		   equals 0xFFFF iff this is a direct item or stat data
-		   item. Note that the key, not this field, is used to
-		   determine the item type, and thus which field this
-		   union contains. */
-		__u16 ih_free_space_reserved; 
-		/* Iff this is a directory item, this field equals the
-		   number of directory entries in the directory item. */
-		__u16 ih_entry_count; 
-	} __attribute__ ((__packed__)) u;
-	__u16 ih_item_len;           /* total size of the item body */
-	__u16 ih_item_location;      /* an offset to the item body
-				      * within the block */
-	__u16 ih_version;	     /* 0 for all old items, 2 for new
-					ones. Highest bit is set by fsck
-					temporary, cleaned after all
-					done */
-} __attribute__ ((__packed__));
+  struct key ih_key; 	/* Everything in the tree is found by searching for it based on its key.*/
+
+  union {
+    __u16 ih_free_space_reserved; /* The free space in the last unformatted node of an indirect item if this
+				     is an indirect item.  This equals 0xFFFF iff this is a direct item or
+				     stat data item. Note that the key, not this field, is used to determine
+				     the item type, and thus which field this union contains. */
+    __u16 ih_entry_count; /* Iff this is a directory item, this field equals the number of directory
+				      entries in the directory item. */
+  } u;
+  __u16 ih_item_len;           /* total size of the item body                  */
+  __u16 ih_item_location;      /* an offset to the item body within the block  */
+  __u16 ih_version;	       /* 0 for all old items, 2 for new
+                                  ones. Highest bit is set by fsck
+                                  temporary, cleaned after all done */
+};
 /* size of item header     */
 #define IH_SIZE (sizeof(struct item_head))
 
-#define ih_free_space(ih)            le16_to_cpu((ih)->u.ih_free_space_reserved)
-#define ih_version(ih)               le16_to_cpu((ih)->ih_version)
-#define ih_entry_count(ih)           le16_to_cpu((ih)->u.ih_entry_count)
-#define ih_location(ih)              le16_to_cpu((ih)->ih_item_location)
-#define ih_item_len(ih)              le16_to_cpu((ih)->ih_item_len)
-
-#define put_ih_free_space(ih, val)   do { (ih)->u.ih_free_space_reserved = cpu_to_le16(val); } while(0)
-#define put_ih_version(ih, val)      do { (ih)->ih_version = cpu_to_le16(val); } while (0)
-#define put_ih_entry_count(ih, val)  do { (ih)->u.ih_entry_count = cpu_to_le16(val); } while (0)
-#define put_ih_location(ih, val)     do { (ih)->ih_item_location = cpu_to_le16(val); } while (0)
-#define put_ih_item_len(ih, val)     do { (ih)->ih_item_len = cpu_to_le16(val); } while (0)
-
-
-#define unreachable_item(ih) (ih_version(ih) & (1 << 15))
-
-#define get_ih_free_space(ih) (ih_version (ih) == KEY_FORMAT_3_6 ? 0 : ih_free_space (ih))
-#define set_ih_free_space(ih,val) put_ih_free_space((ih), ((ih_version(ih) == KEY_FORMAT_3_6) ? 0 : (val)))
-
-/* these operate on indirect items, where you've got an array of ints
-** at a possibly unaligned location.  These are a noop on ia32
-** 
-** p is the array of __u32, i is the index into the array, v is the value
-** to store there.
-*/
-#define get_block_num(p, i) le32_to_cpu(get_unaligned((p) + (i)))
-#define put_block_num(p, i, v) put_unaligned(cpu_to_le32(v), (p) + (i))
+#define ih_free_space(ih) (le16_to_cpu ((ih)->u.ih_free_space_reserved))
+#define ih_version(ih) (le16_to_cpu ((ih)->ih_version))
+#define ih_entry_count(ih) (le16_to_cpu ((ih)->u.ih_entry_count))
+#define ih_location(ih) (le16_to_cpu ((ih)->ih_item_location))
+#define ih_item_len(ih) (le16_to_cpu ((ih)->ih_item_len))
+
+
+// FIXME: now would that work for other than i386 archs
+#define unreachable_item(ih) (ih->ih_version & (1 << 15))
+
+
+#define get_ih_free_space(ih) (ih_version (ih) == ITEM_VERSION_2 ? 0 : ih_free_space (ih))
+#define set_ih_free_space(ih,val) (ih_free_space (ih) = (ih_version (ih) == ITEM_VERSION_2 ? 0 : val))
+
 
 //
 // in old version uniqueness field shows key type
@@ -604,7 +527,6 @@ struct block_head {       
   __u16 blk_nr_item;      /* Number of keys/items in a block. */
   __u16 blk_free_space;   /* Block free space in bytes. */
   __u16 blk_reserved;
-				/* dump this in v4/planA */
   struct key  blk_right_delim_key; /* kept only for compatibility */
 };
 
@@ -624,34 +546,28 @@ struct block_head {       
  * values for blk_level field of the struct block_head
  */
 
-#define FREE_LEVEL 0 /* when node gets removed from the tree its
-			blk_level is set to FREE_LEVEL. It is then
+#define FREE_LEVEL 0 /* when node get removed off the tree - its
+			blk_level is set to FREE_LEVEL. It is them
 			used to see whether the node is still in the
 			tree */
 
 #define DISK_LEAF_NODE_LEVEL  1 /* Leaf node level.*/
 
 /* Given the buffer head of a formatted node, resolve to the block head of that node. */
-#define B_BLK_HEAD(p_s_bh)            ((struct block_head *)((p_s_bh)->b_data))
+#define B_BLK_HEAD(p_s_bh)  ((struct block_head *)((p_s_bh)->b_data))
 /* Number of items that are in buffer. */
-#define B_NR_ITEMS(p_s_bh)            (blkh_nr_item(B_BLK_HEAD(p_s_bh)))
-#define B_LEVEL(p_s_bh)               (blkh_level(B_BLK_HEAD(p_s_bh)))
-#define B_FREE_SPACE(p_s_bh)          (blkh_free_space(B_BLK_HEAD(p_s_bh)))
-
-#define PUT_B_NR_ITEMS(p_s_bh,val)    do { set_blkh_nr_item(B_BLK_HEAD(p_s_bh),val); } while (0)
-#define PUT_B_LEVEL(p_s_bh,val)       do { set_blkh_level(B_BLK_HEAD(p_s_bh),val); } while (0)
-#define PUT_B_FREE_SPACE(p_s_bh,val)  do { set_blkh_free_space(B_BLK_HEAD(p_s_bh),val); } while (0)
-
-
-/* Get right delimiting key. -- little endian */
-#define B_PRIGHT_DELIM_KEY(p_s_bh)   (&(blk_right_delim_key(B_BLK_HEAD(p_s_bh))
+#define B_NR_ITEMS(p_s_bh)	  	(le16_to_cpu ( B_BLK_HEAD(p_s_bh)->blk_nr_item ))
+#define B_LEVEL(bh)			(le16_to_cpu ( B_BLK_HEAD(bh)->blk_level ))
+#define B_FREE_SPACE(bh)		(le16_to_cpu ( B_BLK_HEAD(bh)->blk_free_space ))
+/* Get right delimiting key. */
+#define B_PRIGHT_DELIM_KEY(p_s_bh)	( &(B_BLK_HEAD(p_s_bh)->blk_right_delim_key) )
 
 /* Does the buffer contain a disk leaf. */
-#define B_IS_ITEMS_LEVEL(p_s_bh)     (B_LEVEL(p_s_bh) == DISK_LEAF_NODE_LEVEL)
+#define B_IS_ITEMS_LEVEL(p_s_bh)   	( B_BLK_HEAD(p_s_bh)->blk_level == DISK_LEAF_NODE_LEVEL )
 
 /* Does the buffer contain a disk internal node */
-#define B_IS_KEYS_LEVEL(p_s_bh)      (B_LEVEL(p_s_bh) > DISK_LEAF_NODE_LEVEL \
-                                            && B_LEVEL(p_s_bh) <= MAX_HEIGHT)
+#define B_IS_KEYS_LEVEL(p_s_bh) 	( B_BLK_HEAD(p_s_bh)->blk_level > DISK_LEAF_NODE_LEVEL &&\
+					  B_BLK_HEAD(p_s_bh)->blk_level <= MAX_HEIGHT )
 
 
 
@@ -678,7 +594,7 @@ struct stat_data_v1
     union {
 	__u32 sd_rdev;
 	__u32 sd_blocks;	/* number of blocks file uses */
-    } __attribute__ ((__packed__)) u;
+    } u;
     __u32 sd_first_direct_byte; /* first byte of file which is stored
 				   in a direct item: except that if it
 				   equals 1 it is a symlink and if it
@@ -688,7 +604,7 @@ struct stat_data_v1
 				   replace it with a macro based on
 				   sd_size and our tail suppression
 				   policy.  Someday.  -Hans */
-} __attribute__ ((__packed__));
+};
 
 #define SD_V1_SIZE              (sizeof(struct stat_data_v1))
 #define stat_data_v1(ih)        (ih_version (ih) == KEY_FORMAT_3_5)
@@ -772,8 +688,8 @@ struct stat_data {
 				       on me. Let's replace it with a macro
 				       based on sd_size and our tail
 				       suppression policy? */
-  } __attribute__ ((__packed__)) u;
-} __attribute__ ((__packed__));
+  } u;
+};
 //
 // this is 44 bytes long
 //
@@ -853,19 +769,8 @@ struct reiserfs_de_head
   __u16 deh_location;		/* offset of name in the whole item */
   __u16 deh_state;		/* whether 1) entry contains stat data (for future), and 2) whether
 					   entry is hidden (unlinked) */
-} __attribute__ ((__packed__));
-#define DEH_SIZE                  sizeof(struct reiserfs_de_head)
-#define deh_offset(p_deh)         (le32_to_cpu((p_deh)->deh_offset))
-#define deh_dir_id(p_deh)         (le32_to_cpu((p_deh)->deh_dir_id))
-#define deh_objectid(p_deh)       (le32_to_cpu((p_deh)->deh_objectid))
-#define deh_location(p_deh)       (le16_to_cpu((p_deh)->deh_location))
-#define deh_state(p_deh)          (le16_to_cpu((p_deh)->deh_state))
-
-#define put_deh_offset(p_deh,v)   ((p_deh)->deh_offset = cpu_to_le32((v)))
-#define put_deh_dir_id(p_deh,v)   ((p_deh)->deh_dir_id = cpu_to_le32((v)))
-#define put_deh_objectid(p_deh,v) ((p_deh)->deh_objectid = cpu_to_le32((v)))
-#define put_deh_location(p_deh,v) ((p_deh)->deh_location = cpu_to_le16((v)))
-#define put_deh_state(p_deh,v)    ((p_deh)->deh_state = cpu_to_le16((v)))
+};
+#define DEH_SIZE sizeof(struct reiserfs_de_head)
 
 /* empty directory contains two entries "." and ".." and their headers */
 #define EMPTY_DIR_SIZE \
@@ -877,48 +782,91 @@ struct reiserfs_de_head
 #define DEH_Statdata 0			/* not used now */
 #define DEH_Visible 2
 
-/* 64 bit systems (and the S/390) need to be aligned explicitly -jdm */
-#if BITS_PER_LONG == 64 || defined(__s390__) || defined(__hppa__)
-#   define ADDR_UNALIGNED_BITS  (3)
-#endif
 
-/* These are only used to manipulate deh_state.
- * Because of this, we'll use the ext2_ bit routines,
- * since they are little endian */
-#ifdef ADDR_UNALIGNED_BITS
-
-#   define aligned_address(addr)           ((void *)((long)(addr) & ~((1UL << ADDR_UNALIGNED_BITS) - 1)))
-#   define unaligned_offset(addr)          (((int)((long)(addr) & ((1 << ADDR_UNALIGNED_BITS) - 1))) << 3)
-
-#   define set_bit_unaligned(nr, addr)     ext2_set_bit((nr) + unaligned_offset(addr), aligned_address(addr))
-#   define clear_bit_unaligned(nr, addr)   ext2_clear_bit((nr) + unaligned_offset(addr), aligned_address(addr))
-#   define test_bit_unaligned(nr, addr)    ext2_test_bit((nr) + unaligned_offset(addr), aligned_address(addr))
+/* compose directory item containing "." and ".." entries (entries are
+   not aligned to 4 byte boundary) */
+/* the last four params are LE */
+static inline void make_empty_dir_item_v1 (char * body,
+                                           __u32 dirid, __u32 objid,
+					   __u32 par_dirid, __u32 par_objid)
+{
+    struct reiserfs_de_head * deh;
 
-#else
+    memset (body, 0, EMPTY_DIR_SIZE_V1);
+    deh = (struct reiserfs_de_head *)body;
+    
+    /* direntry header of "." */
+    deh[0].deh_offset = cpu_to_le32 (DOT_OFFSET);
+    deh[0].deh_dir_id = cpu_to_le32 (dirid);
+    deh[0].deh_objectid = cpu_to_le32 (objid);
+    deh[0].deh_location = cpu_to_le16 (EMPTY_DIR_SIZE_V1 - strlen ("."));
+    deh[0].deh_state = 0;
+    set_bit (DEH_Visible, &(deh[0].deh_state));
+  
+    /* direntry header of ".." */
+    deh[1].deh_offset = cpu_to_le32 (DOT_DOT_OFFSET);
+    /* key of ".." for the root directory */
+    deh[1].deh_dir_id = cpu_to_le32 (par_dirid);
+    deh[1].deh_objectid = cpu_to_le32 (par_objid);
+    deh[1].deh_location = cpu_to_le16 (le16_to_cpu (deh[0].deh_location) - strlen (".."));
+    deh[1].deh_state = 0;
+    set_bit (DEH_Visible, &(deh[1].deh_state));
+
+    /* copy ".." and "." */
+    memcpy (body + deh[0].deh_location, ".", 1);
+    memcpy (body + deh[1].deh_location, "..", 2);
+}
 
-#   define set_bit_unaligned(nr, addr)     ext2_set_bit(nr, addr)
-#   define clear_bit_unaligned(nr, addr)   ext2_clear_bit(nr, addr)
-#   define test_bit_unaligned(nr, addr)    ext2_test_bit(nr, addr)
 
-#endif
+/* compose directory item containing "." and ".." entries */
+static inline void make_empty_dir_item (char * body, __u32 dirid, __u32 objid,
+					__u32 par_dirid, __u32 par_objid)
+{
+    struct reiserfs_de_head * deh;
+
+    memset (body, 0, EMPTY_DIR_SIZE);
+    deh = (struct reiserfs_de_head *)body;
+    
+    /* direntry header of "." */
+    deh[0].deh_offset = cpu_to_le32 (DOT_OFFSET);
+    deh[0].deh_dir_id = cpu_to_le32 (dirid);
+    deh[0].deh_objectid = cpu_to_le32 (objid);
+    deh[0].deh_location = cpu_to_le16 (EMPTY_DIR_SIZE - ROUND_UP (strlen (".")));
+    deh[0].deh_state = 0;
+    set_bit (DEH_Visible, &(deh[0].deh_state));
+  
+    /* direntry header of ".." */
+    deh[1].deh_offset = cpu_to_le32 (DOT_DOT_OFFSET);
+    /* key of ".." for the root directory */
+    deh[1].deh_dir_id = cpu_to_le32 (par_dirid);
+    deh[1].deh_objectid = cpu_to_le32 (par_objid);
+    deh[1].deh_location = cpu_to_le16 (le16_to_cpu (deh[0].deh_location) - ROUND_UP (strlen ("..")));
+    deh[1].deh_state = 0;
+    set_bit (DEH_Visible, &(deh[1].deh_state));
+
+    /* copy ".." and "." */
+    memcpy (body + deh[0].deh_location, ".", 1);
+    memcpy (body + deh[1].deh_location, "..", 2);
+}
+
 
-#define mark_de_with_sd(deh)        set_bit_unaligned (DEH_Statdata, &((deh)->deh_state))
-#define mark_de_without_sd(deh)     clear_bit_unaligned (DEH_Statdata, &((deh)->deh_state))
-#define mark_de_visible(deh)	    set_bit_unaligned (DEH_Visible, &((deh)->deh_state))
-#define mark_de_hidden(deh)	    clear_bit_unaligned (DEH_Visible, &((deh)->deh_state))
-
-#define de_with_sd(deh)		    test_bit_unaligned (DEH_Statdata, &((deh)->deh_state))
-#define de_visible(deh)	    	    test_bit_unaligned (DEH_Visible, &((deh)->deh_state))
-#define de_hidden(deh)	    	    !test_bit_unaligned (DEH_Visible, &((deh)->deh_state))
-
-extern void make_empty_dir_item_v1 (char * body, __u32 dirid, __u32 objid,
-				    __u32 par_dirid, __u32 par_objid);
-extern void make_empty_dir_item (char * body, __u32 dirid, __u32 objid,
-				 __u32 par_dirid, __u32 par_objid);
+#define deh_dir_id(deh) (__le32_to_cpu ((deh)->deh_dir_id))
+#define deh_objectid(deh) (__le32_to_cpu ((deh)->deh_objectid))
+#define deh_offset(deh) (__le32_to_cpu ((deh)->deh_offset))
+
+
+#define mark_de_with_sd(deh)        set_bit (DEH_Statdata, &((deh)->deh_state))
+#define mark_de_without_sd(deh)     clear_bit (DEH_Statdata, &((deh)->deh_state))
+#define mark_de_visible(deh)	    set_bit (DEH_Visible, &((deh)->deh_state))
+#define mark_de_hidden(deh)	    clear_bit (DEH_Visible, &((deh)->deh_state))
+
+#define de_with_sd(deh)		    test_bit (DEH_Statdata, &((deh)->deh_state))
+#define de_visible(deh)	    	    test_bit (DEH_Visible, &((deh)->deh_state))
+#define de_hidden(deh)	    	    !test_bit (DEH_Visible, &((deh)->deh_state))
 
 /* array of the entry headers */
  /* get item body */
-#define B_I_PITEM(bh,ih) ( (bh)->b_data + ih_location(ih) )
+#define B_I_PITEM(bh,ih) ( (bh)->b_data + (ih)->ih_item_location )
 #define B_I_DEH(bh,ih) ((struct reiserfs_de_head *)(B_I_PITEM(bh,ih)))
 
 /* length of the directory entry in directory item. This define
@@ -953,9 +901,10 @@ static inline int entry_length (const st
 #define B_I_E_NAME(bh,ih,entry_num) ((char *)(bh->b_data + ih_location(ih) + deh_location(B_I_DEH(bh,ih)+(entry_num))))
 
 // two entries per block (at least)
-//#define REISERFS_MAX_NAME_LEN(block_size) 
-//((block_size - BLKH_SIZE - IH_SIZE - DEH_SIZE * 2) / 2)
-#define REISERFS_MAX_NAME_LEN(block_size) 255
+#define REISERFS_MAX_NAME_LEN(block_size) \
+((block_size - BLKH_SIZE - IH_SIZE - DEH_SIZE * 2) / 2)
+
+
 
 
 /* this structure is used for operations on directory entries. It is
@@ -1021,18 +970,13 @@ struct disk_child {
 };
 
 #define DC_SIZE (sizeof(struct disk_child))
-#define dc_block_number(dc_p)	(le32_to_cpu((dc_p)->dc_block_number))
-#define dc_size(dc_p)		(le16_to_cpu((dc_p)->dc_size))
-#define put_dc_block_number(dc_p, val)   do { (dc_p)->dc_block_number = cpu_to_le32(val); } while(0)
-#define put_dc_size(dc_p, val)   do { (dc_p)->dc_size = cpu_to_le16(val); } while(0)
 
 /* Get disk child by buffer header and position in the tree node. */
 #define B_N_CHILD(p_s_bh,n_pos)  ((struct disk_child *)\
 ((p_s_bh)->b_data+BLKH_SIZE+B_NR_ITEMS(p_s_bh)*KEY_SIZE+DC_SIZE*(n_pos)))
 
 /* Get disk child number by buffer header and position in the tree node. */
-#define B_N_CHILD_NUM(p_s_bh,n_pos) (dc_block_number(B_N_CHILD(p_s_bh,n_pos)))
-#define PUT_B_N_CHILD_NUM(p_s_bh,n_pos, val) (put_dc_block_number(B_N_CHILD(p_s_bh,n_pos), val ))
+#define B_N_CHILD_NUM(p_s_bh,n_pos) (le32_to_cpu (B_N_CHILD(p_s_bh,n_pos)->dc_block_number))
 
  /* maximal value of field child_size in structure disk_child */ 
  /* child size is the combined size of all items and their headers */
@@ -1081,16 +1025,7 @@ struct  path_element  {
    invalid, and this means we must check it when using it to see if it
    is still valid. You'll need to read search_by_key and the comments
    in it, especially about decrement_counters_in_path(), to understand
-   this structure.  
-
-Paths make the code so much harder to work with and debug.... An
-enormous number of bugs are due to them, and trying to write or modify
-code that uses them just makes my head hurt.  They are based on an
-excessive effort to avoid disturbing the precious VFS code.:-( The
-gods only know how we are going to SMP the code that uses them.
-znodes are the way! */
-
-
+   this structure. */
 struct  path {
   int                   path_length;                      	/* Length of the array above.   */
   struct  path_element  path_elements[EXTENDED_MAX_HEIGHT];	/* Array of the path elements.  */
@@ -1113,12 +1048,6 @@ struct path var = {ILLEGAL_PATH_ELEMENT_
 
 
 #define PATH_PLAST_BUFFER(p_s_path) (PATH_OFFSET_PBUFFER((p_s_path), (p_s_path)->path_length))
-				/* you know, to the person who didn't
-                                   write this the macro name does not
-                                   at first suggest what it does.
-                                   Maybe POSITION_FROM_PATH_END? Or
-                                   maybe we should just focus on
-                                   dumping paths... -Hans */
 #define PATH_LAST_POSITION(p_s_path) (PATH_OFFSET_POSITION((p_s_path), (p_s_path)->path_length))
 
 
@@ -1146,7 +1075,7 @@ struct path var = {ILLEGAL_PATH_ELEMENT_
 /***************************************************************************/
 
 /* Size of pointer to the unformatted node. */
-#define UNFM_P_SIZE (sizeof(unp_t))
+#define UNFM_P_SIZE (sizeof(unsigned long))
 
 // in in-core inode key is stored on le form
 #define INODE_PKEY(inode) ((struct key *)((inode)->u.reiserfs_i.i_key))
@@ -1453,8 +1382,7 @@ extern struct item_operations * item_ops
 /* indirect items consist of entries which contain blocknrs, pos
    indicates which entry, and B_I_POS_UNFM_POINTER resolves to the
    blocknr contained by the entry pos points to */
-#define B_I_POS_UNFM_POINTER(bh,ih,pos) le32_to_cpu(*(((unp_t *)B_I_PITEM(bh,ih)) + (pos)))
-#define PUT_B_I_POS_UNFM_POINTER(bh,ih,pos, val) do {*(((unp_t *)B_I_PITEM(bh,ih)) + (pos)) = cpu_to_le32(val); } while (0)
+#define B_I_POS_UNFM_POINTER(bh,ih,pos) (*(((unsigned long *)B_I_PITEM(bh,ih)) + (pos)))
 
 struct reiserfs_iget4_args {
     __u32 objectid ;
@@ -1495,10 +1423,34 @@ struct reiserfs_journal_commit {
 struct reiserfs_journal_header {
   __u32 j_last_flush_trans_id ;		/* id of last fully flushed transaction */
   __u32 j_first_unflushed_offset ;      /* offset in the log of where to start replay after a crash */
-  __u32 j_mount_id ;
+  __u32 long j_mount_id ;
+} ;
+
+/* these are used to keep flush pages that contain converted direct items.
+** if the page is not flushed before the transaction that converted it
+** is committed, we risk losing data
+**
+** note, while a page is in this list, its counter is incremented.
+*/
+struct reiserfs_page_list {
+  struct reiserfs_page_list *next ;
+  struct reiserfs_page_list *prev ;
+  struct page *page ;
+  unsigned long blocknr ; /* block number holding converted data */
+
+  /* if a transaction writer has the page locked the flush_page_list
+  ** function doesn't need to (and can't) get the lock while flushing
+  ** the page.  do_not_lock needs to be set by anyone who calls journal_end
+  ** with a page lock held.  They have to look in the inode and see
+  ** if the inode has the page they have locked in the flush list.
+  **
+  ** this sucks.
+  */
+  int do_not_lock ; 
 } ;
 
 extern task_queue reiserfs_commit_thread_tq ;
+extern task_queue reiserfs_end_io_tq ;
 extern wait_queue_head_t reiserfs_commit_thread_wait ;
 
 /* biggest tunable defines are right here */
@@ -1506,16 +1458,15 @@ extern wait_queue_head_t reiserfs_commit
 #define JOURNAL_MAX_BATCH   900 /* max blocks to batch into one transaction, don't make this any bigger than 900 */
 #define JOURNAL_MAX_COMMIT_AGE 30 
 #define JOURNAL_MAX_TRANS_AGE 30
-#define JOURNAL_PER_BALANCE_CNT (3 * (MAX_HEIGHT-2) + 9)
+#define JOURNAL_PER_BALANCE_CNT 12   /* must be >= (5 + 2 * (MAX_HEIGHT-2) + 1) */
+#define JOURNAL_DEL_SIZE_LIMIT 40960 /* size in bytes of the max sized file to use cnodes while deleting */
 
-/* both of these can be as low as 1, or as high as you want.  The min is the
-** number of 4k bitmap nodes preallocated on mount. New nodes are allocated
-** as needed, and released when transactions are committed.  On release, if 
-** the current number of nodes is > max, the node is freed, otherwise, 
-** it is put on a free list for faster use later.
-*/
-#define REISERFS_MIN_BITMAP_NODES 10 
-#define REISERFS_MAX_BITMAP_NODES 100 
+#if 0
+/* hash funcs more or less stolen from buffer cache.  t is a pointer to the hash table */
+#define JHASHDEV(d) ((unsigned int) (d))
+#define _jhashfn(dev,block)  (((unsigned)(JHASHDEV(dev)^(block))) & 8191)
+#define journal_hash(t,dev,block) ((t)[_jhashfn((dev),(block))])
+#endif
 
 #define JBH_HASH_SHIFT 13 /* these are based on journal hash size of 8192 */
 #define JBH_HASH_MASK 8191
@@ -1533,11 +1484,6 @@ extern wait_queue_head_t reiserfs_commit
 */
 #define JOURNAL_BUFFER(j,n) ((j)->j_ap_blocks[((j)->j_start + (n)) % JOURNAL_BLOCK_COUNT])
 
-void reiserfs_commit_for_inode(struct inode *) ;
-void reiserfs_update_inode_transaction(struct inode *) ;
-void reiserfs_wait_on_write_block(struct super_block *s) ;
-void reiserfs_block_writes(struct reiserfs_transaction_handle *th) ;
-void reiserfs_allow_writes(struct super_block *s) ;
 void reiserfs_check_lock_depth(char *caller) ;
 void reiserfs_prepare_for_journal(struct super_block *, struct buffer_head *bh, int wait) ;
 void reiserfs_restore_prepared_buffer(struct super_block *, struct buffer_head *bh) ;
@@ -1565,20 +1511,18 @@ int reiserfs_add_page_to_flush_list(stru
 int reiserfs_remove_page_from_flush_list(struct reiserfs_transaction_handle *,
                                          struct inode *) ;
 
-int reiserfs_allocate_list_bitmaps(struct super_block *s, struct reiserfs_list_bitmap *, int) ;
-
-				/* why is this kerplunked right here? */
-static inline int reiserfs_buffer_prepared(const struct buffer_head *bh) {
-  if (bh && test_bit(BH_JPrepared, ( struct buffer_head * ) &bh->b_state))
+				/* Why is this kerplunked right here? -Hans */
+static inline int reiserfs_buffer_prepared(struct buffer_head *bh) {
+  if (bh && test_bit(BH_JPrepared, &bh->b_state))
     return 1 ;
   else
     return 0 ;
 }
 
 /* buffer was journaled, waiting to get to disk */
-static inline int buffer_journal_dirty(const struct buffer_head *bh) {
+static inline int buffer_journal_dirty(struct buffer_head *bh) {
   if (bh)
-    return test_bit(BH_JDirty_wait, ( struct buffer_head * ) &bh->b_state) ;
+    return test_bit(BH_JDirty_wait, &bh->b_state) ;
   else
     return 0 ;
 }
@@ -1679,7 +1623,6 @@ int reiserfs_cut_from_item (struct reise
 			    struct path * path,
 			    struct cpu_key * key,
 			    struct inode * inode,
-			    struct page *page,
 			    loff_t new_file_size);
 
 int reiserfs_delete_item (struct reiserfs_transaction_handle *th,
@@ -1688,12 +1631,17 @@ int reiserfs_delete_item (struct reiserf
 			  struct inode * inode, 
 			  struct buffer_head  * p_s_un_bh);
 
-void reiserfs_delete_solid_item (struct reiserfs_transaction_handle *th,
-                                                                struct key * key);
+
 void reiserfs_delete_object (struct reiserfs_transaction_handle *th, struct inode * p_s_inode);
 void reiserfs_do_truncate (struct reiserfs_transaction_handle *th, 
-			   struct  inode * p_s_inode, struct page *, 
-			   int update_timestamps);
+			   struct  inode * p_s_inode, int update_timestamps);
+//
+void reiserfs_vfs_truncate_file (struct  inode * p_s_inode);
+//void lock_inode_to_convert (struct inode * p_s_inode);
+//void unlock_inode_after_convert (struct inode * p_s_inode);
+//void increment_i_read_sync_counter (struct inode * p_s_inode);
+//void decrement_i_read_sync_counter (struct inode * p_s_inode);
+
 
 #define block_size(inode) ((inode)->i_sb->s_blocksize)
 #define file_size(inode) ((inode)->i_size)
@@ -1702,28 +1650,92 @@ void reiserfs_do_truncate (struct reiser
 #define tail_has_to_be_packed(inode) (!dont_have_tails ((inode)->i_sb) &&\
 !STORE_TAIL_IN_UNFM(file_size (inode), tail_size(inode), block_size (inode)))
 
+
+#define READ_TAIL_LOCK 1
+#define CONVERT_TAIL_LOCK 2
+
+#define is_tail_locked(inode) \
+(atomic_read(&((inode)->u.reiserfs_i.i_is_being_converted)))
+
+#define is_tail_read_locked(inode) \
+(atomic_read(&((inode)->u.reiserfs_i.i_is_being_converted)) == READ_TAIL_LOCK)
+
+#define is_tail_convert_locked(inode) \
+(atomic_read(&((inode)->u.reiserfs_i.i_is_being_converted)) == CONVERT_TAIL_LOCK)
+
+//extern signed long FASTCALL(schedule_timeout(signed long timeout));
+
+extern inline void wait_on_tail (struct inode * inode)
+{
+#ifdef REISERFS_CHECK    
+  //    schedule_timeout(10);
+#endif
+
+ repeat:
+    if (is_tail_locked (inode)) {
+	schedule ();
+	goto repeat;
+    }
+}
+
+
+extern inline void lock_tail (struct inode * inode, int mode)
+{
+#ifdef REISERFS_CHECK
+    if (is_tail_locked (inode))
+	BUG();
+#endif
+    atomic_set(&((inode)->u.reiserfs_i.i_is_being_converted), mode);
+}
+
+extern inline void unlock_tail (struct inode * inode)
+{
+#ifdef REISERFS_CHECK
+    if (!is_tail_locked (inode))
+	BUG();
+#endif
+    atomic_set(&((inode)->u.reiserfs_i.i_is_being_converted), 0);
+}
+
+
+/*
+int get_buffer_by_range (struct super_block * p_s_sb, struct key * p_s_range_begin, struct key * p_s_range_end, 
+			 struct buffer_head ** pp_s_buf, unsigned long * p_n_objectid);
+int get_buffers_from_range (struct super_block * p_s_sb, struct key * p_s_range_start, struct key * p_s_range_end, 
+                            struct buffer_head ** p_s_range_buffers,
+			    int n_max_nr_buffers_to_return);
+*/
+
 void padd_item (char * item, int total_length, int length);
 
-/* inode.c */
 
-void reiserfs_read_inode (struct inode * inode) ;
-void reiserfs_read_inode2(struct inode * inode, void *p) ;
-void reiserfs_delete_inode (struct inode * inode);
-void reiserfs_write_inode (struct inode * inode, int) ;
-struct dentry *reiserfs_fh_to_dentry(struct super_block *sb, __u32 *data,
-									 int len, int fhtype, int parent);
-int reiserfs_dentry_to_fh(struct dentry *dentry, __u32 *data, int *lenp, int need_parent);
+/* inode.c */
 
-int reiserfs_prepare_write(struct file *, struct page *, unsigned, unsigned) ;
-void reiserfs_truncate_file(struct inode *, int update_timestamps) ;
 void make_cpu_key (struct cpu_key * cpu_key, const struct inode * inode, loff_t offset,
 		   int type, int key_length);
 void make_le_item_head (struct item_head * ih, const struct cpu_key * key, 
 			int version,
 			loff_t offset, int type, int length, int entry_count);
+/*void store_key (struct key * key);
+void forget_key (struct key * key);*/
+int reiserfs_get_block (struct inode * inode, long block,
+			struct buffer_head * bh_result, int create);
 struct inode * reiserfs_iget (struct super_block * s, 
 			      const struct cpu_key * key);
+void reiserfs_read_inode (struct inode * inode) ;
+void reiserfs_read_inode2(struct inode * inode, void *p) ;
+void reiserfs_delete_inode (struct inode * inode);
+extern int reiserfs_notify_change(struct dentry * dentry, struct iattr * attr);
+void reiserfs_write_inode (struct inode * inode, int) ;
 
+/* nfsd support functions */
+struct dentry *reiserfs_fh_to_dentry(struct super_block *sb, __u32 *fh, int len, int fhtype, int parent);
+int reiserfs_dentry_to_fh(struct dentry *, __u32 *fh, int *lenp, int need_parent);
+
+/* we don't mark inodes dirty, we just log them */
+static inline void reiserfs_dirty_inode (struct inode * inode) {
+  reiserfs_write_inode(inode, 0) ;
+}
 
 struct inode * reiserfs_new_inode (struct reiserfs_transaction_handle *th, 
 				   const struct inode * dir, int mode, 
@@ -1807,7 +1819,7 @@ extern struct file_operations reiserfs_d
 
 /* tail_conversion.c */
 int direct2indirect (struct reiserfs_transaction_handle *, struct inode *, struct path *, struct buffer_head *, loff_t);
-int indirect2direct (struct reiserfs_transaction_handle *, struct inode *, struct page *, struct path *, const struct cpu_key *, loff_t, char *);
+int indirect2direct (struct reiserfs_transaction_handle *, struct inode *, struct path *, struct cpu_key *, loff_t, char *);
 void reiserfs_unmap_buffer(struct buffer_head *) ;
 
 
@@ -1821,30 +1833,21 @@ int get_new_buffer (struct reiserfs_tran
 
 /* buffer2.c */
 struct buffer_head * reiserfs_getblk (kdev_t n_dev, int n_block, int n_size);
-void wait_buffer_until_released (const struct buffer_head * bh);
-struct buffer_head * reiserfs_bread (struct super_block *super, int n_block, 
-				     int n_size);
+void wait_buffer_until_released (struct buffer_head * bh);
+struct buffer_head * reiserfs_bread (kdev_t n_dev, int n_block, int n_size);
+
 
 /* fix_nodes.c */
-#ifdef CONFIG_REISERFS_CHECK
 void * reiserfs_kmalloc (size_t size, int flags, struct super_block * s);
 void reiserfs_kfree (const void * vp, size_t size, struct super_block * s);
-#else
-#define reiserfs_kmalloc(x, y, z) kmalloc(x, y)
-#define reiserfs_kfree(x, y, z) kfree(x)
-#endif
-
-int fix_nodes (int n_op_mode, struct tree_balance * p_s_tb, 
-	       struct item_head * p_s_ins_ih, const void *);
+int fix_nodes (int n_op_mode, struct tree_balance * p_s_tb, struct item_head * p_s_ins_ih, const void *);
 void unfix_nodes (struct tree_balance *);
 void free_buffers_in_tb (struct tree_balance * p_s_tb);
 
 
 /* prints.c */
-void reiserfs_panic (struct super_block * s, const char * fmt, ...)
-__attribute__ ( ( noreturn ) );/* __attribute__( ( format ( printf, 2, 3 ) ) ) */
-void reiserfs_debug (struct super_block *s, int level, const char * fmt, ...);
-/* __attribute__( ( format ( printf, 3, 4 ) ) ); */
+void reiserfs_panic (struct super_block * s, const char * fmt, ...);
+void reiserfs_warning (const char * fmt, ...);
 void print_virtual_node (struct virtual_node * vn);
 void print_indirect_item (struct buffer_head * bh, int item_num);
 void store_print_tb (struct tree_balance * tb);
@@ -1927,45 +1930,38 @@ __u32 r5_hash (const signed char *msg, i
 /* version.c */
 const char *reiserfs_get_version_string(void) CONSTF;
 
-/* the ext2 bit routines adjust for big or little endian as
-** appropriate for the arch, so in our laziness we use them rather
-** than using the bit routines they call more directly.  These
-** routines must be used when changing on disk bitmaps.  */
+/* the ext2 bit routines handle do little endian bit operations when used
+** on big endian machines.  These must be used when changing on disk
+** bitmaps.
+*/
 #define reiserfs_test_and_set_le_bit   ext2_set_bit
 #define reiserfs_test_and_clear_le_bit ext2_clear_bit
 #define reiserfs_test_le_bit           ext2_test_bit
 #define reiserfs_find_next_zero_le_bit ext2_find_next_zero_bit
 
+				/* This has no comment explaining that
+                                   it is space reserved for fsck, nor
+                                   does it give any guidance to
+                                   palmtop folks on how much they can
+                                   get away with reducing
+                                   this. Finally, why is it in this
+                                   file, what does it have to do with
+                                   super block operations?  Actually,
+                                   an even better question might be,
+                                   why is this file separate from
+                                   reiserfs_fs.h at all?  Then let us
+                                   ask, why is that named
+                                   reiserfs_fs.h rather than
+                                   reiser_fs.h? -Hans */
 /* sometimes reiserfs_truncate may require to allocate few new blocks
    to perform indirect2direct conversion. People probably used to
    think, that truncate should work without problems on a filesystem
    without free disk space. They may complain that they can not
-   truncate due to lack of free disk space. This spare space allows us
-   to not worry about it. 500 is probably too much, but it should be
+   truncate due to lack of free disk space. This space space allows us
+   to not worry about it. 500 is probably to much, but it should be
    absolutely safe */
 #define SPARE_SPACE 500
 
-static inline unsigned long reiserfs_get_journal_block(const struct super_block *s) {
-    return le32_to_cpu(SB_DISK_SUPER_BLOCK(s)->s_journal_block) ;
-}
-static inline unsigned long reiserfs_get_journal_orig_size(const struct super_block *s) {
-    return le32_to_cpu(SB_DISK_SUPER_BLOCK(s)->s_orig_journal_size) ;
-}
-
-/* prototypes from ioctl.c */
-int reiserfs_ioctl (struct inode * inode, struct file * filp, 
- 		    unsigned int cmd, unsigned long arg);
-int reiserfs_unpack (struct inode * inode, struct file * filp);
- 
-/* ioctl's command */
-#define REISERFS_IOC_UNPACK		_IOW(0xCD,1,long)
-/* define following flags to be the same as in ext2, so that chattr(1),
-   lsattr(1) will work with us. */
-#define REISERFS_IOC_GETFLAGS           EXT2_IOC_GETFLAGS
-#define REISERFS_IOC_SETFLAGS           EXT2_IOC_SETFLAGS
-#define REISERFS_IOC_GETVERSION 	EXT2_IOC_GETVERSION
-#define REISERFS_IOC_SETVERSION         EXT2_IOC_SETVERSION
- 			         
 #endif /* _LINUX_REISER_FS_H */
 
 
diff -urp linux/include/linux/reiserfs_fs_i.h new_kernel_src/include/linux/reiserfs_fs_i.h
--- linux/include/linux/reiserfs_fs_i.h	2009-06-10 21:00:37.000000000 +0100
+++ new_kernel_src/include/linux/reiserfs_fs_i.h	2002-03-25 03:37:32.000000000 +0000
@@ -1,52 +1,62 @@
 #ifndef _REISER_FS_I
 #define _REISER_FS_I
 
-#include <linux/list.h>
-
-/** bitmasks for i_flags field in reiserfs-specific part of inode */
-typedef enum {
-    /** this says what format of key do all items (but stat data) of
-	an object have.  If this is set, that format is 3.6 otherwise
-	- 3.5 */
-    i_item_key_version_mask    =  0x0001,
-    /** If this is unset, object has 3.5 stat data, otherwise, it has
-	3.6 stat data with 64bit size, 32bit nlink etc. */
-    i_stat_data_version_mask   =  0x0002,
-    /** file might need tail packing on close */
-    i_pack_on_close_mask       =  0x0004,
-    /** don't pack tail of file */
-    i_nopack_mask              =  0x0008,
-    /** If those is set, "safe link" was created for this file during
-	truncate or unlink. Safe link is used to avoid leakage of disk
-	space on crash with some files open, but unlinked. */
-    i_link_saved_unlink_mask   =  0x0010,
-    i_link_saved_truncate_mask =  0x0020
-} reiserfs_inode_flags;
+#define REISERFS_N_BLOCKS 10
 
+#include <linux/list.h>
 
 struct reiserfs_inode_info {
-    __u32 i_key [4];/* key is still 4 32 bit integers */
-  
-    /** transient inode flags that are never stored on disk. Bitmasks
-	for this field are defined above. */
-    __u32 i_flags;
-
-    __u32 i_first_direct_byte; // offset of first byte stored in direct item.
-
-    /* copy of persistent inode flags read from sd_attrs. */
-    __u32 i_attrs;
-
-    int i_prealloc_block; /* first unused block of a sequence of unused blocks */
-    int i_prealloc_count; /* length of that sequence */
-    struct list_head i_prealloc_list;	/* per-transaction list of inodes which
-					 * have preallocated blocks */
-  
-    /* we use these for fsync or O_SYNC to decide which transaction
-    ** needs to be committed in order for this inode to be properly
-    ** flushed */
-    unsigned long i_trans_id ;
-    unsigned long i_trans_index ;
+  //struct pipe_inode_info reserved;
+  __u32 i_key [4];/* key is still 4 32 bit integer */
+  int i_version;  // this says whether file is old or new
+
+  // FIXME: do we need both now?
+  atomic_t i_is_being_converted;
+
+  int i_pack_on_close ; // file might need tail packing on close 
+  //atomic_t i_read_sync_counter;
+  //atomic_t i_converted;
+  /* this is set when direct2indirect has been
+			   performed. Unset when i_count gets to 0 in
+			   iput */
+
+  __u32 i_first_direct_byte; // offset of first byte stored in direct item.
+  //int i_has_tail; // 1 if file has bytes stored in direct item(s), 0 otherwise
+
+  int i_data_length;
+  __u32 i_data [REISERFS_N_BLOCKS];
+
+  /* pointer to the page that must be flushed before 
+  ** the current transaction can commit.
+  **
+  ** this pointer is only used when the tail is converted back into
+  ** a direct item, or the file is deleted
+  */
+  struct reiserfs_page_list *i_converted_page ;
+
+  /* we save the id of the transaction when we did the direct->indirect
+  ** conversion.  That allows us to flush the buffers to disk
+  ** without having to upate this inode to zero out the converted
+  ** page variable
+  */
+  int i_conversion_trans_id ;
+
+				/* So is this an extent, or what? What
+                                   happens when the disk is badly
+                                   fragmented? I would prefer a list
+                                   of blocks, and I would prefer that
+                                   you simply take the first
+                                   PREALLOC_SIZE blocks after
+                                   search_start and put them on the
+                                   list, contiguous or not. Maybe I
+                                   don't fully understand this code. I
+                                   really prefer allocate on flush
+                                   conceptually..... -Hans */
+  //For preallocation
+  int i_prealloc_block;
+  int i_prealloc_count;
+
 };
 
-#endif
 
+#endif
diff -urp linux/include/linux/reiserfs_fs_sb.h new_kernel_src/include/linux/reiserfs_fs_sb.h
--- linux/include/linux/reiserfs_fs_sb.h	2009-06-10 21:00:37.000000000 +0100
+++ new_kernel_src/include/linux/reiserfs_fs_sb.h	2002-03-25 03:37:32.000000000 +0000
@@ -3,10 +3,8 @@
 
 #ifndef _LINUX_REISER_FS_SB
 #define _LINUX_REISER_FS_SB
-
-#ifdef __KERNEL__
+                                
 #include <linux/tqueue.h>
-#endif
 
 //
 // super block's field values
@@ -19,7 +17,7 @@
 #define TEA_HASH  1
 #define YURA_HASH 2
 #define R5_HASH   3
-#define DEFAULT_HASH R5_HASH
+#define DEFAULT_HASH TEA_HASH
 
 /* this is the on disk super block */
 
@@ -38,8 +36,6 @@ struct reiserfs_super_block
   ** while mounting (inside journal_init) prevent that from happening
   */
 
-				/* great comment Chris. Thanks.  -Hans */
-
   __u32 s_orig_journal_size; 		
   __u32 s_journal_trans_max ;           /* max number of blocks in a transaction.  */
   __u32 s_journal_block_count ;         /* total size of the journal. can change over time  */
@@ -51,7 +47,7 @@ struct reiserfs_super_block
   __u16 s_oid_cursize;			/* current size of object id array */
   __u16 s_state;                       	/* valid or error       */
   char s_magic[12];                     /* reiserfs magic string indicates that file system is reiserfs */
-  __u32 s_hash_function_code;		/* indicate, what hash function is being use to sort names in a directory*/
+  __u32 s_hash_function_code;		/* indicate, what hash fuction is being use to sort names in a directory*/
   __u16 s_tree_height;                  /* height of disk tree */
   __u16 s_bmap_nr;                      /* amount of bitmap blocks needed to address each block of file system */
   __u16 s_version;		/* I'd prefer it if this was a string,
@@ -59,20 +55,8 @@ struct reiserfs_super_block
                                    16 bytes long mostly unused. We
                                    don't need to save bytes in the
                                    superblock. -Hans */
-  __u16 s_reserved;
-  __u32 s_inode_generation;
-  __u32 s_flags;		       /* Right now used only by inode-attributes, if enabled */
-  unsigned char s_uuid[16];            /* filesystem unique identifier */
-  unsigned char s_label[16];           /* filesystem volume label */
-  char s_unused[88] ;                  /* zero filled by mkreiserfs and
-                                        * reiserfs_convert_objectid_map_v1()
-                                        * so any additions must be updated
-                                        * there as well. */
-} __attribute__ ((__packed__));
-
-typedef enum {
-  reiserfs_attrs_cleared       = 0x00000001,
-} reiserfs_super_block_flags;
+  char s_unused[128] ;			/* zero filled by mkreiserfs */
+};
 
 #define SB_SIZE (sizeof(struct reiserfs_super_block))
 /* struct reiserfs_super_block accessors/mutators
@@ -148,8 +132,8 @@ struct reiserfs_super_block_v1
   char s_magic[16];                     /* reiserfs magic string indicates that file system is reiserfs */
   __u16 s_tree_height;                  /* height of disk tree */
   __u16 s_bmap_nr;                      /* amount of bitmap blocks needed to address each block of file system */
-  __u32 s_reserved;
-} __attribute__ ((__packed__));
+  __u16 s_reserved;
+};
 
 #define SB_SIZE_V1 (sizeof(struct reiserfs_super_block_v1))
 
@@ -182,7 +166,7 @@ struct reiserfs_super_block_v1
 #define JOURNAL_MAX_CNODE   1500 /* max cnodes to allocate. */
 #define JOURNAL_TRANS_MAX 1024   /* biggest possible single transaction, don't change for now (8/3/99) */
 #define JOURNAL_HASH_SIZE 8192   
-#define JOURNAL_NUM_BITMAPS 5 /* number of copies of the bitmaps to have floating.  Must be >= 2 */
+#define JOURNAL_NUM_BITMAPS 3 /* number of copies of the bitmaps to have floating.  Must be >= 2 */
 #define JOURNAL_LIST_COUNT 64
 
 /* these are bh_state bit flag offset numbers, for use in the buffer head */
@@ -204,7 +188,7 @@ struct reiserfs_super_block_v1
 ** hash of all the in memory transactions.
 ** next and prev are used by the current transaction (journal_hash).
 ** hnext and hprev are used by journal_list_hash.  If a block is in more than one transaction, the journal_list_hash
-** links it in multiple times.  This allows flush_journal_list to remove just the cnode belonging
+** links it in multiple times.  This allows the end_io handler, and flush_journal_list to remove just the cnode belonging
 ** to a given transaction.
 */
 struct reiserfs_journal_cnode {
@@ -219,15 +203,14 @@ struct reiserfs_journal_cnode {
   struct reiserfs_journal_cnode *hnext ; /* next in hash list */
 };
 
-struct reiserfs_bitmap_node {
-  int id ;
-  char *data ;
-  struct list_head list ;
-} ;
+				/* oooh boy does this need
+                                   commenting. I want a full length
+                                   paragraph on our multiple bitmap
+                                   architecture. -Hans */
 
 struct reiserfs_list_bitmap {
-  struct reiserfs_journal_list *journal_list ;
-  struct reiserfs_bitmap_node **bitmaps ;
+  struct reiserfs_journal_list *journal_list;  /* used to flush the commit when this one needs to be reused */
+  char *bitmap ;   /* the bitmap */
 } ;
 
 /*
@@ -236,20 +219,34 @@ struct reiserfs_list_bitmap {
 struct reiserfs_transaction_handle {
 				/* ifdef it. -Hans */
   char *t_caller ;              /* debugging use */
-  int t_blocks_logged ;         /* number of blocks this writer has logged */
+  int t_blocks_logged ;         /* number of blocks this writer has actually logged */
+				/* is the allocation of blocks to writers explained somewhere? -Hans */
   int t_blocks_allocated ;      /* number of blocks this writer allocated */
-  unsigned long t_trans_id ;    /* sanity check, equals the current trans id */
-  struct super_block *t_super ; /* super for this FS when journal_begin was 
-                                   called. saves calls to reiserfs_get_super */
+  unsigned long t_trans_id ;    /* sanity check, should equal the current trans id */
+  struct super_block *t_super ; /* super for this FS when journal_begin was called. saves calls to reiserfs_get_super */
+
 } ;
 
 /*
+
+so why is it called a journal list if there is one per transaction,
+and not a transaction list.  Hmmm.  Maybe if transaction and journal
+as used by your code were conceptually defined somewhere I'd know the
+answer. -Hans
+
 ** one of these for each transaction.  The most important part here is the j_realblock.
 ** this list of cnodes is used to hash all the blocks in all the commits, to mark all the
 ** real buffer heads dirty once all the commits hit the disk,
 ** and to make sure every real block in a transaction is on disk before allowing the log area
 ** to be overwritten */
 struct reiserfs_journal_list {
+				/* per field comments? You could at
+                                   least indicate that these things
+                                   are blocknumbers.  Hmmm.  We need a
+                                   blocknr typedef so that we can go
+                                   to 40+ bit blocknumbers without an
+                                   excess of pain. The next new
+                                   programmer we hire.  -Hans */
   unsigned long j_start ;
   unsigned long j_len ;
   atomic_t j_nonzerolen ;
@@ -273,8 +270,8 @@ struct reiserfs_journal {
   struct buffer_head ** j_ap_blocks ; /* journal blocks on disk */
   struct reiserfs_journal_cnode *j_last ; /* newest journal block */
   struct reiserfs_journal_cnode *j_first ; /*  oldest journal block.  start here for traverse */
-				
-  long j_state ;			
+				/* comment? -Hans */
+  int j_state ;			
   unsigned long j_trans_id ;
   unsigned long j_mount_id ;
   unsigned long j_start ;             /* start of current waiting commit (index into j_ap_blocks) */
@@ -307,10 +304,6 @@ struct reiserfs_journal {
   struct reiserfs_journal_cnode *j_cnode_free_list ;
   struct reiserfs_journal_cnode *j_cnode_free_orig ; /* orig pointer returned from vmalloc */
 
-  int j_free_bitmap_nodes ;
-  int j_used_bitmap_nodes ;
-  struct list_head j_bitmap_nodes ;
-  struct inode j_dummy_inode ;
   struct reiserfs_list_bitmap j_list_bitmap[JOURNAL_NUM_BITMAPS] ;	/* array of bitmaps to record the deleted blocks */
   struct reiserfs_journal_list j_journal_list[JOURNAL_LIST_COUNT] ;	    /* array of all the journal lists */
   struct reiserfs_journal_cnode *j_hash_table[JOURNAL_HASH_SIZE] ; 	    /* hash table for real buffer heads in current trans */ 
@@ -402,8 +395,6 @@ typedef struct reiserfs_proc_info_data
 struct reiserfs_sb_info
 {
     struct buffer_head * s_sbh;                   /* Buffer containing the super block */
-				/* both the comment and the choice of
-                                   name are unclear for s_rs -Hans */
     struct reiserfs_super_block * s_rs;           /* Pointer to the super block in the buffer */
     struct buffer_head ** s_ap_bitmap;       /* array of buffers, holding block bitmap */
     struct reiserfs_journal *s_journal ;		/* pointer to journal information */
@@ -473,38 +464,17 @@ struct reiserfs_sb_info
 #define FORCE_R5_HASH 8       /* try to force rupasov hash on mount */
 #define FORCE_HASH_DETECT 9   /* try to detect hash function on mount */
 
-
-/* used for testing experimental features, makes benchmarking new
-   features with and without more convenient, should never be used by
-   users in any code shipped to users (ideally) */
-
-#define REISERFS_NO_BORDER 11
-#define REISERFS_NO_UNHASHED_RELOCATION 12
-#define REISERFS_HASHED_RELOCATION 13
-#define REISERFS_TEST4 14 
-
-#define REISERFS_TEST1 11
-#define REISERFS_TEST2 12
-#define REISERFS_TEST3 13
-#define REISERFS_TEST4 14 
-
 #define REISERFS_ATTRS (15)
 
 #define reiserfs_r5_hash(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << FORCE_R5_HASH))
 #define reiserfs_rupasov_hash(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << FORCE_RUPASOV_HASH))
 #define reiserfs_tea_hash(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << FORCE_TEA_HASH))
 #define reiserfs_hash_detect(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << FORCE_HASH_DETECT))
-#define reiserfs_no_border(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REISERFS_NO_BORDER))
-#define reiserfs_no_unhashed_relocation(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REISERFS_NO_UNHASHED_RELOCATION))
-#define reiserfs_hashed_relocation(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REISERFS_HASHED_RELOCATION))
-#define reiserfs_test4(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REISERFS_TEST4))
 
 #define dont_have_tails(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << NOTAIL))
 #define replay_only(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REPLAYONLY))
 #define reiserfs_dont_log(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REISERFS_NOLOG))
-#define reiserfs_attrs(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REISERFS_ATTRS))
-#define old_format_only(s) ((s)->u.reiserfs_sb.s_properties & (1 << REISERFS_3_5))
-#define convert_reiserfs(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REISERFS_CONVERT))
+#define old_format_only(s) ((le16_to_cpu(SB_VERSION(s)) != REISERFS_VERSION_2) && !((s)->u.reiserfs_sb.s_mount_opt & (1 << REISERFS_CONVERT)))
 
 
 void reiserfs_file_buffer (struct buffer_head * bh, int list);
@@ -512,6 +482,8 @@ int reiserfs_is_super(struct super_block
 int journal_mark_dirty(struct reiserfs_transaction_handle *, struct super_block *, struct buffer_head *bh) ;
 int flush_old_commits(struct super_block *s, int) ;
 int show_reiserfs_locks(void) ;
+void reiserfs_end_buffer_io_sync (struct buffer_head *bh, int uptodate) ; 
+void reiserfs_journal_end_io(struct buffer_head *bh, int uptodate) ;
 int reiserfs_resize(struct super_block *, unsigned long) ;
 
 #define CARRY_ON                0
@@ -527,22 +499,15 @@ int reiserfs_resize(struct super_block *
 
 
 // on-disk super block fields converted to cpu form
-#define SB_DISK_SUPER_BLOCK(s)        ((s)->u.reiserfs_sb.s_rs)
-#define SB_BLOCK_COUNT(s)             sb_block_count (SB_DISK_SUPER_BLOCK(s))
-#define SB_FREE_BLOCKS(s)             sb_free_blocks (SB_DISK_SUPER_BLOCK(s))
-#define SB_REISERFS_MAGIC(s)          (SB_DISK_SUPER_BLOCK(s)->s_magic)
-#define SB_ROOT_BLOCK(s)              sb_root_block (SB_DISK_SUPER_BLOCK(s))
-#define SB_TREE_HEIGHT(s)             sb_tree_height (SB_DISK_SUPER_BLOCK(s))
-#define SB_REISERFS_STATE(s)          sb_state (SB_DISK_SUPER_BLOCK(s))
-#define SB_VERSION(s)                 sb_version (SB_DISK_SUPER_BLOCK(s))
-#define SB_BMAP_NR(s)                 sb_bmap_nr(SB_DISK_SUPER_BLOCK(s))
-
-#define PUT_SB_BLOCK_COUNT(s, val)    do { set_sb_block_count( SB_DISK_SUPER_BLOCK(s), val); } while (0)
-#define PUT_SB_FREE_BLOCKS(s, val)    do { set_sb_free_blocks( SB_DISK_SUPER_BLOCK(s), val); } while (0)
-#define PUT_SB_ROOT_BLOCK(s, val)     do { set_sb_root_block( SB_DISK_SUPER_BLOCK(s), val); } while (0)
-#define PUT_SB_TREE_HEIGHT(s, val)    do { set_sb_tree_height( SB_DISK_SUPER_BLOCK(s), val); } while (0)
-#define PUT_SB_REISERFS_STATE(s, val) do { set_sb_state( SB_DISK_SUPER_BLOCK(s), val); } while (0) 
-#define PUT_SB_VERSION(s, val)        do { set_sb_version( SB_DISK_SUPER_BLOCK(s), val); } while (0)
-#define PUT_SB_BMAP_NR(s, val)        do { set_sb_bmap_nr( SB_DISK_SUPER_BLOCK(s), val); } while (0)
+#define SB_DISK_SUPER_BLOCK(s) ((s)->u.reiserfs_sb.s_rs)
+#define SB_JOURNAL_BLOCK(s) le32_to_cpu ((SB_DISK_SUPER_BLOCK(s)->s_journal_block))
+#define SB_BLOCK_COUNT(s) le32_to_cpu ((SB_DISK_SUPER_BLOCK(s)->s_block_count))
+#define SB_FREE_BLOCKS(s) le32_to_cpu ((SB_DISK_SUPER_BLOCK(s)->s_free_blocks))
+#define SB_REISERFS_MAGIC(s) (SB_DISK_SUPER_BLOCK(s)->s_magic)
+#define SB_ROOT_BLOCK(s) le32_to_cpu ((SB_DISK_SUPER_BLOCK(s)->s_root_block))
+#define SB_TREE_HEIGHT(s) le16_to_cpu ((SB_DISK_SUPER_BLOCK(s)->s_tree_height))
+#define SB_REISERFS_STATE(s) le16_to_cpu ((SB_DISK_SUPER_BLOCK(s)->s_state))
+#define SB_VERSION(s) le16_to_cpu ((SB_DISK_SUPER_BLOCK(s)->s_version))
+#define SB_BMAP_NR(s) le16_to_cpu ((SB_DISK_SUPER_BLOCK(s)->s_bmap_nr))
 
 #endif	/* _LINUX_REISER_FS_SB */
diff -urp linux/include/linux/timex.h new_kernel_src/include/linux/timex.h
--- linux/include/linux/timex.h	2001-11-22 19:46:18.000000000 +0000
+++ new_kernel_src/include/linux/timex.h	2002-03-25 03:37:32.000000000 +0000
@@ -286,6 +286,11 @@ extern long pps_calcnt;		/* calibration 
 extern long pps_errcnt;		/* calibration errors */
 extern long pps_stbcnt;		/* stability limit exceeded */
 
+/* UAE high precision timer interface */
+extern unsigned long current_latch; /* The current latch value for the timer chip */
+extern unsigned long long uae_alert; /* When to start checking timers */
+extern unsigned long long uae_nextevent; /* When to next trigger */
+extern void uae_trigger(void);
 #endif /* KERNEL */
 
 #endif /* LINUX_TIMEX_H */
Only in new_kernel_src/include/linux: uae.h
Only in new_kernel_src/include/linux: version.h
Only in new_kernel_src/include/net: slhc.h
diff -urp linux/init/main.c new_kernel_src/init/main.c
--- linux/init/main.c	2009-06-10 21:00:37.000000000 +0100
+++ new_kernel_src/init/main.c	2002-03-25 03:19:25.000000000 +0000
@@ -387,6 +387,7 @@ asmlinkage void __init start_kernel(void
 	sti();
 	calibrate_delay();
 #ifdef CONFIG_BLK_DEV_INITRD
+	printk("looking at initrd early on!\n");
 	if (initrd_start && !initrd_below_start_ok &&
 			initrd_start < min_low_pfn << PAGE_SHIFT) {
 		printk(KERN_CRIT "initrd overwritten (0x%08lx < 0x%08lx) - "
diff -urp linux/kernel/ksyms.c new_kernel_src/kernel/ksyms.c
--- linux/kernel/ksyms.c	2009-06-10 21:00:37.000000000 +0100
+++ new_kernel_src/kernel/ksyms.c	2002-03-25 03:10:34.000000000 +0000
@@ -162,7 +162,6 @@ EXPORT_SYMBOL(d_alloc);
 EXPORT_SYMBOL(d_lookup);
 EXPORT_SYMBOL(__d_path);
 EXPORT_SYMBOL(mark_buffer_dirty);
-EXPORT_SYMBOL(set_buffer_async_io); /* for reiserfs_writepage */
 EXPORT_SYMBOL(__mark_buffer_dirty);
 EXPORT_SYMBOL(__mark_inode_dirty);
 EXPORT_SYMBOL(get_empty_filp);
diff -urp linux/kernel/printk.c new_kernel_src/kernel/printk.c
--- linux/kernel/printk.c	2009-06-10 21:00:37.000000000 +0100
+++ new_kernel_src/kernel/printk.c	2002-03-25 03:10:34.000000000 +0000
@@ -149,7 +149,23 @@ static int __init console_setup(char *st
 	return 1;
 }
 
+
+/*
+ *	Set console log level at boot time
+ */
+static int __init console_level_setup(char *str)
+{
+  int level=0;
+
+  while (str[0] >= '0' && str[0] <= '9') {
+    level=10*level+str[0]-'0';
+    str++;
+  }
+  console_loglevel = level;
+}
+
 __setup("console=", console_setup);
+__setup("console_level=", console_level_setup);
 
 /*
  * Commands to do_syslog:
@@ -164,6 +180,7 @@ __setup("console=", console_setup);
  * 	7 -- Enable printk's to console
  *	8 -- Set level of messages printed to console
  *	9 -- Return number of unread characters in the log buffer
+ *    102 -- same as 2, but non-blocking
  */
 int do_syslog(int type, char * buf, int len)
 {
@@ -177,6 +194,7 @@ int do_syslog(int type, char * buf, int 
 		break;
 	case 1:		/* Open log */
 		break;
+	case 102:
 	case 2:		/* Read from log */
 		error = -EINVAL;
 		if (!buf || len < 0)
@@ -187,12 +205,13 @@ int do_syslog(int type, char * buf, int 
 		error = verify_area(VERIFY_WRITE,buf,len);
 		if (error)
 			goto out;
-		error = wait_event_interruptible(log_wait, (log_start - log_end));
+		error = wait_event_interruptible(log_wait, 
+						 log_start-log_end||(type==102));
 		if (error)
 			goto out;
 		i = 0;
 		spin_lock_irq(&logbuf_lock);
-		while ((log_start != log_end) && i < len) {
+		while (log_start != log_end && i < len) {
 			c = LOG_BUF(log_start);
 			log_start++;
 			spin_unlock_irq(&logbuf_lock);
@@ -299,6 +318,9 @@ asmlinkage long sys_syslog(int type, cha
 	return do_syslog(type, buf, len);
 }
 
+/* This (and where it is used) really belong into #ifdef's. Too lazy :/ */
+extern int fbcon_show_logo(void);
+
 /*
  * Call the console drivers on a range of log_buf
  */
@@ -471,6 +493,7 @@ asmlinkage int printk(const char *fmt, .
 		spin_unlock_irqrestore(&logbuf_lock, flags);
 	}
 out:
+	fbcon_show_logo(); /* move the logo around */
 	return printed_len;
 }
 EXPORT_SYMBOL(printk);
diff -urp linux/kernel/sched.c new_kernel_src/kernel/sched.c
--- linux/kernel/sched.c	2001-12-21 17:42:04.000000000 +0000
+++ new_kernel_src/kernel/sched.c	2002-02-08 08:32:14.000000000 +0000
@@ -127,6 +127,12 @@ extern struct task_struct *child_reaper;
 
 void scheduling_functions_start_here(void) { }
 
+
+/* This lets us mess easily with the scheduler, to improve AmigaOS
+   interrupt response time in the face of disk I/O */
+unsigned long process_to_elevate=0;
+int do_elevate_process=0;
+
 /*
  * This is the function that decides how desirable a process is..
  * You can weigh different processes against each other depending
@@ -190,6 +196,11 @@ static inline int goodness(struct task_s
 	 */
 	weight = 1000 + p->rt_priority;
 out:
+	if (process_to_elevate && 
+	    p->pid==process_to_elevate && 
+	    do_elevate_process 
+	    )
+	  return 2000; /* Run this before all other */
 	return weight;
 }
 
diff -urp linux/mm/bootmem.c new_kernel_src/mm/bootmem.c
--- linux/mm/bootmem.c	2001-12-21 17:42:04.000000000 +0000
+++ new_kernel_src/mm/bootmem.c	2002-02-08 08:32:14.000000000 +0000
@@ -98,6 +98,19 @@ static void __init reserve_bootmem_core(
 			printk("hm, page %08lx reserved twice.\n", i*PAGE_SIZE);
 }
 
+static int __init bootmem_is_reserved_core(bootmem_data_t *bdata, unsigned long addr)
+{
+	unsigned long i;
+	/*
+	 * round up, partially reserved pages are considered
+	 * fully reserved.
+	 */
+	unsigned long sidx = (addr - bdata->node_boot_start)/PAGE_SIZE;
+	if (test_bit(sidx, bdata->node_bootmem_map))
+	  return 1;
+	return 0;
+}
+
 static void __init free_bootmem_core(bootmem_data_t *bdata, unsigned long addr, unsigned long size)
 {
 	unsigned long i;
@@ -311,6 +324,11 @@ void __init reserve_bootmem (unsigned lo
 	reserve_bootmem_core(contig_page_data.bdata, addr, size);
 }
 
+int __init bootmem_is_reserved (unsigned long addr)
+{
+  return bootmem_is_reserved_core(contig_page_data.bdata, addr);
+}
+
 void __init free_bootmem (unsigned long addr, unsigned long size)
 {
 	return(free_bootmem_core(contig_page_data.bdata, addr, size));

Only in new_kernel_src/scripts: cramfs
Only in new_kernel_src/scripts/lxdialog: checklist.o
Only in new_kernel_src/scripts/lxdialog: inputbox.o
Only in new_kernel_src/scripts/lxdialog: lxdialog
Only in new_kernel_src/scripts/lxdialog: lxdialog.o
Only in new_kernel_src/scripts/lxdialog: menubox.o
Only in new_kernel_src/scripts/lxdialog: msgbox.o
Only in new_kernel_src/scripts/lxdialog: textbox.o
Only in new_kernel_src/scripts/lxdialog: util.o
Only in new_kernel_src/scripts/lxdialog: yesno.o
Only in new_kernel_src/scripts: mkdep
Only in new_kernel_src/scripts: split-include
